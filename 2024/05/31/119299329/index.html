<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>10万字208道Java经典面试题总结(附答案) | Mybbs</title><meta name="keywords" content="教程,github,java"><meta name="author" content="Mybbs —— 开源MC社区"><meta name="copyright" content="Mybbs —— 开源MC社区"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="10万字208道Java经典面试题总结(附答案)"><meta name="application-name" content="10万字208道Java经典面试题总结(附答案)"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="10万字208道Java经典面试题总结(附答案)"><meta property="og:url" content="https://bianb-hehe.github.io/2024/05/31/119299329/index.html"><meta property="og:site_name" content="Mybbs"><meta property="og:description" content="🍅 作者简介：哪吒，CSDN2021博客之星亚军🏆、新星计划导师✌、博客专家💪🍅 哪吒多年工作总结：Java学习路线总结，搬砖工逆袭Java架构师🍅 技术交流：定期更新Java硬核干货，不定期送书活动🍅 关注公众号【哪吒编程】，回复 面试题，获取《10万字208道Java经典面试题总结"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.9a6de07448a467a377b44596d9ae5da0?rik=8WbMsGmKuRB5XA&amp;riu=http%3a%2f%2fpic.2265.com%2fupload%2f2021-8%2f2021810928385817.png&amp;ehk=Xi9L%2fFaaTMGPUxE7TnAHh3CKp6VDRo44YeVHbgK3Auk%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0"><meta property="article:author" content="Mybbs —— 开源MC社区"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.9a6de07448a467a377b44596d9ae5da0?rik=8WbMsGmKuRB5XA&amp;riu=http%3a%2f%2fpic.2265.com%2fupload%2f2021-8%2f2021810928385817.png&amp;ehk=Xi9L%2fFaaTMGPUxE7TnAHh3CKp6VDRo44YeVHbgK3Auk%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0"><meta name="description" content="🍅 作者简介：哪吒，CSDN2021博客之星亚军🏆、新星计划导师✌、博客专家💪🍅 哪吒多年工作总结：Java学习路线总结，搬砖工逆袭Java架构师🍅 技术交流：定期更新Java硬核干货，不定期送书活动🍅 关注公众号【哪吒编程】，回复 面试题，获取《10万字208道Java经典面试题总结"><link rel="shortcut icon" href="https://img.pixelbbs.cn/LightPicture/2024/05/642ae2f5e0e131a7.ico"><link rel="canonical" href="https://bianb-hehe.github.io/2024/05/31/119299329/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Mybbs —— 开源MC社区","link":"链接: ","source":"来源: Mybbs","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Mybbs',
  title: '10万字208道Java经典面试题总结(附答案)',
  postAI: '',
  pageFillDescription: '前言, 1、JDK 和 JRE 有什么区别？, 2、== 和 equals 的区别是什么？, 3、final 在 java 中有什么作用？, 4、java 中的 Math.round(-1.5) 等于多少？, 5、String 属于基础的数据类型吗？, 6、String str=i与 String str=new String(i)一样吗？, 7、如何将字符串反转？, 8、String 类的常用方法都有那些？, 9、new String(a) + new String(b) 会创建几个对象？, 10、如何将字符串反转？, 11、String 类的常用方法都有那些？, 12、普通类和抽象类有哪些区别？, 13、接口和抽象类有什么区别？, 14、java 中 IO 流分为几种？, 15、BIO、NIO、AIO 有什么区别？, 16、Files的常用方法都有哪些？, 17、什么是反射？, 18、什么是 java 序列化？什么情况下需要序列化？, 19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？, 20、throw 和 throws 的区别？, 21、final、finally、finalize 有什么区别？, 22、try-catch-finally 中如果 catch 中 return 了finally 还会执行吗？, 23、常见的异常类有哪些？, 24、hashcode是什么？有什么作用？, 25、java 中操作字符串都有哪些类？它们之间有什么区别？, 26、java 中都有哪些引用类型？, 27、在 Java 中为什么不允许从静态方法中访问非静态变量？, 28、说说Java Bean的命名规范, 29、Java Bean 属性命名规范问题分析, 30、什么是 Java 的内存模型?, 31、在 Java 中什么时候用重载什么时候用重写？, 32、举例说明什么情况下会更倾向于使用抽象类而不是接口？, 33、实例化对象有哪几种方式, 34、byte类型127+1等于多少, 35、Java 容器都有哪些？, 36、Collection 和 Collections 有什么区别？, 37、list与Set区别, 38、HashMap 和 Hashtable 有什么区别？, 39、说一下 HashMap 的实现原理？, 40、set有哪些实现类？, 41、说一下 HashSet 的实现原理？, 43、如何实现数组和 List 之间的转换？, 44、在 Queue 中 poll()和 remove()有什么区别？, 45、哪些集合类是线程安全的, 46、迭代器 Iterator 是什么？, 47、Iterator 怎么使用？有什么特点？, 48、Iterator 和 ListIterator 有什么区别？, 49、怎么确保一个集合不能被修改？, 50、队列和栈是什么？有什么区别？, 51、Java8开始ConcurrentHashMap为什么舍弃分段锁？, 52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？, 53、concurrentHashMap和HashTable有什么区别, 54、HasmMap和HashSet的区别, 55、请谈谈 ReadWriteLock 和 StampedLock, 56、线程的run()和start()有什么区别？, 57、为什么我们调用 start() 方法时会执行 run() 方法为什么我们不能直接调用 run() 方法？, 58、Synchronized 用过吗其原理是什么？, 59、JVM 对 Java 的原生锁做了哪些优化？, 60、为什么 wait() notify()和 notifyAll()必须在同步方法或者同步块中被调用？, 61、Java 如何实现多线程之间的通讯和协作？, 62、Thread 类中的 yield 方法有什么作用？, 63、为什么说 Synchronized 是非公平锁？, 64、请谈谈 volatile 有什么特点为什么它能保证变量对所有线程的可见性？, 65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS它有什么特性？, 66、乐观锁一定就是好的吗？, 67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。, 68、ReentrantLock 是如何实现可重入性的？, 69、什么是锁消除和锁粗化？, 70、跟 Synchronized 相比可重入锁 ReentrantLock 其实现原理有什么不同？, 71、那么请谈谈 AQS 框架是怎么回事儿？, 72、AQS 对资源的共享方式？, 73、如何让 Java 的线程彼此同步？, 74、你了解过哪些同步器？请分别介绍下。, 75、Java 中的线程池是如何实现的, 76、创建线程池的几个核心构造参数, 77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？, 78、volatile 关键字的作用, 79、既然 volatile 能够保证线程间的变量可见性是不是就意味着基于 volatile 变量的运算就是并发安全的？, 80、ThreadLocal 是什么？有哪些使用场景？, 81、请谈谈 ThreadLocal 是怎么解决并发安全的？, 82、很多人都说要慎用 ThreadLocal谈谈你的理解使用 ThreadLocal 需要注意些什么？, 83、为什么代码会重排序？, 84、什么是自旋, 85、多线程中 synchronized 锁升级的原理是什么？, 86、synchronized 和 ReentrantLock 区别是什么？, 87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？, 88、jsp 和 servlet 有什么区别？, 89、jsp 有哪些内置对象？作用分别是什么？, 90、forward 和 redirect 的区别？, 91、说一下 jsp 的 4 种作用域？, 92、session 和 cookie 有什么区别？, 93、如果客户端禁止 cookie 能实现 session 还能用吗？, 94、什么是上下文切换？, 95、cookie、session、token, 96、说一下 session 的工作原理？, 97、http 响应码 301 和 302 代表的是什么？有什么区别？, 98、简述 tcp 和 udp的区别？, 99、tcp 为什么要三次握手两次不行吗？为什么？, 100、OSI 的七层模型都有哪些？, 101、get 和 post 请求有哪些区别？, 102、什么是 XSS 攻击如何避免？, 103、什么是 CSRF 攻击如何避免？, 104、如何实现跨域？说一下 JSONP 实现原理？, 105、websocket应用的是哪个协议, 106、说一下 tcp 粘包是怎么产生的？, 107、请列举出在 JDK 中几个常用的设计模式？, 108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？, 109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式, 110、在 Java 中什么叫观察者设计模式（observer design pattern）？, 111、使用工厂模式最主要的好处是什么？在哪里使用？, 112、请解释自动装配模式的区别？, 113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？, 114、什么是 Spring 框架？Spring 框架有哪些主要模块？, 115、使用 Spring 框架能带来哪些好处？, 116、Spring IOC、AOP举例说明, 117、什么是控制反转(IOC)？什么是依赖注入？, 118、BeanFactory 和 ApplicationContext 有什么区别？, 119、什么是 JavaConfig？, 120、什么是 ORM 框架？, 121、Spring 有几种配置方式？, 122、请解释 Spring Bean 的生命周期？, 123、Spring Bean 的作用域之间有什么区别？ Spring容器中的bean可以分为5个范围：, 124、如何在 Spring Boot 中禁用 Actuator 端点安全性？, 125、什么是 Spring inner beans？, 126、Spring 框架中的单例 Beans 是线程安全的么？, 127、请解释 Spring Bean 的自动装配？, 128、如何开启基于注解的自动装配？, 129、什么是 Spring Batch？, 130、spring mvc 和 struts 的区别是什么？, 131、请举例解释@Required 注解？, 132、Spring常用注解, 133、项目中是如何实现权限验证的权限验证需要几张表, 134、谈谈controller接口调用的路径问题, 135、如何防止表单重复提交, 136、Spring中都应用了哪些设计模式, 137、请举例说明如何在 Spring 中注入一个 Java Collection？, 138、mybatis 中 {}和 ${}的区别是什么？, 139、mybatis 是否支持延迟加载？延迟加载的原理是什么？, 140、说一下 mybatis 的一级缓存和二级缓存？, 141、mybatis 有哪些执行器（Executor）？, 142、mybatis 和 hibernate 的区别有哪些？, 143、myBatis查询多个id、myBatis常用属性, 144、mybatis一级缓存、二级缓存, 145、mybatis如何防止sql注入, 146、hibernate 中如何在控制台查看打印的 sql 语句？, 147、hibernate 有几种查询方式？, 148、hibernate 实体类可以被定义为 final 吗？, 149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？, 150、什么是 Spring Boot？Spring Boot 有哪些优点？, 151、Spring Boot 中的监视器是什么？, 152、什么是 YAML？, 153、如何使用 Spring Boot 实现分页和排序？, 154、如何使用 Spring Boot 实现异常处理？, 155、单点登录, 156、Spring Boot比Spring多哪些注解, 157、打包和部署, 158、Spring Boot如何访问不同的数据库, 159、查询网站在线人数, 160、easyExcel如何实现, 161、什么是 Swagger？你用 Spring Boot 实现了它吗？, 162、数据库的三范式是什么？, 163、一张自增表里面总共有 7 条数据删除了最后 2 条数据重启 mysql 数据库又插入了一条数据此时 id 是几？, 164、如何获取当前数据库版本？, 165、说一下 ACID 是什么？, 166、char 和 varchar 的区别是什么？, 167、float 和 double 的区别是什么？, 168、Oracle分页sql, 169、数据库如何保证主键唯一性, 170、如何设计数据库, 171、性别是否适合做索引, 172、如何查询重复的数据, 173、数据库一般会采取什么样的优化方法？, 174、索引怎么定义分哪几种, 175、mysql 的内连接、左连接、右连接有什么区别？, 176、RabbitMQ的使用场景有哪些？, 177、RabbitMQ有哪些重要的角色？有哪些重要的组件？, 178、RabbitMQ中 vhost 的作用是什么？, 179、说一下 jvm 的主要组成部分？及其作用？, 180、说一下 jvm 运行时数据区？, 181、什么是类加载器类加载器有哪些？, 182、说一下类加载的执行过程？, 183、JVM的类加载机制是什么？, 184、什么是双亲委派模型？, 185、怎么判断对象是否可以被回收？, 186、说一下 jvm 有哪些垃圾回收算法？, 187、说一下 jvm 有哪些垃圾回收器？, 188、JVM栈堆概念何时销毁对象, 189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？, 190、详细介绍一下 CMS 垃圾回收器？, 191、简述分代垃圾回收器是怎么工作的？, 192、Redis是什么？, 193、Redis都有哪些使用场景？, 194、Redis有哪些功能？, 195、Redis支持的数据类型有哪些？, 196、Redis取值存值问题, 197、Redis为什么是单线程的？, 198、Redis真的是单线程的吗？, 199、Redis持久化有几种方式？, 200、Redis和 memecache 有什么区别？, 201、Redis支持的 java 客户端都有哪些？, 202、jedis 和 redisson 有哪些区别？, 203、什么是缓存穿透？怎么解决？, 204、怎么保证缓存和数据库数据的一致性？, 205、Redis什么是缓存穿透？怎么解决？, 206、Redis怎么实现分布式锁？, 207、Redis分布式锁有什么缺陷？, 208、Redis如何做内存优化？作者简介哪吒博客之星亚军新星计划导师博客专家哪吒多年工作总结学习路线总结搬砖工逆袭架构师技术交流定期更新硬核干货不定期送书活动关注公众号哪吒编程回复面试题获取万字道经典面试题总结附答案背题更方便一文在手面试我有前言最近有很多粉丝问我有什么方法能够快速提升自己通过阿里腾讯字节跳动京东等互联网大厂的面试我觉得短时间提升自己最快的手段就是背面试题最近总结了常用的面试题分享给大家希望大家都能圆梦大厂加油我命由我不由天目录和有什么区别和的区别是什么在中有什么作用中的等于多少属于基础的数据类型吗与一样吗如何将字符串反转类的常用方法都有那些会创建几个对象如何将字符串反转类的常用方法都有那些普通类和抽象类有哪些区别接口和抽象类有什么区别中流分为几种有什么区别的常用方法都有哪些什么是反射什么是序列化什么情况下需要序列化为什么要使用克隆如何实现对象克隆深拷贝和浅拷贝区别是什么和的区别有什么区别中如果中了还会执行吗常见的异常类有哪些是什么有什么作用中操作字符串都有哪些类它们之间有什么区别中都有哪些引用类型在中为什么不允许从静态方法中访问非静态变量说说的命名规范属性命名规范问题分析什么是的内存模型在中什么时候用重载什么时候用重写举例说明什么情况下会更倾向于使用抽象类而不是接口实例化对象有哪几种方式类型等于多少容器都有哪些和有什么区别与区别和有什么区别说一下的实现原理有哪些实现类说一下的实现原理和的区别是什么如何实现数组和之间的转换在中和有什么区别哪些集合类是线程安全的迭代器是什么怎么使用有什么特点和有什么区别怎么确保一个集合不能被修改队列和栈是什么有什么区别开始为什么舍弃分段锁为什么要使用而不是如这样的可重入锁和有什么区别和的区别请谈谈和线程的和有什么区别为什么我们调用方法时会执行方法为什么我们不能直接调用方法用过吗其原理是什么对的原生锁做了哪些优化为什么和必须在同步方法或者同步块中被调用如何实现多线程之间的通讯和协作类中的方法有什么作用为什么说是非公平锁请谈谈有什么特点为什么它能保证变量对所有线程的可见性为什么说是一个悲观锁乐观锁的实现原理又是什么什么是它有什么特性乐观锁一定就是好的吗请尽可能详尽地对比下和的异同是如何实现可重入性的什么是锁消除和锁粗化跟相比可重入锁其实现原理有什么不同那么请谈谈框架是怎么回事儿对资源的共享方式如何让的线程彼此同步你了解过哪些同步器请分别介绍下中的线程池是如何实现的创建线程池的几个核心构造参数线程池中的线程是怎么创建的是一开始就随着线程池的启动创建好的吗关键字的作用既然能够保证线程间的变量可见性是不是就意味着基于变量的运算就是并发安全的是什么有哪些使用场景请谈谈是怎么解决并发安全的很多人都说要慎用谈谈你的理解使用需要注意些什么为什么代码会重排序什么是自旋多线程中锁升级的原理是什么和区别是什么中的接口是什么对比同步它有什么优势和有什么区别有哪些内置对象作用分别是什么和的区别说一下的种作用域和有什么区别如果客户端禁止能实现还能用吗什么是上下文切换说一下的工作原理响应码和代表的是什么有什么区别简述和的区别为什么要三次握手两次不行吗为什么的七层模型都有哪些和请求有哪些区别什么是攻击如何避免什么是攻击如何避免如何实现跨域说一下实现原理应用的是哪个协议说一下粘包是怎么产生的请列举出在中几个常用的设计模式什么是设计模式你是否在你的代码里面使用过任何设计模式中什么叫单例设计模式请用写出线程安全的单例模式在中什么叫观察者设计模式使用工厂模式最主要的好处是什么在哪里使用请解释自动装配模式的区别举一个用实现的装饰模式它是作用于对象层次还是类层次什么是框架框架有哪些主要模块使用框架能带来哪些好处举例说明什么是控制反转什么是依赖注入和有什么区别什么是什么是框架有几种配置方式请解释的生命周期的作用域之间有什么区别容器中的可以分为个范围如何在中禁用端点安全性什么是框架中的单例是线程安全的么请解释的自动装配如何开启基于注解的自动装配什么是和的区别是什么请举例解释注解常用注解项目中是如何实现权限验证的权限验证需要几张表谈谈接口调用的路径问题如何防止表单重复提交中都应用了哪些设计模式请举例说明如何在中注入一个中和的区别是什么是否支持延迟加载延迟加载的原理是什么说一下的一级缓存和二级缓存有哪些执行器和的区别有哪些查询多个常用属性一级缓存二级缓存如何防止注入中如何在控制台查看打印的语句有几种查询方式实体类可以被定义为吗在中使用和做映射有什么区别什么是有哪些优点中的监视器是什么什么是如何使用实现分页和排序如何使用实现异常处理单点登录比多哪些注解打包和部署如何访问不同的数据库查询网站在线人数如何实现什么是你用实现了它吗数据库的三范式是什么一张自增表里面总共有条数据删除了最后条数据重启数据库又插入了一条数据此时是几如何获取当前数据库版本说一下是什么和的区别是什么和的区别是什么分页数据库如何保证主键唯一性如何设计数据库性别是否适合做索引如何查询重复的数据数据库一般会采取什么样的优化方法索引怎么定义分哪几种的内连接左连接右连接有什么区别的使用场景有哪些有哪些重要的角色有哪些重要的组件中的作用是什么说一下的主要组成部分及其作用说一下运行时数据区什么是类加载器类加载器有哪些说一下类加载的执行过程的类加载机制是什么什么是双亲委派模型怎么判断对象是否可以被回收说一下有哪些垃圾回收算法说一下有哪些垃圾回收器栈堆概念何时销毁对象新生代垃圾回收器和老生代垃圾回收器都有哪些有什么区别详细介绍一下垃圾回收器简述分代垃圾回收器是怎么工作的是什么都有哪些使用场景有哪些功能支持的数据类型有哪些取值存值问题为什么是单线程的真的是单线程的吗持久化有几种方式和有什么区别支持的客户端都有哪些和有哪些区别什么是缓存穿透怎么解决怎么保证缓存和数据库数据的一致性什么是缓存穿透怎么解决怎么实现分布式锁分布式锁有什么缺陷如何做内存优化和有什么区别开发工具包运行环境中包含中有一个名为的目录里面包含两个文件夹和就是就是工作所需要的类库和的区别是什么对于基本类型比较的是值对于引用类型比较的是地址不能用于基本类型的比较如果没有重写就相当于如果重写了方法比较的是对象的内容在中有什么作用用来修饰一个引用如果引用为基本数据类型则该引用为常量该值无法修改如果引用为引用数据类型比如对象数组则该对象数组本身可以修改但指向该对象或数组的地址的引用不能修改如果引用时类的成员变量则必须当场赋值否则编译会报错用来修饰一个方法当使用修饰方法时这个方法将成为最终方法无法被子类重写但是该方法仍然可以被继承用来修饰类当用修改类时该类成为最终类无法被继承比如常用的类就是最终类中的等于多少提供了三个与取整有关的方法向上取整向下取整四舍五入加然后向下取整属于基础的数据类型吗不属于八种基本数据类型与一样吗会将起分配到常量池中常量池中没有重复的元素如果常量池中存中就将的地址赋给变量如果没有就创建一个再赋给变量会将对象分配到堆中即使内存一样还是会重新创建一个新的对象如何将字符串反转将对象封装到中调用方法反转类的常用方法都有那些常见类的获取功能获取字符串长度获取指定索引位置的字符返回指定字符在此字符串中第一次出现处的索引从指定位置开始截取字符串默认到末尾从指定位置开始到指定位置结束截取字符串常见类的判断功能比较字符串的内容是否相同区分大小写判断字符串中是否包含传递进来的字符串判断字符串是否以传递进来的字符串开头判断字符串是否以传递进来的字符串结尾判断字符串的内容是否为空串常见类的转换功能把字符串转换为字节数组把字符串转换为字符数组把字符数组转成字符串可以将任意类型转为字符串把字符串转成小写把字符串转成大写把字符串拼接常见类的其他常用功能将指定字符进行互换将指定字符串进行互换去除两端空格会对照码表从第一个字母进行减法运算返回的就是这个减法的结果如果前面几个字母一样会根据两个字符串的长度进行减法运算返回的就是这个减法的结果如果连个字符串一摸一样返回的就是会创建几个对象对象对象对象常量池中的对象对象常量池中的深入剖析中的对象强调一下的调用在字符串常量池中没有生成附加题变量记录的地址为在字符串常量池中生成如何理解创建了一个新的对象也就有新的地址此时常量池中并没有创建而是创建了一个指向堆空间中的地址如何将字符串反转添加到中然后调用类的常用方法都有那些等等普通类和抽象类有哪些区别抽象类不能被实例化抽象类可以有抽象方法只需申明无须实现有抽象方法的类一定是抽象类抽象类的子类必须实现抽象类中的所有抽象方法否则子类仍然是抽象类抽象方法不能声明为静态不能被修饰接口和抽象类有什么区别接口接口使用修饰接口不能实例化类可以实现多个接口之前接口中的方法都是抽象方法省略了之后接口中可以定义静态方法静态方法必须有方法体普通方法没有方法体需要被实现抽象类抽象类使用修饰抽象类不能被实例化抽象类只能单继承抽象类中可以包含抽象方法和非抽象方法非抽象方法需要有方法体如果一个类继承了抽象类如果实现了所有的抽象方法子类可以不是抽象类如果没有实现所有的抽象方法子类仍然是抽象类中流分为几种按流划分可以分为输入流和输出流按单位划分可以分为字节流和字符流字节流字符流有什么区别同步阻塞一个连接一个线程之前建立网络连接的时候采用模式先在启动服务端然后启动客户端对服务端通信客户端发送请求后先判断服务端是否有线程响应如果没有则会一直等待或者遭到拒绝请求如果有的话会等待请求结束后才继续执行同步非阻塞主要是想解决的大并发问题是每一个请求分配一个线程当请求过多时每个线程占用一定的内存空间服务器瘫痪了开始支持适用于连接数目多且连接比较短的架构比如聊天服务器并发局限于应用中一个请求一个线程异步非阻塞一个有效请求一个线程开始支持适用于连接数目多且连接比较长的结构比如相册服务器充分调用参与并发操作的常用方法都有哪些什么是反射所谓反射是在运行时进行自我观察的能力通过四个方法获取一个类的各个组成部分在运行时环境中对任意一个类可以知道类有哪些属性和方法这种动态获取类的信息以及动态调用对象的方法的功能来自于反射机制什么是序列化什么情况下需要序列化序列化就是一种用来处理对象流的机制将对象的内容流化将流化后的对象传输于网络之间序列化是通过实现接口该接口没有需要实现的方法只是为了标注该对象是可被序列化的使用一个输出流来构造一个对象接着使用对象的方法就可以将参数的对象到磁盘需要恢复的时候使用输入流序列化是将对象转换为容易传输的格式的过程例如可以序列化一个对象然后通过通过在客户端和服务器之间传输该对象在另一端反序列化将从流中心构造成对象一般程序在运行时产生对象这些对象随着程序的停止而消失但我们想将某些对象保存下来这时我们就可以通过序列化将对象保存在磁盘需要使用的时候通过反序列化获取到对象序列化的最主要目的就是传递和保存对象保存对象的完整性和可传递性譬如通过网络传输或者把一个对象保存成本地一个文件的时候需要使用序列化为什么要使用克隆如何实现对象克隆深拷贝和浅拷贝区别是什么什么要使用克隆想对一个对象进行复制又想保留原有的对象进行接下来的操作这个时候就需要克隆了如何实现对象克隆实现接口重写方法实现接口通过对象的序列化和反序列化实现克隆可以实现真正的深克隆和都提供了工具只是这都是浅克隆深拷贝和浅拷贝区别是什么浅拷贝仅仅克隆基本类型变量不克隆引用类型变量深克隆既克隆基本类型变量又克隆引用类型变量代码实例和的区别作用在方法内表示抛出具体异常由方法体内的语句处理一定抛出了异常作用在方法的声明上表示抛出异常由调用者来进行异常处理可能出现异常不一定会发生异常有什么区别可以修饰类变量方法修饰的类不能被继承修饰的变量不能重新赋值修饰的方法不能被重写用于抛异常代码块内语句无论是否发生异常都会在执行常用于一些流的关闭方法用于垃圾回收一般情况下不需要我们实现当对象被回收的时候需要释放一些资源比如链接在对象初始化时创建整个生命周期内有效那么需要实现方法关闭这个链接但是当调用方法后并不意味着会立即回收该对象所以有可能真正调用的时候对象又不需要回收了然后到了真正要回收的时候因为之前调用过一次这次又不会调用了产生问题所以不推荐使用方法中如果中了还会执行吗常见的异常类有哪些空指针异常数据库相关的异常数组下角标越界异常打开文件失败时抛出当发生某种异常时抛出当试图将对象强制转换为不是实例的子类时抛出此异常无法找到某一方法时抛出试图将错误类型的对象存储到一个对象数组时抛出的异常当试图将字符串转换成数字时失败了抛出抛出的异常表明向方法传递了一个不合法或不正确的参数当出现异常的运算条件时抛出此异常例如一个整数除以零时抛出此类的一个实例是什么有什么作用中有一个方法方法的作用方法主要配合基于散列的集合一起使用比如当集合需要添加新的对象时先调用这个对象的方法得到对应的值实际上中会有一个保存已经存进去的对象的值如果中没有改值则直接存入如果有就调用方法与新元素进行比较相同就不存了不同就存入和的关系如果为一定相等如果为不一定不相等如果值相等不一定相等如果值不等一定不等重写方法时一定要重写方法百度百科方法返回该对象的哈希码值支持该方法是为哈希表提供一些优点例如提供的哈希表的常规协定是在应用程序执行期间在同一对象上多次调用方法时必须一致地返回相同的整数前提是对象上比较中所用的信息没有被修改从某一应用程序的一次执行到同一应用程序的另一次执行该整数无需保持一致如果根据方法两个对象是相等的那么在两个对象中的每个对象上调用方法都必须生成相同的整数结果以下情况不是必需的如果根据方法两个对象不相等那么在两个对象中的任一对象上调用方法必定会生成不同的整数结果但是程序员应该知道为不相等的对象生成不同整数结果可以提高哈希表的性能实际上由类定义的方法确实会针对不同的对象返回不同的整数这一般是通过将该对象的内部地址转换成一个整数来实现的但是编程语言不需要这种实现技巧当方法被重写时通常有必要重写方法以维护方法的常规协定该协定声明相等对象必须具有相等的哈希码小白解释是用来查找的如果你学过数据结构就应该知道在查找和排序这一章有例如内存中有这样的位置而我有个类这个类有个字段叫我要把这个类存放在以上个位置之一如果不用而任意存放那么当查找时就需要到这八个位置里挨个去找或者用二分法一类的算法但如果用那就会使效率提高很多我们这个类中有个字段叫那么我们就定义我们的为然后把我们的类存放在取得得余数那个位置比如我们的为除的余数为那么我们就把该类存在这个位置如果是求得的余数是那么我们就把该类放在这个位置这样以后在查找该类时就可以通过除求余数直接找到存放的位置了但是如果两个类有相同的怎么办那我们假设上面的类的不是唯一的例如除以和除以的余数都是那么这是不是合法的回答是可以这样那么如何判断呢在这个时候就需要定义了也就是说我们先通过来判断两个类是否存放某个桶里但这个桶里可能有很多类那么我们就需要再通过来在这个桶里找到我们要的类那么重写了为什么还要重写呢想想你要在一个桶里找东西你必须先要找到这个桶啊你不通过重写来找到桶光重写有什么用啊中操作字符串都有哪些类它们之间有什么区别是不可变对象每次对类型的改变时都会生成一个新的对象线程不安全效率高多用于单线程线程安全由于加锁的原因效率不如多用于多线程不频繁的字符串操作使用操作频繁的情况不建议使用中都有哪些引用类型强引用中默认声明的就是强引用比如只要强引用存在垃圾回收器将永远不会回收被引用的对象如果想被回收可以将对象置为软引用在内存足够的时候软引用不会被回收只有在内存不足时系统才会回收软引用对象如果回收了软引用对象之后仍然没有足够的内存才会跑出内存溢出异常弱引用进行垃圾回收时弱引用就会被回收虚引用引用队列引用队列可以与软引用弱引用虚引用一起配合使用当垃圾回收器准备回收一个对象时如果发现它还有引用就会在回收对象之前把这个引用加入到引用队列中程序可以通过判断引用队列中是否加入了引用来判断被引用的对象是否将要被垃圾回收这样可以在对象被回收之前采取一些必要的措施在中为什么不允许从静态方法中访问非静态变量静态变量属于类本身在类加载的时候就会分配内存可以通过类名直接访问非静态变量属于类的对象只有在类的对象产生时才会分配内存通过类的实例去访问静态方法也属于类本身但是此时没有类的实例内存中没有非静态变量所以无法调用说说的命名规范类必须是一个公共类并将其访问属性设置为类必须有一个空的构造函数类中必须有一个不带参数的公用构造器此构造器也应该通过调用各个特性的设置方法来设置特性的缺省值一个类不应有公共实例变量类变量都为持有值应该通过一组存取方法和来访问对于每个特性应该有一个带匹配公用和方法的专用实例变量属性为布尔类型可以使用方法代替方法通常属性名是要和包名类名方法名字段名常量名作出区别的首先必须用英文不要用汉语拼音包用于将完成不同功能的类分门别类放在不同的目录包下包的命名规则将公司域名反转作为包名比如对于包名每个字母都需要小写比如该包下的类的全名是如果定义类的时候没有使用那么就认为我们所定义的类位于默认包里面类首字母大写如果一个类由多个单词构成那么每个单词的首字母都大写而且中间不使用任何的连接符尽量使用英文如方法首单词全部小写如果一个方法由多个单词构成那么从第二个单词开始首字母大写不使用连接符字段与方法相同如常量所有单词的字母都是大写如果有多个单词那么使用下划线链接即可如通常加上属性命名规范问题分析正确的命名方式驼峰式的这是什么这个也是不允许的属性命名尽量使用常规的驼峰式命名规则属性名第一个单词尽量避免使用一个字母如属性名避免使用开头的名称随着等软件版本的不断提高底版本的出现的问题可能在高版本中解决了低版本原来正常的代码可能在高版本环境下不再支持什么是的内存模型在了解什么是内存模型之前先了解一下为什么要提出内存模型之前提到过并发编程有三大问题缓存在多核的情况下带来了可见性问题操作系统对当前执行线程的切换带来了原子性问题译器指令重排优化带来了有序性问题为了解决并发编程的三大问题提出了新的内存模型开始使用简单总结下内存模型是的一种规范定义了共享内存在多线程程序中读写操作行为的规范屏蔽了各种硬件和操作系统的访问差异保证了程序在各种平台下对内存的访问效果一致解决并发问题采用的方式限制处理器优化和使用内存屏障增强了三个同步原语的内存语义定义了规则在中什么时候用重载什么时候用重写重载是多态的集中体现在类中要以统一的方式处理不同类型数据的时候可以用重载重写的使用是建立在继承关系上的子类在继承父类的基础上增加新的功能可以用重写简单总结重载是多样性重写是增强剂目的是提高程序的多样性和健壮性以适配不同场景使用时使用重载进行扩展目的是在不修改原方法及源代码的基础上对方法进行扩展或增强时使用重写生活例子你想吃一碗面我给你提供了拉面炒面刀削面担担面供你选择这是重载你想吃一碗面我不但给你端来了面还给你加了青菜加了鸡蛋这个是重写设计模式实现动态代理核心原理用的就是方法的重写详细解答的重载最重要的应用场景就是构造器的重载构造器重载后提供多种形参形式的构造器可以应对不同的业务需求加强程序的健壮性和可扩展性比如我们最近学习的源码中的它的构造函数使用重载一共提供了个构造函数这样就为业务的选择提供了多选择性在应用到方法中时主要是为了增强方法的健壮性和可扩展性比如我们在开发中常用的各种工具类比如我目前工作中的短信工具类发短信的方法就会使用重载针对不同业务场景下的不同形参提供短信发送方法这样提高了工具类的扩展性和健壮性总结重载必须要修改方法构造器的形参列表可以修改方法的返回值类型也可以修改方法的异常信息即访问权限使用范围是在同一个类中目的是对方法构造器进行功能扩展以应对多业务场景的不同使用需求提高程序的健壮性和扩展性的重写只要用于子类对父类方法的扩展或修改但是在我们开发中为了避免程序混乱重写一般都是为了方法的扩展比如在方式实现的动态代理中代理类就是继承了目标类对目标类的方法进行重写同时在方法前后进行切面织入总结方法重写时参数列表返回值得类型是一定不能修改的异常可以减少或者删除但是不能抛出新的异常或者更广的异常方法的访问权限可以降低限制但是不能做更严格的限制在里氏替换原则中子类对父类的方法尽量不要重写和重载我们可以采用的手段强制来遵循举例说明什么情况下会更倾向于使用抽象类而不是接口接口和抽象类都遵循面向接口而不是实现编码设计原则它可以增加代码的灵活性可以适应不断变化的需求下面有几个点可以帮助你回答这个问题在中你只能继承一个类但可以实现多个接口所以一旦你继承了一个类你就失去了继承其他类的机会了接口通常被用来表示附属描述或行为如等等因此当你使用抽象类来表示行为时你的类就不能同时是和注这里的意思是指如果把等实现为抽象类的情况因为在中你不能继承两个类但当你使用接口时你的类就可以同时拥有多个不同的行为在一些对时间要求比较高的应用中倾向于使用抽象类它会比接口稍快一点如果希望把一系列行为都规范在类继承层次内并且可以更好地在同一个地方进行编码那么抽象类是一个更好的选择有时接口和抽象类可以一起使用接口中定义函数而在抽象类中定义默认的实现实例化对象有哪几种方式通过反射机制创建用方法获取类在调用类的方法序列化反序列化将一个对象实例化后进行序列化再反序列化也可以获得一个对象远程通信的场景下使用序列化对象反序列化对象反序列化类型等于多少的范围是字节长度为位最左边的是符号位而的二进制为所以执行操作时变为大家知道计算机中存储负数存的是补码的兴衰左边第一位为符号位那么负数的补码转换成十进制如下一个数如果为正则它的原码反码补码相同一个正数的补码将其转化为十进制可以直接转换已知一个负数的补码将其转换为十进制数步骤如下先对各位取反将其转换为十进制数加上负号再减去例如最高位是是负数对各位取反得转换为十进制就是加上负号得再减去得容器都有哪些和有什么区别是最基本的集合接口派生了两个子接口和分别定义了两种不同的存储方式是一个包装类它包含各种有关集合操作的静态方法对集合的搜索排序线程安全化等此类不能实例化就像一个工具类服务于框架与区别简介实际上有两种一种是基本的其优点在于随机访问元素另一种是它并不是为快速随机访问设计的而是快速的插入或删除由数组实现的允许对元素进行快速随机访问但是向中间插入与移除元素的速度很慢对顺序访问进行了优化向中间插入与删除的开销并不大随机访问则相对较慢还具有下列方法和这些方法没有在任何接口或基类中定义过使得可以当作堆栈队列和双向队列使用简介具有与完全一样的接口因此没有任何额外的功能实际上就是只是行为不同这是继承与多态思想的典型应用表现不同的行为不保存重复的元素至于如何判断元素相同则较为负责存入的每个元素都必须是唯一的因为不保存重复元素加入的元素必须定义方法以确保对象的唯一性与有完全一样的接口接口不保证维护元素的次序为快速查找设计的存入的对象必须定义保存次序的底层为树结构使用它可以从中提取有序的序列与区别都是继承自接口特点元素有放入顺序元素可重复特点元素无放入顺序元素不可重复重复元素会覆盖掉元素虽然无放入顺序但是元素在中的位置是有该元素的决定的其位置其实是固定的加入的必须定义方法另外支持循环也就是通过下标来遍历也可以用迭代器但是只能用迭代因为他无序无法用下标来取得想要的值和对比检索元素效率低下删除和插入效率高插入和删除不会引起元素位置改变和数组类似可以动态增长查找元素效率高插入删除元素效率低因为会引起其他元素位置改变和有什么区别是线程不安全的是线程安全的中允许键和值为不允许的默认容器是为倍扩容默认是为倍扩容说一下的实现原理简介基于接口元素以键值对方式存储允许有值是线程不安全的基本属性初始化大小默认倍扩容负载因子初始化的默认数组判断是否需要调整容量的存储结构中采用数组链表的存储形式采取数组来存储每一个键值对组成了一个实体类时机上是一个单向的链表结构它具有指针指向下一个实体以此来解决冲突的问题实现一个内部类重要的属性有中采用数据链表红黑树的存储形式当链表长度超过阈值时将链表转换为红黑树在性能上进一步得到提升有哪些实现类是接口的实现类下面最主要的实现类就是也就是用的最多的此外还有和是无序的不可重复的通过对象的和方法保证对象的唯一性内部的存储结构是哈希表是线程不安全的对元素进行排序的方式元素自身具备比较功能需要实现接口并覆盖方法元素自身不具备比较功能需要实现接口并覆盖方法是一种有序的集合即其元素的存入和输出的顺序是相同的说一下的实现原理实际上是一个实例数据存储结构都是数组链表是基于实现的中的元素都存放在的上面而都是一个统一的对象中方法调用的是底层中的方法方法要判断插入值是否存在而的方法首先判断元素是否存在如果存在则插入如果不存在则不插入这样就保证了中不存在重复值通过对象的和方法保证对象的唯一性是动态数组的数据结构实现查找和遍历的效率较高是双向链表的数据结构增加和删除的效率较高如何实现数组和之间的转换张三李四王五在中和有什么区别和区别增加新项时如果队列满了会抛出异常返回和区别和都是从队列中删除第一个元素抛出异常返回和区别和用于查询队列头部元素为空时抛出异常返回哪些集合类是线程安全的就比多了个同步化机制线程安全栈也是线程安全的继承于就比多了个线程安全是一种高效但是线程安全的集合迭代器是什么为了方便的处理集合中的元素中出现了一个对象该对象提供了一些方法专门处理集合中的元素例如删除和获取集合中的元素该对象就叫做迭代器怎么使用有什么特点接口源码中的方法接口被接口继承接口的方法返回一个对象方法获得集合中的下一个元素检查集合中是否还有元素方法将迭代器新返回的元素删除和有什么区别继承比多方法将指定的元素插入列表插入位置为迭代器当前位置之前迭代器返回的最后一个元素替换参数迭代器当前位置反向遍历集合是否含有元素迭代器当前位置反向遍历集合下一个元素迭代器当前位置反向遍历集合返回下一个元素的下标迭代器当前位置返回下一个元素的下标使用范围不同可以迭代所有集合只能用于及其子类有方法可以向中添加对象不能有和方法可以实现逆向遍历不可以有和方法可定位当前索引的位置不可以有方法可以实现对的修改仅能遍历不能修改怎么确保一个集合不能被修改我们很容易想到用关键字进行修饰我们都知道关键字可以修饰类方法成员变量修饰的类不能被继承修饰的方法不能被重写修饰的成员变量必须初始化值如果这个成员变量是基本数据类型表示这个变量的值是不可改变的如果说这个成员变量是引用类型则表示这个引用的地址值是不能改变的但是这个引用所指向的对象里面的内容还是可以改变的那么我们怎么确保一个集合不能被修改首先我们要清楚集合都是引用类型所以我们如果用修饰的话集合里面的内容还是可以修改的我们可以做一个实验可以看到我们用关键字定义了一个集合这时候我们往集合里面传值第一个键值对我们再修改后可以把键为的值改为说明我们是可以修改集合的值的那我们应该怎么做才能确保集合不被修改呢我们可以采用包下的方法通过这个方法返回的是不可以修改的他会报错同理包也提供了对和集合的方法队列和栈是什么有什么区别队列先进先出栈先进后出遍历数据速度不同栈只能从头部取数据也就最先放入的需要遍历整个栈最后才能取出来而且在遍历数据的时候还得为数据开辟临时空间保持数据在遍历前的一致性队列则不同他基于地址指针进行遍历而且可以从头或尾部开始遍历但不能同时遍历无需开辟临时空间因为在遍历的过程中不影像数据结构速度要快的多开始为什么舍弃分段锁的原理是引用了内部的分段锁保证在操作不同段的时候可以并发执行操作同段的时候进行锁的竞争和等待从而达到线程安全且效率大于但是在之后却弃用了这个策略重新使用了弃用原因通过的源码和官方文档看来他们认为的弃用分段锁的原因由以下几点加入多个分段锁浪费内存空间生产环境中在放入时竞争同一个锁的概率非常小分段锁反而会造成更新等操作的长时间等待为了提高的效率新的同步方案既然弃用了分段锁那么一定由新的线程安全方案我们来看看源码是怎么解决线程安全的呢源码保留了代码但并没有使用为什么要使用而不是如这样的可重入锁我想从下面几个角度讨论这个问题锁的粒度首先锁的粒度并没有变粗甚至变得更细了每当扩容一次的并发度就扩大一倍冲突中从过二次的方式能够快速的找到查找的元素在中通过链表加红黑树的形式弥补了时的性能差距中在进行扩容时其他线程可以通过检测数组中的节点决定是否对这条链表红黑树进行扩容减小了扩容的粒度提高了扩容的效率下面是我对面试中的那个问题的一下看法为什么是而不是减少内存开销假设使用可重入锁来获得同步支持那么每个节点都需要通过继承来获得同步支持但并不是每个节点都需要获得同步支持的只有链表的头节点红黑树的根节点需要同步这无疑带来了巨大内存浪费获得的支持可重入锁毕竟是这个级别的后续的性能优化空间很小则是直接支持的能够在运行时作出相应的优化措施锁粗化锁消除锁自旋等等这就使得能够随着版本的升级而不改动代码的前提下获得性能上的提升和有什么区别融合了和的优势是不同步的但是单线程情况下效率高是同步的同步情况下保证程序执行的正确性但每次同步执行的时候都要锁住整个结构如下图锁的方式是细粒度的将分为个桶默认值诸如等常用操作只锁住当前需要用到的桶的读取并发因为读取的大多数时候都没有锁定所以读取操作几乎是完全的并发操作只是在求时才需要锁定整个而且在迭代时使用了不同于传统集合的快速失败迭代器的另一种迭代方式弱一致迭代器在这种方式中当被创建后集合再发生改变就不会抛出取而代之的是在改变时新的数据而不是影响原来的数据完成后再讲头指针替代为新的数据这样时使用的是原来的数据和的区别先了解一下中的集合有两类一类是一类是元素有序可以重复元素无序不可重复要想保证元素的不重复拿什么来判断呢这就是方法了如果元素有很多增加一个元素就要判断次吗显然不现实于是采用了哈希表的原理哈希算法也称为散列算法是将数据依特定算法直接指定到一根地址上初学者可以简单的理解为方法返回的就是对象存储的物理位置实际上并不是这样一来当集合添加新的元素时先调用这个元素的方法就一下子能定位到他应该放置的物理位置上如果这个位置上没有元素他就可以直接存储在这个位置上不用再进行任何比较了如果这个位置上有元素就调用它的方法与新元素进行比较想同的话就不存了不相同就散列其它的地址所以这里存在一个冲突解决的问题这样一来实际上调用方法的次数就大大降低了几乎只需要一两次简而言之在集合查找时能大大降低对象比较次数提高查找效率对象的方法和方法时这样规定的相等的对象就必须具有相等的如果两个对象的相同他们并不一定相同如果两个对象的相同他们并不一定相同如果两个对象和和不相等但是和的哈希码相等将和都存入时会发生哈希冲突也就是和存放在内部数组的位置索引相同这时会在该位置建立一个链接表将和串起来放在该位置显然该情况不违反的使用规则是允许的当然哈希冲突越少越好尽量采用好的哈希算法避免哈希冲突相等的两个对象一定相等不相等的两个对象却并不能证明他们的不相等和的区别请谈谈和包括两种子锁可以实现多个读锁同时进行但是读与写和写于写互斥只能有一个写锁线程在进行是在提供的一种读写锁相比较性能更好因为在读写之间是互斥的使用的是一种悲观策略在读线程特别多的情况下会造成写线程处于饥饿状态虽然可以在初始化的时候设置为指定为公平但是吞吐量又下去了而是提供了一种乐观策略更好的实现读写分离并且吞吐量不会下降包括三种锁写锁是一个独占锁写锁当一个线程获得该锁后其他请求读锁或者写锁的线程阻塞获取成功后会返回一个凭据变量来表示该锁的版本在释放锁时调用方法传递参数提供了非阻塞式获取锁悲观读锁是一个共享读锁在没有线程获取写锁情况下多个线程可以获取该锁如果有写锁获取那么其他线程请求读锁会被阻塞悲观读锁会认为其他线程可能要对自己操作的数据进行修改所以需要先对数据进行加锁这是在读少写多的情况下考虑的请求该锁成功后会返回一个值在释放锁时调用方法传递参数提供了非阻塞式获取锁方法乐观读锁相对比悲观读锁在操作数据前并没有通过设置锁的状态如果没有线程获取写锁则返回一个非的变量获取该后在操作数据前还需要调用方法来判断期间是否有线程获取了写锁如果是返回值为则有线程获取写锁如果不是则可以使用变量的锁来操作数据由于并没有修改锁状态所以不需要释放锁这是读多写少的情况下考虑的不涉及操作所以效率较高在保证数据一致性上需要复制一份要操作的变量到方法栈中并且在操作数据时可能其他写线程已经修改了数据而我们操作的是方法栈里面的数据也就是一个快照所以最多返回的不是最新的数据但是一致性得到了保证线程的和有什么区别每个线程都是通过某个特定对象所对应的方法来完成其操作的方法称为线程体通过调用类的方法来启动一个线程方法用于启动线程方法用于执行线程的运行时代码可以重复调用而只能调用一次方法来启动一个线程真正实现了多线程运行调用方法无需等待方法体代码执行完毕可以直接继续执行其他的代码此时线程是处于就绪状态并没有运行然后通过此类调用方法来完成其运行状态方法运行结束此线程终止然后再调度其它线程方法是在本线程里的只是线程里的一个函数而不是多线程的如果直接调用其实就相当于是调用了一个普通函数而已直接待用方法必须等待方法执行完毕才能执行下面的代码所以执行路径还是只有一条根本就没有线程的特征所以在多线程执行时要使用方法而不是方法为什么我们调用方法时会执行方法为什么我们不能直接调用方法这是另一个非常经典的多线程面试问题而且在面试中会经常被问到很简单但是很多人都会答不上来一个线程进入了新建状态调用方法会启动一个线程并使线程进入了就绪状态当分配到时间片后就可以开始运行了会执行线程的相应准备工作然后自动执行方法的内容这是真正的多线程工作而直接执行方法会把方法当成一个线程下的普通方法去执行并不会在某个线程中执行它所以这并不是多线程工作总结调用方法方可启动线程并使线程进入就绪状态而方法只是的一个普通方法调用还是在主线程里执行用过吗其原理是什么可重入性的锁对象中有一个计数器变量会记录线程获得几次锁可重入的好处可以避免死锁可以让我们更好的封装代码是可重入锁每部锁对象会有一个计数器记录线程获取几次锁在执行完同步代码块时计数器的数量会直到计数器的数量为就释放这个锁不可中断性一个线程获得锁后另一个线程想要获得锁必须处于阻塞或等待状态如果第一个线程不释放锁第二个线程会一直阻塞或等待不可被中断属于不可被中断方法是不可中断的方法是可中断的对的原生锁做了哪些优化自旋锁在线程进行阻塞的时候先让线程自旋等待一段时间可能这段时间其它线程已经解锁这时就无需让线程再进行阻塞操作了自旋默认次数是次自适应自旋锁自旋锁的升级自旋的次数不再固定由前一次自旋次数和锁的拥有者的状态决定锁消除在动态编译同步代码块的时候编译器借助逃逸分析技术来判断锁对象是否只被一个线程访问而没有其他线程这时就可以取消锁了锁粗化当编译器发现一系列的操作都对同一个对象反复加锁解锁甚至加锁操作出现在循环中此时会将加锁同步的范围粗化到整个操作系列的外部锁粒度不要锁住一些无关的代码锁粗化可以一次性执行完的不要多次加锁执行为什么和必须在同步方法或者同步块中被调用中任何对象都可以作为锁并且等方法用于等待对象的锁或者唤醒线程在的线程中并没有可供任何对象使用的锁所以任意对象调用方法一定定义在类中和这些方法在同步代码块中调用有的人会说既然是线程放弃对象锁那也可以把定义在类里面啊新定义的线程继承于类也不需要重新定义方法的实现然而这样做有一个非常大的问题一个线程完全可以持有很多锁你一个线程放弃锁的时候到底要放弃哪个锁当然了这种设计并不是不能实现只是管理起来更加复杂综上所述和方法要定义在类中如何实现多线程之间的通讯和协作可以通过中断和共享变量的方式实现线程间的通讯和协作比如说最经典的生产者消费者模型当队列满时生产者需要等待队列有空间才能继续往里面放入商品而在等待的期间内生产者必须释放对临界资源即队列的占用权因为生产者如果不释放对临界资源的占用权那么消费者就无法消费队列中的商品就不会让队列有空间那么生产者就会一直无限等待下去因此一般情况下当队列满时会让生产者交出对临界资源的占用权并进入挂起状态然后等待消费者消费了商品然后消费者通知生产者队列有空间了同样地当队列空时消费者也必须等待等待生产者通知它队列中有商品了这种互相通信的过程就是线程间的协作中线程通信协作的最常见的两种方式加锁的线程的类的类加锁的线程的类的线程间直接的数据交换通过管道进行线程间通信字节流字符流类中的方法有什么作用应该做的是让当前运行线程回到可运行状态以允许具有相同优先级的其他线程获得运行机会因此使用的目的是让相同优先级的线程之间能适当的轮转执行但是实际中无法保证达到让步目的因为让步的线程还有可能被线程调度程序再次选中结论从未导致线程转到等待睡眠阻塞状态在大多数情况下将导致线程从运行状态转到可运行状态但有可能没有效果为什么说是非公平锁当锁被释放后任何一个线程都有机会竞争得到锁这样做的目的是提高效率但缺点是可能产生线程饥饿现象请谈谈有什么特点为什么它能保证变量对所有线程的可见性只能作用于变量保证了操作可见性和有序性不保证原子性在的内存模型中分为主内存和工作内存内存模型规定所有的变量存储在主内存中每条线程都有自己的工作内存主内存和工作内存之间的交互分为个原子操作修饰的变量只有对进行操作才可以只有才可以这样就保证了在工作内存操作变量都会同步到主内存中为什么说是一个悲观锁乐观锁的实现原理又是什么什么是它有什么特性的并发策略是悲观的不管是否产生竞争任何数据的操作都必须加锁乐观锁的核心是包括内存值预期值新值只有当内存值等于预期值时才会将内存值修改为新值乐观锁一定就是好的吗乐观锁认为对一个对象的操作不会引发冲突所以每次操作都不进行加锁只是在最后提交更改时验证是否发生冲突如果冲突则再试一遍直至成功为止这个尝试的过程称为自旋乐观锁没有加锁但乐观锁引入了问题此时一般采用版本号进行控制也可能产生自旋次数过多问题此时并不能提高效率反而不如直接加锁的效率高只能保证一个对象的原子性可以封装成对象再进行操作请尽可能详尽地对比下和的异同相似点它们都是阻塞式的同步也就是说一个线程获得了对象锁进入代码块其它访问该同步块的线程都必须阻塞在同步代码块外面等待而进行线程阻塞和唤醒的代码是比较高的功能区别是语言的关键字是原生语法层面的互斥需要实现是之后提供的层面的互斥锁需要和方法配合代码块来完成使用较便利一些锁的细粒度和灵活性强于性能区别引入偏向锁自旋锁之后两者的性能差不多在这种情况下官方建议使用会在同步块的前后分别形成和两个字节码指令在执行指令时首先要尝试获取对象锁如果这个对象没被锁定或者当前线程已经拥有了那个对象锁把锁的计数器相应的执行时计数器当计数器为时锁就会被释放如果获取锁失败当前线程就要阻塞知道对象锁被另一个线程释放为止是包下提供的一套互斥锁相比类提供了一些高级功能主要有如下三项等待可中断持有锁的线程长期不释放的时候正在等待的线程可以选择放弃等待这相当于避免出现死锁的情况通过来实现这一机制公平锁多个线程等待同一个锁时必须按照申请锁的时间顺序获得锁锁是非公平锁默认也是非公平锁可以通过参数设为公平锁但公平锁表现的性能不是很好锁绑定多个条件一个对象可以同时绑定多个对象提供了一个条件类用来实现分组唤醒需要唤醒的线程们而不是像要么随机唤醒一个线程要么唤醒全部线程是如何实现可重入性的什么是可重入性一个线程持有锁时当其他线程尝试获取该锁时会被阻塞而这个线程尝试获取自己持有锁时如果成功说明该锁是可重入的反之则不可重入是如何实现可重入性关键字经过编译后会在同步块的前后分别形成和两个字节码指令每个锁对象内部维护一个计数器该计数器初始值为表示任何线程都可以获取该锁并执行相应的方法根据虚拟机规范要求在执行指令时首先要尝试获取对象的锁如果这个对象没有被锁定或者当前线程已经拥有了对象的锁把锁的计数器相应的在执行指令后锁计数器当计数器为时锁就被释放如果获取对象锁失败那当前线程就要阻塞等待直到对象锁被另一个线程释放为止如何实现可重入性使用内部类来管理锁所以真正的获取锁是由的实现类控制的有两个实现分别为非公公平锁和公平锁通过继承实现在中维护了一个来计算重入次数避免频繁的持有释放操作带来的线程问题代码实例继承于默认是非公平锁可以通过向构造方法中传来实现公平锁当前想要获取锁的线程当前锁的状态此时此刻没有线程持有锁虽然此时此刻锁是可以用的但是这是公平锁既然是公平就得讲究先来后到看看有没有别人在队列中等了半天了如果没有线程在等待那就用尝试一下成功了就获取到锁了不成功的话只能说明一个问题就在刚刚几乎同一时刻有个线程抢先了因为刚刚还没人的我判断过了到这里就是获取到锁了标记一下告诉大家现在是我占用了锁会进入这个分支说明是重入了需要操作这里不存在并发问题如果到这里说明前面的和都没有返回说明没有获取到锁代码分析当一个线程在获取锁过程中先判断的值是否为如果是表示没有线程持有锁就可以尝试获取锁当的值不为时表示锁已经被一个线程占用了这时会做一个判断这个方法返回的是当前持有锁的线程这个判断是看当前持有锁的线程是不是自己如果是自己那么将的值表示重入返回即可什么是锁消除和锁粗化锁消除所消除就是虚拟机根据一个对象是否真正存在同步情况若不存在同步情况则对该对象的访问无需经过加锁解锁的操作比如的方法因为方法需要判断对象是否被占用而如果代码不存在锁竞争那么这部分的性能消耗是无意义的于是虚拟机在即时编译的时候就会将上面的代码进行优化也就是锁消除从源码可以看出方法用了关键字它是线程安全的但我们可能仅在线程内部把当做局部变量使用仅在方法内作用域有效不存在线程安全的问题这时我们可以通过编译器将其优化将锁消除前提是必须运行在模式同时必须开启逃逸分析其中表示开启逃逸分析表示锁消除方法是同步操作逃逸分析比如上面的代码它要看是否可能逃出它的作用域如果将作为方法的返回值进行返回那么它在方法外部可能被当作一个全局对象使用就有可能发生线程安全问题这时就可以说这个对象发生逃逸了因而不应将操作的锁消除但我们上面的代码没有发生锁逃逸锁消除就可以带来一定的性能提升锁粗化锁的请求同步释放都会消耗一定的系统资源如果高频的锁请求反而不利于系统性能的优化锁粗化就是把多次的锁请求合并成一个请求扩大锁的范围降低锁请求同步释放带来的性能损耗跟相比可重入锁其实现原理有什么不同都是可重入锁内部是实现了继承于抽象类有两个实现一个是公平锁一个是非公平锁通过构造函数定义中维护了一个来计算重入次数避免频繁的持有释放操作带来的线程问题只能定义代码块而可以定义方法和代码块是的一个内部关键字是之后引入的一个层面的互斥锁实现自动的加锁释放锁需要手动加锁和释放锁中间可以暂停由于引进了偏向锁和自旋锁所以性能上和差不多但操作上方便很多所以优先使用那么请谈谈框架是怎么回事儿是的缩写它提供了一个队列可以看成是一个实现同步锁的核心组件是一个抽象类主要通过继承的方式来使用它本身没有实现任何的同步接口仅仅是定义了同步状态的获取和释放的方法来提供自定义的同步组件的两种功能独占锁和共享锁的内部实现的实现依赖内部的同步队列也就是的双向队列如果当前线程竞争失败那么会把当前线程以及等待状态信息构造成一个加入到同步队列中同时再阻塞该线程当获取锁的线程释放锁以后会从队列中唤醒一个阻塞的节点线程队列内部维护的是一个的双向链表这种结构的特点是每个数据结构都有两个指针分别指向直接的后继节点和直接前驱节点所以双向链表可以从任意一个节点开始很方便的范文前驱和后继节点每个其实是由线程封装当线程争抢锁失败后会封装成加入到队列中对资源的共享方式定义两种资源共享方式独占只有一个线程能执行如又可分为公平锁和非公平锁公平锁按照线程在队列中的排队顺序先到者先拿到锁非公平锁当线程要获取锁时无视队列顺序直接去抢锁谁抢到就是谁的共享多个线程可同时执行如我们都会在后面讲到可以看成是组合式因为也就是读写锁允许多个线程同时对某一资源进行读不同的自定义同步器争用共享资源的方式也不同自定义同步器在实现时只需要实现共享资源的获取与释放方式即可至于具体线程等待队列的维护如获取资源失败入队唤醒出队等已经在顶层实现好了如何让的线程彼此同步使用局部变量实现线程同步你了解过哪些同步器请分别介绍下同步器特征经典的信号量通过计数器控制对共享资源的访问创建拥有个许可证的信号量获取个许可证释放个许可证同步器特征必须发生指定数量的事件后才可以继续运行比如赛跑比赛裁判喊出之后大家才同时跑必须发生个数量才可以打开锁存器等待锁存器触发事件同步器特征适用于只有多个线程都到达预定点时才可以继续执行比如斗地主需要等齐三个人才开始等待线程的数量等待线程的数量以及所有线程到达后的操作到达临界点后暂停线程交换器同步器同步器中的线程池是如何实现的创建一个阻塞队列来容纳任务在第一次执行任务时创建足够多的线程并处理任务之后每个工作线程自动从任务队列中获取线程直到任务队列中任务为为止此时线程处于等待状态一旦有工作任务加入任务队列中即刻唤醒工作线程进行处理实现线程的可复用性线程池一般包括四个基本组成部分线程池管理器用于创建线程池销毁线程池添加新任务工作线程线程池中线程可循环执行任务在没有任务时处于等待状态任务队列用于存放没有处理的任务一种缓存机制任务接口每个任务必须实现的接口供工作线程调度任务的执行主要规定了任务的开始和收尾工作和任务的状态创建线程池的几个核心构造参数线程池的完整构造函数线程池长期维持的最小线程数即使线程处于状态也不会回收线程数的上限线程最大生命周期时间单位任务队列当线程池中的线程都处于运行状态而此时任务数量继续增加则需要一个容器来容纳这些任务这就是任务队列线程工厂定义如何启动一个线程可以设置线程名称并且可以确认是否是后台线程等拒绝任务处理器由于超出线程数量和队列容量而对继续增加的任务进行处理的程序线程池中的线程是怎么创建的是一开始就随着线程池的启动创建好的吗线程池中的线程是在第一次提交任务时创建的创建线程的方式有继承和实现重写方法开始执行等待休眠停止单线程池顾名思义就是一个池中只有一个线程在运行该线程永不超时而且由于是一个线程当有多个任务需要处理时会将它们放置到一个无界阻塞队列中逐个处理它的实现代码如下它的使用方法也很简单下面是简单的示例创建单线程执行器执行一个任务获得任务执行后的返回值返回值关闭执行器缓冲功能的线程建立了一个线程池而且线程数量是没有限制的当然不能超过的最大值新增一个任务即有一个线程处理或者复用之前空闲的线程或者重亲启动一个线程但是一旦一个线程在秒内一直处于等待状态时也就是一分钟无事可做则会被终止其源码如下这里需要说明的是任务队列使用了同步阻塞队列这意味着向队列中加入一个元素即可唤醒一个线程新创建的线程或复用空闲线程来处理这种队列已经没有队列深度的概念了固定线程数量的线程池在初始化时已经决定了线程的最大数量若任务添加的能力超出了线程的处理能力则建立阻塞队列容纳多余的任务其源码如下上面返回的是一个它的和是相等的也就是说最大线程数量为如果任务增长的速度非常快超过了的最大容量的最大值那此时会如何处理呢会按照默认的拒绝策略默认是直接丢弃来处理以上三种线程池执行器都是的简化版目的是帮助开发人员屏蔽过得线程细节简化多线程开发当需要运行异步任务时可以直接通过获得一个线程池然后运行任务不需要关注的一系列参数时什么含义当然有时候这三个线程不能满足要求此时则可以直接操作来实现复杂的多线程计算是线程池的简化版而则是旗舰版简化版容易操作需要了解的知识相对少些方便使用而旗舰版功能齐全适用面广难以驾驭关键字的作用对于可见性提供了关键字来保证可见性和禁止指令重排提供的保证确保一个线程的修改能对其他线程是可见的当一个共享变量被修饰时它会保证修改的值会立即被更新到主存当有其他线程需要读取时它会去内存中读取新值从实践角度而言的一个重要作用就是和结合保证了原子性详细的可以参见包下的类比如常用于多线程环境下的单次操作单次读或者单次写既然能够保证线程间的变量可见性是不是就意味着基于变量的运算就是并发安全的修饰的变量在各个线程的工作内存中不存在一致性的问题在各个线程工作的内存中修饰的变量也会存在不一致的情况但是由于每次使用之前都会先刷新主存中的数据到工作内存执行引擎看不到不一致的情况因此可以认为不存在不一致的问题但是的运算并非原子性的操作导致在并发下并非是线程安全的是什么有哪些使用场景是一个本地线程副本变量工具类在每个线程中都创建了一个对象简单说就是一种以空间换时间的做法每个线程可以访问自己内部对象内的通过这种方式避免资源在多线程间共享原理线程局部变量是局限于线程内部的变量属于线程自身所有不在多个线程间共享提供类来支持线程局部变量是一种实现线程安全的方式但是在管理环境下如服务器使用线程局部变量的时候要特别小心在这种情况下工作线程的生命周期比任何应用变量的生命周期都要长任何线程局部变量一旦在工作完成后没有释放应用就存在内存泄露的风险经典的使用场景是为每个线程分配一个连接这样就可以保证每个线程的都在各自的上进行数据库的操作不会出现线程关了线程正在使用的还有管理等问题请谈谈是怎么解决并发安全的在程序中常用的有两种机制来解决多线程并发问题一种是方式通过锁机制一个线程执行时让另一个线程等待是以时间换空间的方式来让多线程串行执行而另外一种方式就是方式通过创建线程局部变量以空间换时间的方式来让多线程并行执行两种方式各有优劣适用于不同的场景要根据不同的业务场景来进行选择在的源码中就使用了来管理连接在很多开源项目中都经常使用来控制多线程并发问题因为它足够的简单我们不需要关心是否有线程安全问题因为变量是每个线程所特有的很多人都说要慎用谈谈你的理解使用需要注意些什么变量解决了多线程环境下单个线程中变量的共享问题使用名为的哈希表进行维护为变量名为变量的值使用时需要注意以下几点线程之间的变量是互不影响的使用进行修饰防止多实例时内存的泄露问题线程池环境下使用后将变量掉或设置成一个初始值为什么代码会重排序在执行程序时为了提供性能处理器和编译器常常会对指令进行重排序但是不能随意重排序不是你想怎么排序就怎么排序它需要满足以下两个条件在单线程环境下不能改变程序运行的结果存在数据依赖关系的不允许重排序需要注意的是重排序不会影响单线程环境的执行结果但是会破坏多线程的执行语义什么是自旋很多里面的代码只是一些很简单的代码执行时间非常快此时等待的线程都加锁可能是一种不太值得的操作因为线程阻塞涉及到用户态和内核态切换的问题既然里面的代码执行得非常快不妨让等待锁的线程不要被阻塞而是在的边界做忙循环这就是自旋如果做了多次循环发现还没有获得锁再阻塞这样可能是一种更好的策略多线程中锁升级的原理是什么锁升级原理在锁对象的对象头里面有一个字段在第一次访问的时候为空让其持有偏向锁并将设置为其线程再次进入的时候会先判断是否与其线程一致如果一致则可以直接使用此对象如果不一致则升级偏向锁为轻量级锁通过自旋循环一定次数来获取锁执行一定次数之后如果还没有正常获取到要使用的对象此时就会把锁从轻量级升级为重量级锁此过程就构成了锁的升级锁的升级的目的锁升级是为了减低了锁带来的性能消耗在之后优化的实现方式使用了偏向锁升级为轻量级锁再升级到重量级锁的方式从而减低了锁带来的性能消耗和区别是什么是和一样的关键字是类这是二者的本质区别既然是类那么它就提供了比更多更灵活的特性可以被继承可以有方法可以有各种各样的类变量早期的实现比较低效对比大多数场景性能都相差较大但是在中对进行了非常多的改进相同点两者都是可重入锁两者都是可重入锁可重入锁概念是自己可以再次获取自己的内部锁比如一个线程获得了某个对象的锁此时这个对象锁还没有释放当其再次想要获取这个对象的锁的时候还是可以获取的如果不可锁重入的话就会造成死锁同一个线程每次获取锁锁的计数器都自增所以要等到锁的计数器下降为时才能释放锁主要区别如下使用起来比较灵活但是必须有释放锁的配合动作必须手动获取与释放锁而不需要手动释放和开启锁只适用于代码块锁而可以修饰类方法变量等二者的锁机制其实也是不一样的底层调用的是的方法加锁操作的应该是对象头中中每一个对象都可以作为锁这是实现同步的基础普通同步方法锁是当前实例对象静态同步方法锁是当前类的对象同步方法块锁是括号里面的对象中的接口是什么对比同步它有什么优势接口比同步方法和同步块提供了更具扩展性的锁操作他们允许更灵活的结构可以具有完全不同的性质并且可以支持多个相关类的条件对象它的优势有可以使锁更公平可以使线程在等待锁的时候响应中断可以让线程尝试获取锁并在无法获取锁的时候立即返回或者等待一段时间可以在不同的范围以不同的顺序获取和释放锁整体上来说是的扩展版提供了无条件的可轮询的方法定时的带参方法可中断的可多条件队列的方法锁操作另外的实现类基本都支持非公平锁默认和公平锁只支持非公平锁当然在大部分情况下非公平锁是高效的选择和有什么区别是服务器端的程序它担当客户端和服务端的中间层全名为中文名叫服务器页面其本质是一个简化的设计是一种动态页面设计它的主要目的是将表示逻辑从中分离出来只能识别代码不能识别编译后变成了容器将的代码编译成能够识别的类有内置对象没有内置对象有哪些内置对象作用分别是什么九大内置对象页面上下文对象相当于页面中所有功能的集合通过它可以获取页面的对象应用程序对象实现了用户间数据的共享可存放全局变量它开始于服务器启动知道服务器关闭就是本身用于在浏览器内输出信息并且管理应用服务器上的输出缓冲区作用域取得服务器的配置信息和的区别是直接请求转发是间接请求转发又叫重定向客户端和浏览器执行一次请求客户端和浏览器执行两次请求经典的模式就是用于避免用户的非正常访问例如用户非正常访问就可以将请求重定向到登录页面地址不变地址改变常用方法类的方法常用方法类的方法说一下的种作用域和有什么区别存储位置不同在客户端浏览器在服务器存储容量不同存储方式不同只能保存字符串并需要通过编码方式存储为字符或者二进制数据中能存储任何类型的数据包括并不局限于等隐私策略不同对客户端是可见的不安全存储在服务器上安全有效期不同开发可以通过设置的属性达到使长期有效的效果依赖于名为的而的过期时间默认为只需关闭窗口该就会失效因而达不到长期有效的效果跨域支持上不同支持跨域不支持跨域如果客户端禁止能实现还能用吗一般默认情况下在会话中服务器存储的是通过存到浏览器里如果浏览器禁用了浏览器请求服务器无法携带服务器无法识别请求中的用户身份失效但是可以通过其他方法在禁用的情况下可以继续使用通过重写把作为参数追加的原中后续的浏览器与服务器交互中携带参数服务器的返回数据中包含浏览器发送请求时携带参数通过协议其他字段服务器每次返回时设置该字段信息浏览器中读取该字段请求服务器时设置携带该字段什么是上下文切换多线程编程中一般线程的个数都大于核心的个数而一个核心在任意时刻只能被一个线程使用为了让这些线程都能得到有效执行采取的策略是为每个线程分配时间片并轮转的形式当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用这个过程就属于一次上下文切换概括来说就是当前任务在执行完时间片切换到另一个任务之前会先保存自己的状态以便下次再切换回这个任务时可以再加载这个任务的状态任务从保存到再加载的过程就是一次上下文切换上下文切换通常是计算密集型的也就是说它需要相当可观的处理器时间在每秒几十上百次的切换中每次切换都需要纳秒量级的时间所以上下文切换对系统来说意味着消耗大量的时间事实上可能是操作系统中时间消耗最大的操作相比与其他操作系统包括其他类系统有很多的优点其中有一项就是其上下文切换和模式切换的时间消耗非常少机制是服务端存储的一个对象主要用来存储所有访问过该服务端的客户端的用户信息也可以存储其他信息从而实现保持用户会话状态但是服务器重启时内存会被销毁存储的用户信息也就消失了不同的用户访问服务端的时候会在对象中存储键值对键用来存储开启这个用户信息的钥匙在登录成功后钥匙通过返回给客户端客户端存储为记录在中当客户端再次访问时会默认携带中的来实现会话机制是基于的的数据左右存储数据的格式字符串存储有效期可以自行通过进行具体的日期设置如果没设置默认是关闭浏览器时失效有效范围当前域名下有效所以这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上前后端项目协议域名端口号都一致即在一个项目下持久化用于解决重启服务器后消失的问题在数据库中存储而不是存储在内存中通过包当客户端存储的失效后服务端的不会立即销毁会有一个延时服务端会定期清理无效不会造成无效数据占用存储空间的问题机制适用于前后端分离的项目前后端代码运行在不同的服务器下请求登录时和原理相同是对和对应的用户信息进行加密后的加密字符登录成功后会在响应主体中将字符串返回给客户端客户端通过都可以进行存储再次请求时不会默认携带需要在请求拦截器位置给请求头中添加认证字段携带信息服务器就可以通过信息查找用户登录状态说一下的工作原理当客户端登录完成后会在服务端产生一个此时服务端会将返回给客户端浏览器客户端将储存在浏览器的中当用户再次登录时会获得对应的然后将发送到服务端请求登录服务端在内存中找到对应的完成登录如果找不到返回登录页面响应码和代表的是什么有什么区别和状态码都表示重定向当浏览器拿到服务器返回的这个状态码后悔自动跳转到一个新的地址代表永久性重定向旧地址被永久移除客户端向新地址发送请求代表暂时性重定向旧地址还在客户端继续向旧地址发送请求代表暂时性重定向重定向到新地址时必须使用方法请求新地址代表暂时性重定向与的区别在于不允许从改为代表永久性重定向与的区别在于不允许从改为简述和的区别是传输控制协议是用户数据表协议长连接无连接程序结构较简单只需发送无须接收可靠保证数据正确性顺序性不可靠可能丢数据适用于少量数据适用于大量数据传输速度慢速度快为什么要三次握手两次不行吗为什么因为客户端和服务端都要确认连接客户端请求连接服务端针对客户端的请求确认应答并请求建立连接针对服务端的请求确认应答建立连接两次无法确保能收到的数据的七层模型都有哪些和请求有哪些区别请求参数是连接在后面的而请求参数是存放在内的请求因为浏览器对长度有限制所以参数个数有限制而请求参数个数没有限制因为请求参数暴露在上所以安全方面比更加安全请求只能进行编码而请求可以支持多种编码方式请求参数会保存在浏览器历史记录内请求并不会请求浏览器会主动并不会除非主动设置请求产生个数据包请求产生个数据包在浏览器进行回退操作时请求是无害的而请求则会重新请求一次浏览器在发送请求时会将和一起发送给服务器服务器返回状态码而在发送请求时会先将发送给服务器服务器返回之后再将发送给服务器服务器返回什么是攻击如何避免即跨站脚本攻击是一种常见于应用程序中的计算机安全漏洞指的是在用户浏览器上在渲染树的时候执行了不可预期的脚本从而发生了安全问题就是通过在用户端注入恶意的可运行脚本若服务端对用户的输入不进行处理直接将用户的输入输出到浏览器然后浏览器将会执行用户注入的脚本所以攻击的核心就是浏览器渲染的时候将文本信息解析成脚本从而引发脚本注入那么攻击的防御手段就是基于浏览器渲染这一步去做防御只要我们使用编码将浏览器需要渲染的信息编码后浏览器在渲染元素的时候会自动解码需要渲染的信息将上述信息解析成字符串而不是脚本这就是我们防御攻击的核心想法预防获取用户的输入不用用对用户的输入进行过滤如对等进行转义什么是攻击如何避免跨站请求伪造英语也被称为或者通常缩写为或者是一种挟制用户在当前已登录的应用程序上执行非本意的操作的攻击方法跟跨网站脚本相比利用的是用户对指定网站的信任利用的是网站对用户网页浏览器的信任攻击细节跨站请求攻击简单地说是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作如发邮件发消息甚至财产操作如转账和购买商品由于浏览器曾经认证过所以被访问的网站会认为是真正的用户操作而去运行这利用了中用户身份验证的一个漏洞简单的身份验证只能保证请求发自某个用户的浏览器却不能保证请求本身是用户自愿发出的例子假如一家银行用以运行转账操作的地址如下那么一个恶意攻击者可以在另一个网站上放置如下代码如果有账户名为的用户访问了恶意站点而她之前刚访问过银行不久登录信息尚未过期那么她就会损失资金这种恶意的网址可以有很多种形式藏身于网页中的许多地方此外攻击者也不需要控制放置恶意网址的网站例如他可以将这种地址藏在论坛博客等任何用户生成信息的网站中这意味着如果服务端没有合适的防御措施的话用户即使访问熟悉的可信网站也有受攻击的危险透过例子能够看出攻击者并不能通过攻击来直接获取用户的账户控制权也不能直接窃取用户的任何信息他们能做到的是欺骗用户浏览器让其以用户的名义运行操作防御措施检查字段头中有一个字段这个字段用以标明请求来源于哪个地址在处理敏感数据请求时通常来说字段应和请求的地址位于同一域名下以上文银行操作为例字段地址通常应该是转账按钮所在的网页地址应该也位于之下而如果是攻击传来的请求字段会是包含恶意网址的地址不会位于之下这时候服务器就能识别出恶意的访问这种办法简单易行工作量低仅需要在关键访问处增加一步校验但这种办法也有其局限性因其完全依赖浏览器发送正确的字段虽然协议对此字段的内容有明确的规定但并无法保证来访的浏览器的具体实现亦无法保证浏览器没有安全漏洞影响到此字段并且也存在攻击者攻击某些浏览器篡改其字段的可能添加校验由于的本质在于攻击者欺骗用户去访问自己设置的地址所以如果要求在访问敏感数据请求时要求用户浏览器提供不保存在中并且攻击者无法伪造的数据作为校验那么攻击者就无法再运行攻击这种数据通常是窗体中的一个数据项服务器将其生成并附加在窗体中其内容是一个伪随机数当客户端通过窗体提交请求时这个伪随机数也一并提交上去以供校验正常的访问时客户端浏览器能够正确得到并传回这个伪随机数而通过传来的欺骗性攻击中攻击者无从事先得知这个伪随机数的值服务端就会因为校验的值为空或者错误拒绝这个可疑请求如何实现跨域说一下实现原理原理详解终于搞清楚是啥了最流行的跨域方案是目前主流的跨域解决方案跨域资源共享是一种机制它使用额外的头来告诉浏览器让运行在一个上的应用被准许访问来自不同源服务器上的指定的资源当一个资源从与该资源本身所在的服务器不同的域协议或端口请求一个资源时资源会发起一个跨域请求最方便的跨域方案是一款极其强大的服务器其优点就是轻量级启动快高并发现在的新项目中几乎是首选我们用或者开发的服务通常都需要经过的反向代理反向代理的原理很简单即所有客户端的请求都必须先经过的处理作为代理服务器再讲请求转发给或者服务这样就规避了同源策略应用的是哪个协议是一个允许应用程序通常指浏览器与服务器进行双向通信的协议的主要是为浏览器端提供了一个基于协议实现全双工通信的方法优势浏览器和服务器只需要要做一个握手的动作在建立连接之后双方可以在任意时刻相互推送信息同时服务器与客户端之间交换的头信息很小说一下粘包是怎么产生的发送方需要等缓冲区满才能发送出去造成粘包接收方不及时接收缓冲区的包造成粘包请列举出在中几个常用的设计模式单例模式作用保证类只有一个实例中体现类静态工厂模式作用代替构造函数创建对象方法名比构造函数清晰中体现抽象工厂作用创建某一种类的对象中体现包原型模式原型模式的本质是拷贝原型来创建新的对象拷贝是比更快的创建对象的方法当需要大批量创建新对象而且都是同一个类的对象的时候考虑使用原型模式一般的克隆只是浅拷贝对象的值不一样但是对象里面的成员变量的值是一样的有些场景需要深拷贝这时我们就要重写方法以为例适配器模式作用使不兼容的接口相容中体现装饰器模式作用为类添加新的功能防止类继承带来的类爆炸中体现类外观模式作用封装一组交互类一直对外提供接口中体现包享元模式作用共享对象节省内存中体现常量池代理模式作用透明调用被代理对象无须知道复杂实现细节增加被代理类的功能中体现动态代理迭代器模式作用将集合的迭代和集合本身分离中体现命令模式作用封装操作使接口一致中体现什么是设计模式你是否在你的代码里面使用过任何设计模式什么是设计模式设计模式是解决软件开发某些特定问题而提出的一些解决方案也可以理解为解决问题的一些固定思路通过设计模式可以帮助我们增强代码的可复用性可扩展性灵活性我们使用设计模式的最终目的是实现代码的高内聚低耦合设计模式的七大原则单一职责原则接口隔离原则依赖倒转原则里式替换原则开闭原则迪米特法则合成复用原则你是否在你的代码里面使用过任何设计模式单例模式种的种的简单工厂模式的根据传入一个唯一标识来获得对象原型模式代理模式的中实现功能的原理就是代理模式动态代理动态代理使用通知对类进行方法级别的切面增强装饰器模式为类添加新的功能防止类爆炸流数据源包装中用到的装饰器模式表现在中什么叫单例设计模式请用写出线程安全的单例模式保证程序只有一个对象的实例叫做单例模式内部类的方式实现单例模式是线程安全的双重验证方式实现单例模式也是线程安全的在中什么叫观察者设计模式观察者模式是一种一对多的依赖关系让多个观察者同时监听某一主题对象当这个主题对象发生变化时会通知所有观察者对象使它们能够自动更新自己提供的对观察者模式的支持在语言的库里面提供了一个类以及一个接口构成语言对观察者模式的支持接口这个接口只定义了一个方法即方法当被观察者对象的状态发生变化时被观察者对象的方法就会调用这一方法类被观察者类都是类的子类提供公开的方法支持观察者对象这些方法中有两个对的子类非常重要一个是另一个是第一方法被调用之后会设置一个内部标记变量代表被观察者对象的状态发生了变化第二个是这个方法被调用时会调用所有登记过的观察者对象的方法使这些观察者对象可以更新自己使用工厂模式最主要的好处是什么在哪里使用工厂模式好处良好的封装性代码结构清晰扩展性好如果想增加一个产品只需扩展一个工厂类即可典型的解耦框架在哪里使用需要生成对象的地方不同数据库的访问请解释自动装配模式的区别有五种自动装配的方式可以用来指导容器用自动装配方式来进行依赖注入默认的方式是不进行自动装配通过显式设置属性来进行装配第页共页通过参数名自动装配容器在配置文件中发现的属性被设置成之后容器试图匹配装配和该的属性具有相同名字的通过参数类型自动装配容器在配置文件中发现的属性被设置成之后容器试图匹配装配和该的属性具有相同类型的如果有多个符合条件则抛出错误这个方式类似于但是要提供给构造器参数如果没有确定的带参数的构造器参数类型将会抛出异常首先尝试使用来自动装配如果无法工作则使用方式举一个用实现的装饰模式它是作用于对象层次还是类层次在中运用了装饰器模式作为抽象类其下有几个实现类表示从不同的数据源输入从管道产生输入可将其他流收集合并到一个流内作为装饰器在中是一个普通类其下面有多个具体装饰器比如等内部封装了基础构件而在调用其读取数据时会委托基础构件来进行更底层的操作而它自己所起的装饰作用就是缓冲在源码中可以很清楚的看到这一切什么是框架框架有哪些主要模块是一个控制反转和面向切面的容器框架有七大功能模块模块是的核心类库实现了功能模块是的库提供了拦截器机制并提供常见的拦截器供用户自定义和配置提供对常用框架的管理和支持等提供对的支持对进行封装对的支持模块提供框架式的的访问方式其它程序可以通过访问的资源相当于资源注入模块为提供了一套轻量级的实现即使用框架能带来哪些好处轻量级框架容器是一个容器管理对象的生命周期和配置基于一个可配置原型你的可以使单利的也可以每次需要时都生成一个新的实例控制反转通过控制反转实现松耦合支持提供对的支持它允许将一些通用任务如安全事务日志等进行集中式处理从而提高了程序的复用性轻量级框架方便测试提供的支持可以通过注解方便测试程序对中很多进行了封装方便集成各种优秀框架如支持声明式事务处理只需通过配置就可以完成对事务的管理而无须手动编程举例说明理论的背景我们都知道在采用面向对象方法设计的软件系统中它的底层实现都是由个对象组成的所有的对象通过彼此的合作最终实现系统的业务逻辑如果我们打开机械式手表的后盖就会看到与上面类似的情形各个齿轮分别带动时针分针和秒针顺时针旋转从而在表盘上产生正确的时间图中描述的就是这样的一个齿轮组它拥有多个独立的齿轮这些齿轮相互啮合在一起协同工作共同完成某项任务我们可以看到在这样的齿轮组中如果有一个齿轮出了问题就可能会影响到整个齿轮组的正常运转齿轮组中齿轮之间的啮合关系与软件系统中对象之间的耦合关系非常相似对象之间的耦合关系是无法避免的也是必要的这是协同工作的基础现在伴随着工业级应用的规模越来越庞大对象之间的依赖关系也越来越复杂经常会出现对象之间的多重依赖性关系因此架构师和设计师对于系统的分析和设计将面临更大的挑战对象之间耦合度过高的系统必然会出现牵一发而动全身的情形耦合关系不仅会出现在对象与对象之间也会出现在软件系统的各模块之间以及软件系统和硬件系统之间如何降低系统之间模块之间和对象之间的耦合度是软件工程永远追求的目标之一为了解决对象之间的耦合度过高的问题软件专家提出了理论用来实现对象之间的解耦目前这个理论已经被成功地应用到实践当中很多的项目均采用了框架产品什么是控制反转是的缩写多数书籍翻译成控制反转还有些书籍翻译成为控制反向或者控制倒置年在一篇有关探讨面向对象框架的文章中首先提出了这个概念对于面向对象设计及编程的基本思想前面我们已经讲了很多了不再赘述简单来说就是把复杂系统分解成相互合作的对象这些对象类通过封装以后内部实现对外部是透明的从而降低了解决问题的复杂度而且可以灵活地被重用和扩展理论提出的观点大体是这样的借助于第三方实现具有依赖关系的对象之间的解耦如下图大家看到了吧由于引进了中间位置的第三方也就是容器使得这个对象没有了耦合关系齿轮之间的传动全部依靠第三方了全部对象的控制权全部上缴给第三方容器所以容器成了整个系统的关键核心它起到了一种类似粘合剂的作用把系统中的所有对象粘合在一起发挥作用如果没有这个粘合剂对象与对象之间会彼此失去联系这就是有人把容器比喻成粘合剂的由来我们再来做个试验把上图中间的容器拿掉然后再来看看这套系统拿掉容器后的系统我们现在看到的画面就是我们要实现整个系统所需要完成的全部内容这时候这个对象之间已经没有了耦合关系彼此毫无联系这样的话当你在实现的时候根本无须再去考虑和了对象之间的依赖关系已经降低到了最低程度所以如果真能实现容器对于系统开发而言这将是一件多么美好的事情参与开发的每一成员只要实现自己的类就可以了跟别人没有任何关系我们再来看看控制反转到底为什么要起这么个名字我们来对比一下软件系统在没有引入容器之前如图所示对象依赖于对象那么对象在初始化或者运行到某一点的时候自己必须主动去创建对象或者使用已经创建的对象无论是创建还是使用对象控制权都在自己手上软件系统在引入容器之后这种情形就完全改变了如图所示由于容器的加入对象与对象之间失去了直接联系所以当对象运行到需要对象的时候容器会主动创建一个对象注入到对象需要的地方通过前后的对比我们不难看出来对象获得依赖对象的过程由主动行为变为了被动行为控制权颠倒过来了这就是控制反转这个名称的由来的别名依赖注入年探讨了同一个问题既然是控制反转那么到底是哪些方面的控制被反转了呢经过详细地分析和论证后他得出了答案获得依赖对象的过程被反转了控制被反转之后获得依赖对象的过程由自身管理变为了由容器主动注入于是他给控制反转取了一个更合适的名字叫做依赖注入他的这个答案实际上给出了实现的方法注入所谓依赖注入就是由容器在运行期间动态地将某种依赖关系注入到对象之中所以依赖注入和控制反转是从不同的角度的描述的同一件事情就是指通过引入容器利用依赖关系注入的方式实现对象之间的解耦我们举一个生活中的例子来帮助理解依赖注入的过程大家对接口和设备应该都很熟悉吧为我们使用电脑提供了很大的方便现在有很多的外部设备都支持接口现在我们利用电脑主机和接口来实现一个任务从外部设备读取一个文件电脑主机读取文件的时候它一点也不会关心接口上连接的是什么外部设备而且它确实也无须知道它的任务就是读取接口挂接的外部设备只要符合接口标准即可所以如果我给电脑主机连接上一个盘那么主机就从盘上读取文件如果我给电脑主机连接上一个外置硬盘那么电脑主机就从外置硬盘上读取文件挂接外部设备的权力由我作主即控制权归我至于接口挂接的是什么设备电脑主机是决定不了它只能被动的接受电脑主机需要外部设备的时候根本不用它告诉我我就会主动帮它挂上它想要的外部设备你看我的服务是多么的到位这就是我们生活中常见的一个依赖注入的例子在这个过程中我就起到了容器的作用通过这个例子依赖注入的思路已经非常清楚当电脑主机读取文件的时候我就把它所要依赖的外部设备帮他挂接上整个外部设备注入的过程和一个被依赖的对象在系统运行时被注入另外一个对象内部的过程完全一样我们把依赖注入应用到软件系统中再来描述一下这个过程对象依赖于对象当对象需要用到对象的时候容器就会立即创建一个对象送给对象容器就是一个对象制造工厂你需要什么它会给你送去你直接使用就行了而再也不用去关心你所用的东西是如何制成的也不用关心最后是怎么被销毁的这一切全部由容器包办在传统的实现中由程序内部代码来控制组件之间的关系我们经常使用关键字来实现两个组件之间关系的组合这种实现方式会造成组件之间耦合很好地解决了该问题它将实现组件间关系从程序内部提到外部容器也就是说由容器在运行期将组件间的某种依赖关系动态注入组件中为我们带来了什么好处我们还是从的例子说起使用外部设备比使用内置硬盘到底带来什么好处第一设备作为电脑主机的外部设备在插入主机之前与电脑主机没有任何的关系只有被我们连接在一起之后两者才发生联系具有相关性所以无论两者中的任何一方出现什么的问题都不会影响另一方的运行这种特性体现在软件工程中就是可维护性比较好非常便于进行单元测试便于调试程序和诊断故障代码中的每一个都可以单独测试彼此之间互不影响只要保证自身的功能无误即可这就是组件之间低耦合或者无耦合带来的好处第二设备和电脑主机的之间无关性还带来了另外一个好处生产设备的厂商和生产电脑主机的厂商完全可以是互不相干的人各干各事他们之间唯一需要遵守的就是接口标准这种特性体现在软件开发过程中好处可是太大了每个开发团队的成员都只需要关心实现自身的业务逻辑完全不用去关心其它的人工作进展因为你的任务跟别人没有任何关系你的任务可以单独测试你的任务也不用依赖于别人的组件再也不用扯不清责任了所以在一个大中型项目中团队成员分工明确责任明晰很容易将一个大的任务划分为细小的任务开发效率和产品质量必将得到大幅度的提高第三同一个外部设备可以插接到任何支持的设备可以插接到电脑主机也可以插接到机外部设备可以被反复利用在软件工程中这种特性就是可复用性好我们可以把具有普遍性的常用组件独立出来反复利用到项目中的其它部分或者是其它项目当然这也是面向对象的基本特征显然不仅更好地贯彻了这个原则提高了模块的可复用性符合接口标准的实现都可以插接到支持此标准的模块中第四同外部设备一样模块具有热插拔特性生成对象的方式转为外置方式也就是把对象生成放在配置文件里进行定义这样当我们更换一个实现子类将会变得很简单只要修改配置文件就可以了完全具有热插拨的特性以上几点好处难道还不足以打动我们让我们在项目开发过程中使用框架吗容器的技术剖析中最基本的技术就是反射编程目前和等语言均支持其中的技术书籍中有时候也被翻译成映射有关反射的概念和用法大家应该都很清楚通俗来讲就是根据给出的类名字符串方式来动态地生成对象这种编程方式可以让对象在生成时才决定到底是哪一种对象反射的应用是很广泛的很多的成熟的框架比如象中的框架中框架都是把反射做为最基本的技术手段反射技术其实很早就出现了但一直被忽略没有被进一步的利用当时的反射编程方式相对于正常的对象生成方式要慢至少得倍现在的反射技术经过改良优化已经非常成熟反射方式生成对象和通常对象生成方式速度已经相差不大了大约为倍的差距我们可以把容器的工作模式看做是工厂模式的升华可以把容器看作是一个工厂这个工厂里要生产的对象都在配置文件中给出定义然后利用编程语言的的反射编程根据配置文件中给出的类名生成相应的对象从实现来看是把以前在工厂方法里写死的对象生成代码改变为由配置文件来定义也就是把工厂和对象生成这两者独立分隔开来目的就是提高灵活性和可维护性容器的一些产品技术体系下的容器有轻量级的有重量级的有不轻不重的有等等框架作为开发中三剑客之一大中小项目中都有使用非常成熟应用广泛在关键性的工业级项目中也被使用比如某些电信业务技术体系下的容器有等等是从的移植过来的容器的容器就是部分它们均是轻量级的框架比较成熟其中已经被逐渐应用于各种项目中使用框架应该注意什么使用框架产品能够给我们的开发过程带来很大的好处但是也要充分认识引入框架的缺点做到心中有数杜绝滥用框架软件系统中由于引入了第三方容器生成对象的步骤变得有些复杂本来是两者之间的事情又凭空多出一道手续所以我们在刚开始使用框架的时候会感觉系统变得不太直观所以引入了一个全新的框架就会增加团队成员学习和认识的培训成本并且在以后的运行维护中还得让新加入者具备同样的知识体系由于容器生成对象是通过反射方式在运行效率上有一定的损耗如果你要追求运行效率的话就必须对此进行权衡具体到框架产品比如来讲需要进行大量的配制工作比较繁琐对于一些小的项目而言客观上也可能加大一些工作成本框架产品本身的成熟度需要进行评估如果引入一个不成熟的框架产品那么会影响到整个项目所以这也是一个隐性的风险我们大体可以得出这样的结论一些工作量不大的项目或者产品不太适合使用框架产品另外如果团队成员的知识能力欠缺对于框架产品缺乏深入的理解也不要贸然引入最后特别强调运行效率的项目或者产品也不太适合引入框架产品象网站就是这种情况什么是控制反转什么是依赖注入借助实现具有依赖关系的对象之间的解耦对象运行需要对象由主动创建变为容器注入这便是控制反转获得依赖对象的过程被反转了获取依赖对象的过程由自身创建变为由容器注入这便是依赖注入和有什么区别是的最底层接口包含的定义管理的加载实例化控制的生命周期特点是每次获取对象时才会创建对象是的子接口拥有的全部功能并且扩展了很多高级特性每次容器启动时就会创建所有的对象的额外功能继承支持国际化统一的资源文件访问方式提供在监听器中注册同时加载过个配置文件载入多个有继承关系上下文使得每个上下文都专注于一个特定的层次比如应用的层通常以编程的方式被创建可以以声明的方式创建如使用和都支持但需要手动注册则是自动注册什么是是新增的概念就是以注解的形式取代中繁琐的文件结合了的解耦和编译时检查的优点表示这个类是配置类相当于的相当于的相当于的相当于的用于读取配置文件一般用于多环境配置激活时可用注解什么是框架对象关系映射是为了解决面向对象与关系型数据库存在的不匹配问题框架的优点开发效率更高数据访问更抽象轻便支持面向对象封装有几种配置方式配置文件基于注解的方式项目越来越大基于配置太麻烦时代提供了声明的注解的定义的注入基于的方式以后可以通过代码装配两个狗方法略原来就是配置类啊通过方式进行的注册和发现请解释的生命周期通过构造器或工厂方法创建实例为的属性赋值调用的初始化方法使用当容器关闭时调用的销毁方法的作用域之间有什么区别容器中的可以分为个范围这种范围是默认的这种范围确保不管接受多少请求每个容器中只哟一个的实例单例模式为每一个提供一个实例在请求范围内为每一个来自客户端的网络请求创建一个实例在请求完毕后会失效并被垃圾回收器回收为每个创建一个实例过期后会随之消失和应用相关当你的应用部署在容器中工作时它包含很多如果你想要声明让所有的公用全局的存储变量的话那么全局变量需要存储在中如何在中禁用端点安全性默认情况下所有敏感的端点都是安全的只有具有角色的用户才能访问它们安全性是使用标准的方法实施的我们可以使用来禁用安全性只有在执行机构端点在防火墙后访问时才建议禁用安全性什么是在框架中无论何时被使用时当仅被调用一个属性可以将这个声明为内部内部可以用注入属性和构造方法注入构造参数的方式来实现比如在我们的应用程序中一个类引用了一个类我们要做的是创建一个实例然后再内部使用框架中的单例是线程安全的么框架并没有对单例进行任何多线程的封装处理关于单例的线程安全和并发问题需要开发者自行去搞定但实际上大部分的并没有可变的状态所以在某种程度上说的单例时线程安全的如果你的有多种状态的话比如就需要自行保证线程安全啦最浅显的解决办法就是将多态的作用域由变更为请解释的自动装配支持自动装配不用类实例化直接从容器中取配置在中如何开启基于注解的自动装配要使用需要注册可以有以下两种方式来实现引入配置文件中的下引入在配置文件中直接引入什么是什么是是一个轻量级的完善的批处理框架它主要的目的在于帮助企业建立健壮高效的批处理应用是的一个子项目它使用语言并基于框架作为基础开发使得已经使用框架的开发者或者是企业可以更加容易访问和利用企业服务提供了大量可重用的组件包括了日志追踪事务任务作业统计任务重启跳过重复资源管理对大数据量和高性能的批处理任务同样提供了高级功能和特性来支持例如分区功能远程功能总的来说可以支持简单的复杂的和大数据量的批处理作业业务场景周期性的提交批处理把一个任务并行处理消息驱动应用分级处理大规模并行批处理手工或调度使任务失败之后重新启动有依赖步骤的顺序执行使用工作流驱动扩展处理时跳过部分记录成批事务为小批量的或有的存储过程脚本的场景使用和的区别是什么拦截机制的不同是类级别的拦截每次请求就会创建一个和整合时的注入作用域是原型模式然后通过吧数据注入到属性中一个对应一个上下文在接收参数时可以通过属性接收这说明属性参数是让多个方法共享的中的一个方法可以对应一个而其类属性却被所有方法共享这也就无法用注解或其他方式标识其所属方法了只能设计为多例是方法级别的拦截一个方法对应一个上下文所以方法直接基本上是独立的独享数据而每个方法同时又何一个对应参数的传递是直接注入到方法中的是方法所独有的处理结果通过返回给框架在整合时的默认单例模式所以默认对所有的请求只会创建一个有应为没有共享的属性所以是线程安全的如果要改变默认的作用域需要添加注解修改有自己的拦截机制这是用的是独立的方式这样导致的配置文件量还是比大底层框架的不同采用实现则采用实现在容器启动之后即初始化服务停止以后坠毁晚于在是在调用时初始化先于调用服务停止后销毁性能方面是类级别的拦截每次请求对应实例一个新的需要加载所有的属性值注入实现了零配置由于基于方法的拦截有加载一次单例模式注入所以开发效率和性能高于配置方面和是无缝的从这个项目的管理和安全上也比高请举例解释注解注解应用于属性的方法它表明影响的属性在配置时必须放在配置文件中十九请举例说明注解如果在中定义了一种类型的多个同时在注解中又想把其中一个对象作为属性那么此时可以使用加来达到这一目的若不加这个注解在运行时会出现这个异常常用注解常用注解绝对经典项目中是如何实现权限验证的权限验证需要几张表通过了解现在最普遍的权限管理模型就是权限控制分类菜单功能控制控制访问不同的控制器的优缺点优点简化了用户和权限的关系易扩展易维护缺点模型没有提供操作顺序的控制机制这一缺陷使得模型很难适应哪些对操作次序有严格要求的系统支持的安全原则最小权限原则可以将角色配置成其完成任务所需的最小权限集合责任分离原则可以通过调用相互独立互斥的角色来共同完成敏感的任务例如要求一个记账员和财务管理员共同参与统一过账操作数据抽象原则可以通过权限的抽象来体现例如财务操作用借款存款等抽象权限而不是使用典型的读写权限远古时代的权限控制当时还没有也没有这个概念就是一堆程序员在那鼓捣觉得登录这块该做点什么新建一个用户对这个用户进行赋予权限但是一旦用户多了权限复杂了这工作量也是蛮大的直接上图一目了然当程序不是很复杂的时候就是这样设计的我们公司的权限验证模块就是这样设计的简简单单五张表解基于模型的基础上进行了角色的访问控制中的一个基本限制是互斥角色的限制互斥角色是指各自权限可以互相制约的两个角色对于这类角色一个用户在某一次活动中只能被分配其中的一个角色不能同时获得两个角色的使用权该模型有以下几种约束互斥角色同一用户只能分配到一组互斥角色集合中至多一个角色支持责任分离的原则互斥角色是指各自权限互相制约的两个角色对于这类角色一个用户在某一次活动中只能被分配其中的一个角色不能同时获得两个角色的使用权常举的例子在审计活动中一个角色不能同时被指派给会计角色和审计员角色基数约束一个角色被分配的用户数量受限一个用户可拥有的角色数目受限同样一个角色对应的访问权限数目也应受限以控制高级权限在系统中的分配先决条件角色可以分配角色给用户仅当该用户已经是另一角色的成员对应的可以分配访问权限给角色仅当该角色已经拥有另一种访问权限指要想获得较高的权限要首先拥有低一级的权限运行时互斥例如允许一个用户具有两个角色的成员资格但在运行中不可同时激活这两个角色的实现理论分析进入登录页面拿到通过传过来的用户名和密码使用进行过滤查找如果能找到值则说明登录成功登录成功后调用初始化函数初始化函数的主要功能是获取用户的权限和菜单保存到中并跳转客户列表页面如果失败页面进行友好提示权限控制关键代码谈谈接口调用的路径问题如何匹配请求路径是用来映射请求的比如请求请求或者风格与非风格的该注解可以用在类上或方法上如果用在类上表示是该类中所有方法的父路径在类上还添加了一个注解该注解在中负责处理由分发的请求它把用户请求的数据经过业务处理层处理之后封装成一个然后再把该返回给对应的进行展示我们可以通过这个路径来定位到这个方法然后执行方法内的方法体可以实现模糊匹配路径比如表示一个字符表示任意字符匹配多层路径就可以匹配这样的路径了如何获取请求的参数该注解用来映射请求中绑定的占位符通过可以将中占位符的参数绑定到处理方法的入参中在中我们添加一条连接用来触发一个请求该注解也是用来获取请求参数的那么该注解和有什么不同呢在添加超链接标签风格的请求在中业务最多的应该是了如何防止表单重复提交通过屏蔽提交按钮不推荐给数据库增加唯一键约束简单粗暴利用防止表单重复提交推荐使用自定义切入实现中都应用了哪些设计模式简单工厂模式简单工厂模式的本质就是一个工厂类根据传入的参数动态的决定实例化哪个类中的就是简单工厂模式的体现根据传入一个唯一的标识来获得对象工厂方法模式应用程序将对象的创建及初始化职责交给工厂对象工厂定义工厂方法然后通过配置文件将其纳入容器来管理需要通过指定静态方法名称单例模式用的是双重判断加锁的单例模式通过方法从中获取代理模式的中使用的通知来增强被代理类的功能实现功能的原理就是代理模式动态代理字节码生成技术代理对类进行方法级别的切面增强装饰器模式装饰器模式动态的给一个对象添加一些额外的功能的中配置所有的这些可能是不同的数据库然后根据用户的每次请求将设置成不同的数据源以达到切换数据源的目的在中有两种表现一种是类名中含有另一种是类名中含有观察者模式定义对象间的一对多的关系当一个对象的状态发生改变时所有依赖于它的对象都得到通知并自动更新中观察者模式一般用在的实现策略模式策略模式是行为性模式调用不同的方法适应行为的变化强调父类的调用子类的特性是接口中的唯一方法用于根据请求找到匹配的处理器模板方法模式的方法总体结构是一个模板方法回调函数方法中调用的是一个模板方法而预期的回调方法也是一个模板方法请举例说明如何在中注入一个注入有四种方式注入构造器注入基于注解的注入配置文件注入想要注入就是注入集合类该标签支持注入键和值都是字符串类型的键值对和都使用标签使用标签使用标签中和的区别是什么带引号不带引号可以防止注入常用于数据库表名子句一般能用就不要使用是否支持延迟加载延迟加载的原理是什么是否支持延迟加载延迟加载其实就是讲数据加载时机推迟比如推迟嵌套查询的时机延迟加载可以实现先查询主表按需实时做关联查询返回关联表结果集一定程度上提高了效率仅支持关联对象和关联集合对象的延迟加载是一对一是一对多查询在配置文件中可以配置延迟加载的原理是什么使用为目标对象建立代理对象当调用目标对象的方法时进入拦截器方法比如调用拦截器方法发现为会单独发送事先准备好的查询关联对象的语句把查询出来然后调用也是的对象的属性就有值了然后调用这就是延迟加载的原理说一下的一级缓存和二级缓存一级缓存是级别的缓存默认开启当查询一次数据库时对查询结果进行缓存如果之后的查询在一级缓存中存在则无需再访问数据库二级缓存是级别的缓存需要配置才会开启当进行语句查询时先查看一级缓存如果不存在访问二级缓存降低数据库访问压力有哪些执行器有三种基本的执行器每执行一次或就开启一个对象用完立刻关闭对象执行或以做为查找对象存在就使用不存在就创建用完后不关闭对象而且放置于内供下一次使用简言之就是重复使用对象执行将所有通过都添加到批处理中等待统一执行它缓存了多个对象每个对象都是完毕后等待逐一执行批处理与批处理相同作用范围的这些特点都严格限制在生命周期范围内中如何指定使用哪一种执行器在的配置文件中可以指定默认的执行器类型也可以手动给的创建的方法传递类型参数和的区别有哪些两者最大的区别针对简单逻辑都有对应的代码生成工具可以生成简单基本的层方法针对高级查询要手动编写语句和而有良好的映射机制开发难度对比日志统计有自己的日志统计功能而需要借助来记录日志数据库扩展比较缓存机制比较因为对查询对象有良好的管理机制用户无需关心所以使用二级缓存如果出现脏数据系统会报错而如果不能获取最新数据应该避免缓存的使用脏数据的出现会给系统的正常运行带来很大的隐患如何选择需要编写和映射规则工作量大于支持的工具也有限不能像那样有许多插件可以帮助生成映射代码和关联关系对于性能要求不太苛刻的系统比如管理系统等推荐对于性能要求高响应快灵活的系统比如电商系统推荐使用查询多个常用属性查询多个我居然回答用对象来传递一级缓存二级缓存一级缓存指的是中对象的缓存当我们执行查询以后查询的结果会同时存入中再次查询的时候先去中查询有的话直接拿出当消失时的一级缓存也就消失了当调用的修改添加删除等方法时会清空一级缓存二级缓存指的是中的对象的缓存由同一个对象创建的共享其缓存但是其中缓存的是数据而不是对象当命中二级缓存时通过存储的数据构造成对象返回查询数据的时候查询的流程是二级缓存一级缓存数据库如果开启了二级缓存进行后才会把一级缓存中的数据添加到二级缓存中为了将缓存数据取出执行反序列化还需要将要缓存的实现接口因为二级缓存数据存储介质多种多样不一定只存在内存中也可能存在硬盘中框架主要是围绕进行的具体的步骤定义一个对象其中包含数据源事务文件资源以及影响数据库行为属性设置通过配置对象则可以创建一个对象通过获得实例通过实例创建实例通过对数据库进行操作代码实例读取文件初始化创建类的实例创建实例接下来在这里做很多事情到目前为止目的已经达到得到了对象通过调用里面的方法可以测试和层接口方法之间的正确性当然也可以做别的很多事情在这里就不列举了插入数据第一个参数为方法的完全限定名位置信息映射文件当中的提交事务关闭如何防止注入注意但凡是注入漏洞的程序都是因为程序要接受来自客户端用户输入的变量或传递的参数并且这个变量或参数是组成语句的一部分对于用户输入的内容或传递的参数我们应该要时刻保持警惕这是安全领域里的外部数据不可信任的原则纵观安全领域的各种攻击方式大多数都是因为开发者违反了这个原则而导致的所以自然能想到就是变量的检测过滤验证下手确保变量是开发者所预想的检查变量数据类型和格式数据类型检查执行前要进行数据类型检查如果是邮箱参数就必须是邮箱的格式如果是日期就必须是日期格式只要是有固定格式的变量在语句执行前应该严格按照固定格式去检查确保变量是我们预想的格式这样很大程度上可以避免注入攻击如果上述例子中是型的效果会怎样呢无法注入因为输入注入参数会失败比如上述中的字段我们应该在用户注册的时候就确定一个用户名规则比如个字符只能由大小写字母数字以及汉字组成不包含特殊字符此时我们应该有一个函数来完成统一的用户名检查不过仍然有很多场景并不能用到这个方法比如写博客评论系统弹幕系统必须允许用户可以提交任意形式的字符才行否则用户体验感太差了过滤特殊符号绑定变量使用预编译语句为什么要使用对进行了封装简化了的重复性代码对有一个封装类可以继承它实现简单的接口使用注解和配置文件可以对实体类和映射文件进行映射有事务管理机制保证了数据的安全性有一级缓存和二级缓存中如何在控制台查看打印的语句有几种查询方式导航对象图查询根据已加载的对象导航到其他对象例如对于已经加载的对象调用它的方法就可以导航到所有关联的对象假如在关联级别使用了延迟加载检索策略那么首次执行此方法时会从数据库中加载关联的对象否则就从缓存中获得对象方式按照对象的来检索对象的和方法提供了这种功能如果在应用程序中先知道了就可以使用这种方式检索对象和的用法完全一样都需要两个参数一个是持久化对象类名一个是行号返回固定的某一行的数据但是需要注意的是当输入的不存在时会返回一个空对象则直接报错检索方式使用面向对象的查询语言的方法用于执行查询语句此外还提供了接口它是提供的专门的查询接口能够执行各种复杂的查询语句它具备以下功能在查询语句中设定各种查询条件支持投影查询即仅检索出对象的部分属性支持分页查询支持连接查询支持分组查询提供内置函数能够调用用户自定义的函数支持子查询支持动态绑定参数例如获得一个对象注意参数字符串中不是一个语句后面的是持久化对象名称就可以获取数据库中对应表的数据集合检索方式的来检索对象这种封装了基于字符串形式的查询语句提供了更加面向对象的接口例创建一个对象参数是所关联的持久化对象将查询条件加入对象中后面的操作就和对象一样了本地使用本地数据库的查询语句会负责把检索到的结果映射为持久化对象图实体类可以被定义为吗可以将的实体类定义为但这种做法不好因为会使用代理模式在延迟关联的情况下提高性能如果你把实体类定义成类之后因为不允许对类进行扩展所以就无法再使用代理了如此一来就限制了使用可以提升性能的手段不过如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有的方法的话就能避免出现前面所说的不利后果在中使用和做映射有什么区别是面向对象的所以一般定义成封装类型要看数据库中的定义如果数据库中有对应字段存在值就要定义也可以定义基本类型在配置文件中写清楚即可什么是有哪些优点简介基于设计不仅继承了框架原有的优秀特性而且还通过简化配置来进一步简化应用的整个搭建和开发过程另外通过集成大量的框架使得依赖包的版本冲突引用的不稳定性得到了解决有哪些优点快速构建项目可以选一些必要的组件对主流框架的无配置集成内嵌容器项目可独立运行删除了繁琐的配置文件极大地提高了开发和部署效率提供简化配置有哪些缺点版本迭代速度快一些模块改动很大由于无须配置报错时很难定位中的监视器是什么监听器也叫是的监听器可以用于监听应用程序中某些对象的创建销毁增加修改删除等动作的发生然后做出相应的响应处理当范围对象的状态发生变化时服务器自动调用监听器对象中的方法常用于系统加载时进行信息初始化统计在线人数和在线用户统计网站的访问量配置监听器的方法通过把监听器加入容器中管理在中添加配置在方法上加注解什么是是的一个超集可以非常方便地将外部配置以层次结构形式存储起来可以作为配置文件的替代使用的注意事项在文件中是以进行分割的在中是用进行分割的的数据格式和的格式很像都是格式并且通过进行赋值每个冒号后面一定要加一个空格如何使用实现分页和排序使用可以实现将可分页的传递给存储库方法如何使用实现异常处理使用注解处理局部异常只能处理当前中的和异常缺点就是只能处理单个的异常没有抛出异常使用注解处理全局异常后面可以填写数组配置类处理异常配置类第一个参数为异常全限定名第二个为跳转视图名称设置异常与视图映射信息的实现接口处理异常实现接口判断不同异常类型做不同视图跳转单点登录概念单点登录说的是在一个多系统共存的环境下用户在一处登录后就不用在其他系统中登录也就是用户的一次登录能得到其他所有系统的信任单点登录的要点存储信任验证信任实现单点登录的三种方式以作为凭证最简单的单点登录实现方式是使用作为媒介存放用户凭证用户登录父应用之后应用返回一个加密的当用户访问子应用的时候携带上这个授权应用解密进行校验校验通过则登录当前用户缺点不安全通过加密可以保证安全性但如果对方掌握了解密算法就完蛋了不能跨域实现免登通过实现对于跨域问题可以使用实现用户在父应用中登录后跟匹配的会存到客户端中当用户需要登录子应用的时候授权应用访问父应用提供的接口并在请求中带上父应用域名下的父应用接收到请求验证用户的登录状态返回加密的信息子应用通过解析返回来的加密信息来验证用户如果通过验证则登录用户缺点这种方法虽然能解决跨域问题但是治标不治本没有解决安全性的问题通过页面重定向的方式最后一种介绍的方式是通过父应用和子应用来回重定向进行通信实现信息的安全传递父应用提供一个方式的登录接口此时的父应用接口固定攻击者无法去伪造用户通过子应用重定向连接的方式访问这个接口如果用户还没有登录则返回一个登录页面用户输入账号密码进行登录如果用户已经登录了则生成加密的并且重定向到子应用提供的验证的接口此时的子应用接口固定攻击者无法去伪造通过解密和校验之后子应用登录当前用户缺点这种方式较前面的两种方式是解决了安全性和跨域的问题但是并没有前面两种方式简单安全与方便本来就是矛盾的使用独立登录系统一般来说大型应用会把授权的逻辑和用户信息的相关逻辑独立成一个应用称为用户中心用户中心不处理业务逻辑只是处理用户信息的管理以及授权给第三方应用第三方应用需要登录的时候则把用户的登录请求转发给用户中心进行处理用户处理完毕后返回凭证第三方应用验证凭证通过后就登录用户单点登录与授权的区别单点登录通常处理的是一个公司的不同应用间的访问登录问题如企业应用有很多子系统只需登录一个系统就可以实现不同子系统间的跳转而避免了登录操作通过重定向来实现授权解决的是服务提供方如微信给第三方应用授权的问题简称微信登录是一种具体的协议只是为用户资源的授权提供了一个安全的开放的而又简易的标准授权为客户开发者开发应用桌面应用程序移动应用及客厅设备提供特定的授权流程比多哪些注解常用注解绝对经典打包和部署和都支持和通用打包管理技术相对的一些优点提供嵌入式容器支持使用命令独立运行部署时可以灵活指定配置文件最近项目是分布式的项目都是通过分项目打包部署然后部署在中运行如何访问不同的数据库可以使用创建然后通过执行查询网站在线人数通过监听对象的方式来实现在线人数的统计和在线人信息展示并且让超时的自动销毁对对象实现监听首先必须继承类该程序的基本原理就是当浏览器访问页面的时候必定会产生一个对象当关闭该页面的时候必然会删除对象所以每当产生一个新的对象就让在线人数当删除一个对象就让在线人数还要继承一个来实现对其属性的监听分别实现方法方法以及方法新建一个会话的时候触发也可以说是客户端第一次喝服务器交互时触发销毁会话的时候一般来说只有某个按钮触发进行销毁或者配置定时销毁有三个方法需要实现在中添加对象时触发此操作笼统的说就是调用这个方法时候会触发的修改删除中添加对象时触发此操作笼统的说就是调用这个方法时候会触发的在属性被重新设置时如何实现异步读取新建一个监听类出来并且继承类监听器每隔条存储数据库实际使用中可以条然后清理方便内存回收解析到一条数据所有数据解析完成加上存储数据库条数据开始存储数据库存储数据库成功什么是你用实现了它吗是用于生成服务的可视化表示工具它使文档和服务器可视化更新当定义好后可以调用服务端接口来查看接口的返回值验证返回数据的正确性数据库的三范式是什么列不可再分每一行数据只做一件事只与一列相关主键每个属性都与主键有直接关系而不是间接关系三大范式只是设计数据库的基本理念可以建立冗余较小结构合理的数据库如果有特殊情结当然要特殊对待数据库设计最重要的是看需求和性能需求性能表结构所以不能一味的追求三范式建立数据库一张自增表里面总共有条数据删除了最后条数据重启数据库又插入了一条数据此时是几一般情况下我们创建的表类型是不重启如果新增一条记录是重启是因为表只把自增主键的最大记录在内存中如果重启已删除的最大会丢失如果表类型是重启之后最大也不会丢失是必须有主键建议使用自增主键不用自增主键索引查询效率高支持外键支持事务支持行级锁系统崩溃后很难恢复综合考虑优先选择默认也是如何获取当前数据库版本说一下是什么是数据库事务执行的四大基本要素包括原子性一致性隔离性持久性原子性整个事务中的所有操作要么全部完成要不全部不完成不可能停滞在中间某个环节事务在执行过程中发生错误会被回滚到事务开始前的状态就像这个事务从未执行过一样一致性事务必须始终保持系统处于一致的状态不管在任何给定的时间并发事务有多少隔离性隔离状态执行事务使他们好像是系统在给定时间内执行的唯一操作如果有两个事务运行在相同的时间内执行相同的功能事务的隔离性确保每一个事务在系统中认为只有自己在使用系统这种属性称为串行化为了防止事务操作间的混淆必须串行化或序列化请求使得在同一时间仅有一个请求用于同一数据持久性一个成功的事务将永久的改变系统的状态和的区别是什么的长度是固定的的长度的可变的的效率比的效率高占用空间比大在查询时需要使用和的区别是什么和的区别是什么内存中占有的字节数不同单精度浮点数在内存中占有个字节双精度浮点数在内存中占有个字节有效数字位数不同单精度浮点数有效数字位双精度浮点数有效数字位数值取值范围不同单精度浮点数的表示范围双精度浮点数的表示范围在程序中处理速度不同一般来说处理单精度浮点数的速度比双精度浮点数的速度快如果不声明默认小数是类型如果想用要进行强转例如会编译报错正确的写法是或者或都可以不区分大小写注意是八位有效数字第七位会四舍五入面试题中将会返回什么还是答返回因为浮点数不能完全精确的表示出来一般会损失精度中是否正确答不正确因为是双精度浮点数将双精度赋给单精度属于向下转型会造成精度损失因此需要强制类型转换或者写成分页不带排序的带排序的数据库如何保证主键唯一性主键约束主键列上没有任何两行具有相同值即重复值不允许空唯一性约束保证一个字段或者一组字段里的数据都与表中其它行的对应数据不同和主键约束不同唯一性约束允许为但是只能有一行唯一性索引不允许具有索引值相同的行从而禁止重复的索引和键值三者的区别约束是用来检查数据的正确性索引是用来优化查询的创建唯一性约束会创建一个约束和一个唯一性索引创建唯一性索引只会创建一个唯一性索引主键约束和唯一性约束都会创建一个唯一性索引如何设计数据库数据库设计最起码要占用这个项目开发的以上的时间数据库设计不仅仅停留在页面的表面页面内容所需字段在数据库设计中只是一部分还有系统运转模块交互中转数据表之间的联系等等所需要的字段因此数据库设计绝对不是简单的基本数据存储还有逻辑数据存储数据库设计完成后项目的设计开发都要存在你的脑海中每个字段的设计都要有他存在的意义要清楚的知道程序中如何去运用这些字段多张表的联系在程序中是如何体现的数据库设计时就要考虑效率和优化问题数据量大的表示粗粒度的会冗余一些必要字段达到用最少的表最弱的表关系去存储海量的数据大数据的表要建立索引方便查询对于含有计算数据交互统计这类需求时还有考虑是否有必要采用存储过程添加必要的冗余字段像创建时间修改时间操作用户备注这些字段在每张表中最好都有一些冗余的字段便于日后维护分析拓展而添加设计合理的表关联若两张表之间的关系复杂建议采用第三张映射表来关联维护两张表之间的关系以降低表之间的直接耦合度设计表时不加主外键等约束关联系统编码阶段完成后再添加约束性关联选择合适的主键生成策略数据库的设计难度其实比单纯的技术实现难很多他充分体现了一个人的全局设计能力和掌控能力最后说一句数据库设计很重要很复杂性别是否适合做索引区分度不高的字段不适合做索引因为索引页是需要有开销的需要存储的不过这类字段可以做联合索引的一部分如何查询重复的数据查询重复的单个字段重复字段表重复字段查询重复的多个字段重复字段重复字段表重复字段重复字段数据库一般会采取什么样的优化方法选取适合的字段属性为了获取更好的性能可以将表中的字段宽度设得尽可能小尽量把字段设置成执行查询的时候数据库不用去比较值对某些省份或者性别字段将他们定义为类型类型被当做数值型数据来处理而数值型数据被处理起来的速度要比文本类型块很多使用连接代替子查询使用联合来代替手动创建的临时表注意用法中两个语句的字段类型要匹配而且字段个数要相同事务要么都成功要么都失败可以保证数据库中数据的一致性和完整性事务以开始关键字结束如果出错命令可以将数据库恢复到开始之前的状态事务的另一个重要作用是当多个用户同时使用相同的数据源时它可以利用锁定数据库的方式为用户提供一种安全的访问方式这样就可以保证用户的操作不被其他的用户干扰锁定表尽管事务是维护数据库完整性的一个非常好的方法但却因为它的独占性有时会影响数据库的性能尤其是在大应用中由于在事务执行的过程中数据库会被锁定因此其它用户只能暂时等待直到事务结束有的时候可以用锁定表的方法来获得更好的性能共享锁其它用户只能看不能修改对于通过命令主动添加的锁来说如果要释放它们只需发出命令即可使用外键锁定表的方法可以维护数据的完整性但是它却不能保证数据的关联性这个时候可以使用外键使用索引索引是提高数据库查询速度的常用方法尤其是查询语句中包含这些命令的时候性能提高更为显著一般来说索引应该建在常用于的字段上尽量不要对数据库中含有大量重复的值得字段建立索引优化的查询语句在索引的字段上尽量不要使用函数进行操作尽量不要使用关键字和通配符这样做法很简单但却是以牺牲性能为代价的避免在查询中进行自动类型转换因为类型转换也会使索引失效索引怎么定义分哪几种索引如果不建立索引的情况下就自动给每一列都加一个树索引普通索引唯一索引位图索引位图索引特定于只有几个枚举值的情况比如性别字段基于函数的索引的内连接左连接右连接有什么区别内连接显示两个表中有联系的所有数据左链接以左表为参照显示所有数据右表中没有则以显示右链接以右表为参照显示数据左表中没有则以显示的使用场景有哪些解决异步问题例如用户注册发送邮件和短信反馈注册成功可以使用消息队列用户无需等待反馈服务间解耦订单系统和库存系统中间加入消息队列当库存系统出现问题时订单系统依旧能正常使用降低服务间耦合度秒杀系统利用的最大值实现秒杀系统有哪些重要的角色有哪些重要的组件有哪些重要的角色客户端服务端有哪些重要的组件连接管理器应用程序与之间建立连接的管理器信道消息推送使用的信道路由键用于把生产者的数据分配到交换机上交换机用于接受和分配消息绑定键用于把交换机的消息绑定到队列上队列用于存储生产者消息中的作用是什么可以理解为版的其内部均含有独立的交换机绑定队列最重要的是拥有独立的权限系统可以做到范围内的用户控制从全局考虑不同的应用可以跑在不同的上作为不同权限隔离的手段说一下的主要组成部分及其作用包括类加载子系统堆方法区栈本地方法栈程序计数器直接内存垃圾回收器执行引擎类加载子系统类加载子系统负责加载信息加载的类信息存放于方法区中直接内存直接内存是在堆外的直接向系统申请的内存空间访问直接内存的速度会由于堆出于性能的考虑读写频繁的场合可能会考虑使用直接内存垃圾回收器垃圾回收器可以对堆方法区直接内存进行回收执行引擎执行引擎负责执行虚拟机的字节码虚拟机会使用即时编译技术将方法编译成机器码后再执行说一下运行时数据区运行时数据区包括堆方法区栈本地方法栈程序计数器堆堆解决的是对象实例存储的问题垃圾回收器管理的主要区域方法区方法区可以认为是堆的一部分用于存储已被虚拟机加载的信息常量静态变量即时编译器编译后的代码栈栈解决的是程序运行的问题栈里面存的是栈帧栈帧里面存的是局部变量表操作数栈动态链接方法出口等信息栈帧每个方法从调用到执行的过程就是一个栈帧在虚拟机栈中入栈到出栈的过程局部变量表用于保存函数的参数和局部变量操作数栈操作数栈又称操作栈大多数指令都是从这里弹出数据执行运算然后把结果压回操作数栈本地方法栈与栈功能相同本地方法栈执行的是本地方法一个调用非代码的接口程序计数器寄存器程序计数器中存放的是当前线程所执行的字节码的行数工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令什么是类加载器类加载器有哪些什么是类加载器类加载器负责加载所有的类其为所有被载入内存的类生成一个实例对象类加载器有哪些有三种类加载器启动类加载器该类没有父加载器用来加载的核心类启动类加载器的实现依赖于底层操作系统属于虚拟机实现的一部分它并不继承自扩展类加载器它的父类为启动类加载器扩展类加载器是纯类是类的子类负责加载的扩展目录应用程序类加载器它的父类为扩展类加载器它从环境变量或者系统属性所指定的目录中加载类它是自定义的类加载器的父加载器说一下类加载的执行过程当程序主动使用某个类时如果该类还未被加载到内存中会通过加载连接初始化个步骤对该类进行类加载加载加载指的是将类的文件读入到内存中并为之创建一个对象类的加载由类加载器完成类加载器由提供开发者也可以通过继承基类来创建自己的类加载器通过使用不同的类加载器可以从不同来源加载类的二进制数据通常有如下几种来源从本地文件系统加载从包加载通过网络加载把一个源文件动态编译并执行加载连接当类被加载之后系统为之生成一个对应的对象接着进入连接阶段连接阶段负责将类的二进制数据合并到中类连接又可分为三个阶段验证文件格式验证元数据验证字节码验证符号引用验证准备为类的静态变量分配内存并设置默认初始值解析将类的二进制数据中的符号引用替换成直接引用初始化为类的静态变量赋予初始值的类加载机制是什么类加载机制主要有三种全盘负责类加载器加载某个时该所依赖的和引用其它的也由该类加载器载入双亲委派先让父加载器加载该父加载器无法加载时才考虑自己加载缓存机制缓存机制保证所有加载过的都会被缓存当程序中需要某个时先从缓存区中搜索如果不存在才会读取该类对应的二进制数据并将其转换成对象存入缓存区中这就是为什么修改了后必须重启程序所做的修改才会生效的原因什么是双亲委派模型如果一个类收到了类加载请求它并不会自己先去加载而是把这个请求委托给父类的加载器执行如果父加载器还存在其父加载器则进一步向上委托依次递归请求将最终到达顶层的启动类加载器如果父类加载器可以完成父加载任务就成功返回如果父加载器无法完成加载任务子加载器才会尝试自己去加载这就是双亲委派模型双亲委派模式的优势避免重复加载考虑到安全因素核心中定义类型不会被随意替换假设通过网络传递一个名为的类通过双亲委派模式传递到启动加载器而启动加载器在核心中发现同名的类发现该类已经被加载就不会重新加载网络传递的类而直接返回已加载过的这样可以防止核心库被随意篡改怎么判断对象是否可以被回收引用计数算法判断对象的引用数量通过判断对象的引用数量来决定对象是否可以被回收每个对象实例都有一个引用计数器被引用完成引用任何引用计数为的对象实例可以被当做垃圾回收优缺点优点执行效率高程序受影响较小缺点无法检测出循环引用的情况导致内存泄漏可达性分析算法通过判断对象的引用链是否可达来决定对象是否可以被回收如果程序无法再引用该对象那么这个对象肯定可以被回收这个状态称为不可达那么不可达状态如何判断呢答案是也就是根对象如果一个对象无法到达根对象的路径或者说从根对象无法引用到该对象该对象就是不可达的以下三种对象在中被称为来判断一个对象是否可以被回收虚拟机栈的栈帧每个方法在执行的时候都会创建一个相应的栈帧操作数栈局部变量表运行时常量池的引用当方法执行完该栈帧就从栈中弹出这样一来方法中临时创建的独享就不存在了或者说没有任何指向这些临时对象这些对象在下一次的时候便会被回收方法区中的静态属性静态属性数据类属性不属于任何实例因此该属性自然会作为这要这个在该引用指向的对象就一直存在也由被回收的时候何时会被回收堆中不存在该类的任何实例加载该类的已经被回收该类的对象没有在任何地方被引用也就是说无法通过反射访问该类的信息本地方法栈引用的对象说一下有哪些垃圾回收算法对象是否已死算法引用计数器算法可达性分析算法算法标记清除算法如果对象被标记后进行清除会带来一个新的问题内存碎片化如果下次有比较大的对象实例需要在堆上分配较大的内存空间时可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收复制算法堆中新生代的垃圾回收算法先标记待回收内存和不用回收内存将不用回收的内存复制到新的内存区域就的内存区域就可以被全部回收了而新的内存区域也是连续的缺点是损失部分系统内存因为腾出部分内存进行复制标记压缩算法堆中老年代的垃圾回收算法对于新生代大部分对象都不会存活所以复制算法较高效但对于老年代大部分对象可能要继续存活如果此时使用复制算法效率会降低标记压缩算法首先还是标记将不用回收的内存对象压缩到内存一端此时即可清除边界处的内存这样就能避免复制算法带来的效率问题同时也能避免内存碎片化的问题老年代的垃圾回收算法称为说一下有哪些垃圾回收器说一下有哪些垃圾回收器栈堆概念何时销毁对象类在程序运行的时候就会被加载方法是在执行的时候才会被加载如果没有任何引用了自动垃圾回收也可以用开启回收器但是回收器不一定会马上回收静态变量在类装载的时候进行创建在整个程序结束时按序销毁实例变量在类实例化对象时创建在对象销毁的时候销毁局部变量在局部范围内使用时创建跳出局部范围时销毁新生代垃圾回收器和老生代垃圾回收器都有哪些有什么区别新生代回收器老年代回收器新生代回收器一般采用的是复制算法复制算法效率较高但是浪费内存老生代回收器一般采用标记清楚算法比如最常用的详细介绍一下垃圾回收器垃圾回收器是是一种同步的标记清除分为四个阶段初始标记标记一下能直接关联到的对象会触发并发标记通过判断对象是否在使用中重新标记标记期间产生对象的再次判断执行时间较短会触发并发清除清除对象可以和用户线程并发进行简述分代垃圾回收器是怎么工作的分代回收器分为新生代和老年代新生代大概占老年代大概占新生代包括区和两个区的的空间比例为垃圾回收器的执行流程把存活的对象放入区清空分区和分区交换每次交换后存活的对象年龄到达升级为老年代大对象会直接进入老年代老年代中当空间到达一定占比会触发全局回收老年代一般采取标记清除算法是什么是一个存储系统它支持存储的类型相对更多包括有序集合和这些数据结构都支持及取交集并集和差集及更丰富的操作而且这些操作都是原子性的在此基础上支持各种不同方式的排序为了保证效率数据都是缓存在内存中会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件并且在此基础上实现了主从同步都有哪些使用场景是基于内存的数据库可以通过新建线程的形式进行持久化不影响单线程的读写操作通过取最新的条数据模拟类似于这种需要设置过期时间的场景发布订阅消息系统定时器计数器有哪些功能基于本机内存的缓存当调用访问数据库时假如此过程需要秒如果每次请求都要访问数据库那将对服务器造成巨大的压力如果将此的查询结果存到中再次请求时直接从中取得而不是访问数据库效率将得到巨大的提升可以定时去更新数据比如分钟如果电脑重启写入内存的数据是不是就失效了呢这时还提供了持久化的功能哨兵和复制可以管理多个服务器它提供了监控提醒以及自动的故障转移功能复制则是让服务器可以配备备份的服务器也是通过这两个功能保证的高可用集群单台服务器资源总是有上限的和资源可以通过主从复制进行读写分离把一部分和的压力转移到从服务器上但是内存资源怎么办主从模式只是数据的备份并不能扩充内存现在我们可以横向扩展让每台服务器只负责一部分任务然后将这些服务器构成一个整体对外界来说这一组服务器就像是集群一样支持的数据类型有哪些字符串取值存值问题先把的连接池拿出来存取值给一个叠加此时的值就是同时给多个进行赋值对进行操作存入取出中删除其中一个键值是否存在一个键取出所有的中的值为什么是单线程的代码更清晰处理逻辑更简单不用考虑各种锁的问题不存在加锁和释放锁的操作没有因为可能出现死锁而导致的性能问题不存在多线程切换而消耗无法发挥多核的优势但可以采用多开几个实例来完善真的是单线程的吗之前是单线程的之后开始支持多线程内部使用了基于的多路服用也可以多部署几个服务器解决单线程的问题主要的性能瓶颈是内存和网络内存好说加内存条就行了而网络才是大麻烦所以内存好说加内存条就行了而网络才是大麻烦所以引入了多线程的概念在网络处理方面引入了多线程如网络数据的读写和协议解析等需要注意的是执行命令的核心模块还是单线程的持久化有几种方式提供了两种持久化的方式分别是和简而言之就是在不同的时间点将存储的数据生成快照并存储到磁盘等介质上则是换了一个角度来实现持久化那就是将执行过的所有写指令记录下来在下次重新启动时只要把这些写指令从前到后再重复执行一遍就可以实现数据恢复了其实和两种方式也可以同时使用在这种情况下如果重启的话则会优先采用方式来进行数据恢复这是因为方式的数据恢复完整度更高如果你没有数据持久化的需求也完全可以关闭和方式这样的话将变成一个纯内存数据库就像一样和有什么区别相比拥有更多的数据结构和支持更丰富的数据操作支持常用的数据类型主要有只支持内存使用率对比采用结构来做存储由于其组合式的压缩其内存利用率会高于性能对比只使用单核使用多核支持磁盘持久化不支持可以将一些很久没用到的通过方法交换到磁盘支持分布式集群不支持支持的客户端都有哪些等等官方推荐使用和有哪些区别和都是中对操作的封装只是简单的封装了的库可以看作是客户端它的方法和的命令很类似不仅封装了还封装了对更多数据结构的支持以及锁等功能相比于更加大但相比于更原生一些更灵活什么是缓存穿透怎么解决缓存穿透一般的缓存系统都是按照去缓存查询如果不存在对用的就应该去后端系统查找比如数据库一些恶意的请求会故意查询不存在的请求量很大就会对后端系统造成很大的压力这就叫做缓存穿透怎么解决对查询结果为空的情况也进行缓存缓存时间设置短一点或者该对应的数据之后清理缓存对一定不存在的进行过滤可以把所有的可能存在的放到一个大的中查询时通过该过滤缓存雪崩当缓存服务器重启或者大量缓存集中在某一时间段失效这样在失效的时候会给后端系统带来很大的压力导致系统崩溃如何解决在缓存失效后通过加锁或者队列来控制读数据库写缓存的线程数量比如对某个只允许一个线程查询数据和写缓存其它线程等待做二级缓存不同的设置不同的过期时间让缓存失效的时间尽量均匀怎么保证缓存和数据库数据的一致性淘汰缓存数据如果为较为复杂的数据时进行缓存的更新操作就会变得异常复杂因此一般推荐选择淘汰缓存而不是更新缓存选择先淘汰缓存再更新数据库假如先更新数据库再淘汰缓存如果淘汰缓存失败那么后面的请求都会得到脏数据直至缓存过期假如先淘汰缓存再更新数据库如果更新数据库失败只会产生一次缓存穿透相比较而言后者对业务则没有本质上的影响延时双删策略如下场景同时有一个请求进行更新操作另一个请求进行查询操作请求进行写操作删除缓存请求查询发现缓存不存在请求去数据库查询得到旧值请求将旧值写入缓存请求将新值写入数据库次数便出现了数据不一致问题采用延时双删策略得以解决这么做可以将秒内所造成的缓存脏数据再次删除这个时间设定可根据俄业务场景进行一个调节数据库读写分离的场景两个请求一个请求进行更新操作另一个请求进行查询操作请求进行写操作删除缓存请求将数据写入数据库了请求查询缓存发现缓存没有值请求去从库查询这时还没有完成主从同步因此查询到的是旧值请求将旧值写入缓存数据库完成主从同步从库变为新值依旧采用延时双删策略解决此问题什么是缓存穿透怎么解决缓存穿透一般的缓存系统都是按照去缓存查询如果不存在对用的就应该去后端系统查找比如数据库一些恶意的请求会故意查询不存在的请求量很大就会对后端系统造成很大的压力这就叫做缓存穿透怎么解决对查询结果为空的情况也进行缓存缓存时间设置短一点或者该对应的数据之后清理缓存对一定不存在的进行过滤可以把所有的可能存在的放到一个大的中查询时通过该过滤缓存雪崩当缓存服务器重启或者大量缓存集中在某一时间段失效这样在失效的时候会给后端系统带来很大的压力导致系统崩溃如何解决在缓存失效后通过加锁或者队列来控制读数据库写缓存的线程数量比如对某个只允许一个线程查询数据和写缓存其它线程等待做二级缓存不同的设置不同的过期时间让缓存失效的时间尽量均匀怎么实现分布式锁使用实现分布式锁命令原子性命令使用解决锁释放的问题备注可以通过脚本保证分布式锁的原子性分布式锁有什么缺陷分布式锁不能解决超时的问题分布式锁有一个超时时间程序的执行如果超出了锁的超时时间就会出现问题容易产生的几个问题锁未被释放锁被锁释放了数据库事务超时锁过期了业务还没执行完主从复制的问题如何做内存优化缩短键值的长度缩短值的长度才是关键如果值是一个大的业务对象可以将对象序列化成二进制数组首先应该在业务上进行精简去掉不必要的属性避免存储一些没用的数据其次是序列化的工具选择上应该选择更高效的序列化工具来降低字节数组大小以为例内置的序列化方式无论从速度还是压缩比都不尽如人意这时可以选择更高效的序列化工具如等共享对象池对象共享池指内部维护的整数对象池创建大量的整数类型存在内存开销每个内部结构至少占字节甚至超过了整数自身空间消耗所以内存维护一个的整数对象池用于节约内存除了整数值对象其他类型如内部元素也可以使用整数对象池因此开发中在满足需求的前提下尽量使用整数对象以节省内存字符串优化编码优化控制的数量作者简介哪吒博客之星亚军新星计划导师博客专家哪吒多年工作总结学习路线总结搬砖工逆袭架构师技术交流定期更新硬核干货不定期送书活动关注公众号哪吒编程回复面试题获取万字道经典面试题总结附答案背题更方便一文在手面试我有',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-08 13:52:25',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="msvalidate.01" content="9425B9ADD6D9B15FB7E7E42C9DF4F63A" /><meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Mybbs" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://www.kuaidaili.com/img/loading.gif"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Mybbs</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 本站</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 首页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/HTML/4238948.html"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 帮助</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&amp;k=AVD1Y5VnrY8z603_1dFsQrHfY1Uodp1O&amp;authKey=bX2RSjVq%2BYvjD2fsZ3PpEz4r2UAeV0e4lMLr4gTi7agxGPNsEfOP2M%2F%2Bw7i1mryp&amp;noverify=0&amp;group_code=565126072"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 交流群</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 帖子</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 帖子</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 板块</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/HTML/index1.html"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 发帖子</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 更多</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/HTML/tc.html"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 图床</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.pixelbbs.cn/source/plugin/bphp_clouds/upload/4438/20240601/417cb596663d3d5bf57708af2fa16eba.zip"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 源码</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/HTML/30588.html"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/HTML/index2.html"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 服务器</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/HTML/gl.html"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 个人中心</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 小游戏</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/HTML/tcs.html"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 2048</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/HTML/tcc.html"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 贪吃蛇</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CSDN/" style="font-size: 1.05rem;">CSDN<sup>1</sup></a><a href="/tags/MC/" style="font-size: 1.05rem;">MC<sup>14</sup></a><a href="/tags/Mod/" style="font-size: 1.05rem;">Mod<sup>1</sup></a><a href="/tags/blog/" style="font-size: 1.05rem;">blog<sup>1</sup></a><a href="/tags/github/" style="font-size: 1.05rem;">github<sup>29</sup></a><a href="/tags/hexo/" style="font-size: 1.05rem;">hexo<sup>4</sup></a><a href="/tags/hexo%E4%B8%BB%E9%A2%98/" style="font-size: 1.05rem;">hexo主题<sup>9</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>1</sup></a><a href="/tags/paper/" style="font-size: 1.05rem;">paper<sup>1</sup></a><a href="/tags/%E4%BC%91%E9%97%B2/" style="font-size: 1.05rem;">休闲<sup>1</sup></a><a href="/tags/%E5%88%86%E4%BA%AB/" style="font-size: 1.05rem;">分享<sup>5</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">工具<sup>4</sup></a><a href="/tags/%E6%89%98%E7%AE%A1/" style="font-size: 1.05rem;">托管<sup>1</sup></a><a href="/tags/%E6%8E%A8%E8%8D%90/" style="font-size: 1.05rem;">推荐<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 1.05rem;">插件<sup>2</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">教程<sup>16</sup></a><a href="/tags/%E6%95%B4%E5%90%88%E5%8C%85/" style="font-size: 1.05rem;">整合包<sup>3</sup></a><a href="/tags/%E6%96%B0%E9%97%BB/" style="font-size: 1.05rem;">新闻<sup>2</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem;">服务器<sup>2</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/" style="font-size: 1.05rem;">服务端<sup>1</sup></a><a href="/tags/%E7%B2%BE%E5%93%81/" style="font-size: 1.05rem;">精品<sup>3</sup></a><a href="/tags/%E8%A7%86%E9%A2%91/" style="font-size: 1.05rem;">视频<sup>1</sup></a><a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 1.05rem;">转载<sup>9</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2026/05/"><span class="card-archive-list-date">五月 2026</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">26</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/github/" itemprop="url">github</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>教程</span></a><a class="article-meta__tags" href="/tags/github/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>github</span></a><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a></span></div></div><h1 class="post-title" itemprop="name headline">10万字208道Java经典面试题总结(附答案)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-05-31T10:24:06.186Z" title="发表于 2024-05-31 18:24:06">2024-05-31</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-06-08T05:52:25.285Z" title="更新于 2024-06-08 13:52:25">2024-06-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://bianb-hehe.github.io/2024/05/31/119299329/"><header><a class="post-meta-categories" href="/categories/github/" itemprop="url">github</a><a href="/tags/%E6%95%99%E7%A8%8B/" tabindex="-1" itemprop="url">教程</a><a href="/tags/github/" tabindex="-1" itemprop="url">github</a><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><h1 id="CrawlerTitle" itemprop="name headline">10万字208道Java经典面试题总结(附答案)</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Mybbs —— 开源MC社区</span><time itemprop="dateCreated datePublished" datetime="2024-05-31T10:24:06.186Z" title="发表于 2024-05-31 18:24:06">2024-05-31</time><time itemprop="dateCreated datePublished" datetime="2024-06-08T05:52:25.285Z" title="更新于 2024-06-08 13:52:25">2024-06-08</time></header><blockquote>
<p>🍅 作者简介：哪吒，CSDN2021博客之星亚军🏆、新星计划导师✌、博客专家💪<br>🍅 哪吒多年工作总结：<a target="_blank" rel="noopener" href="https://blog.csdn.net/guorui_java/article/details/120098618" title="Java学习路线总结，搬砖工逆袭Java架构师">Java学习路线总结，搬砖工逆袭Java架构师</a><br>🍅 技术交流：<a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/607729516" title="定期更新Java硬核干货，不定期送书活动">定期更新Java硬核干货，不定期送书活动</a><br>🍅 <strong>关注公众号【哪吒编程】，回复 面试题</strong>，获取《10万字208道Java经典面试题总结(附答案)》 <strong>pdf</strong>，背题更方便，一文在手，面试我有</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近有很多粉丝问我，有什么方法能够快速提升自己，通过阿里、腾讯、字节跳动、京东等互联网大厂的面试，我觉得短时间提升自己最快的手段就是背面试题，最近总结了Java常用的面试题，分享给大家，希望大家都能圆梦大厂，加油，我命由我不由天。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801221107554.png"></p>
<p><strong>目录</strong></p>
<p><a href="#1%E3%80%81jdk%20%E5%92%8C%20jre%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">1、JDK 和 JRE 有什么区别？</a></p>
<p><a href="#2%E3%80%81==%20%E5%92%8C%20equals%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">2、== 和 equals 的区别是什么？</a></p>
<p><a href="#3%E3%80%81final%20%E5%9C%A8%20java%20%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F">3、final 在 java 中有什么作用？</a></p>
<p><a href="#4%E3%80%81java%20%E4%B8%AD%E7%9A%84%20mathround(-15)%20%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%EF%BC%9F">4、java 中的 Math.round(-1.5) 等于多少？</a></p>
<p><a href="#5%E3%80%81string%20%E5%B1%9E%E4%BA%8E%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F">5、String 属于基础的数据类型吗？</a></p>
<p><a href="#6%E3%80%81string%20str=%22i%22%E4%B8%8E%20string%20str=new%20string(%E2%80%9Ci%E2%80%9D)%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F">6、String str=”i”与 String str=new String(“i”)一样吗？</a></p>
<p><a href="#7%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F">7、如何将字符串反转？</a></p>
<p><a href="#8%E3%80%81string%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F">8、String 类的常用方法都有那些？</a></p>
<p><a href="#9%E3%80%81new%20string(%22a%22)%20+%20new%20string(%22b%22)%20%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F">9、new String(“a”) + new String(“b”) 会创建几个对象？</a></p>
<p><a href="#10%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F">10、如何将字符串反转？</a></p>
<p><a href="#11%E3%80%81string%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F">11、String 类的常用方法都有那些？</a></p>
<p><a href="#12%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F">12、普通类和抽象类有哪些区别？</a></p>
<p><a href="#13%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">13、接口和抽象类有什么区别？</a></p>
<p><a href="#14%E3%80%81java%20%E4%B8%AD%20io%20%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F">14、java 中 IO 流分为几种？</a></p>
<p><a href="#15%E3%80%81bio%E3%80%81nio%E3%80%81aio%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">15、BIO、NIO、AIO 有什么区别？</a></p>
<p><a href="#16%E3%80%81files%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">16、Files的常用方法都有哪些？</a></p>
<p><a href="#17%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F">17、什么是反射？</a></p>
<p><a href="#18%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20java%20%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F">18、什么是 java 序列化？什么情况下需要序列化？</a></p>
<p><a href="#19%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？</a></p>
<p><a href="#20%E3%80%81throw%20%E5%92%8C%20throws%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">20、throw 和 throws 的区别？</a></p>
<p><a href="#21%E3%80%81final%E3%80%81finally%E3%80%81finalize%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">21、final、finally、finalize 有什么区别？</a></p>
<p><a href="#22%E3%80%81try-catch-finally%20%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%20catch%20%E4%B8%AD%20return%20%E4%BA%86%EF%BC%8Cfinally%20%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F">22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</a></p>
<p><a href="#23%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">23、常见的异常类有哪些？</a></p>
<p><a href="#24%E3%80%81hashcode%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F">24、hashcode是什么？有什么作用？</a></p>
<p><a href="#25%E3%80%81java%20%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">25、java 中操作字符串都有哪些类？它们之间有什么区别？</a></p>
<p><a href="#26%E3%80%81java%20%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F">26、java 中都有哪些引用类型？</a></p>
<p><a href="#27%E3%80%81%E5%9C%A8%20java%20%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BB%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F">27、在 Java 中，为什么不允许从静态方法中访问非静态变量？</a></p>
<p><a href="#28%E3%80%81%E8%AF%B4%E8%AF%B4java%20bean%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">28、说说Java Bean的命名规范</a></p>
<p><a href="#29%E3%80%81java%20bean%20%E5%B1%9E%E6%80%A7%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">29、Java Bean 属性命名规范问题分析</a></p>
<p><a href="#30%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20java%20%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B?">30、什么是 Java 的内存模型?</a></p>
<p><a href="#31%E3%80%81%E5%9C%A8%20java%20%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E5%86%99%EF%BC%9F">31、在 Java 中，什么时候用重载，什么时候用重写？</a></p>
<p><a href="#32%E3%80%81%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%9B%B4%E5%80%BE%E5%90%91%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F">32、举例说明什么情况下会更倾向于使用抽象类而不是接口？</a></p>
<p><a href="#33%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">33、实例化对象有哪几种方式</a></p>
<p><a href="#34%E3%80%81byte%E7%B1%BB%E5%9E%8B127+1%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91">34、byte类型127+1等于多少</a></p>
<p><a href="#35%E3%80%81java%20%E5%AE%B9%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">35、Java 容器都有哪些？</a></p>
<p><a href="#36%E3%80%81collection%20%E5%92%8C%20collections%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">36、Collection 和 Collections 有什么区别？</a></p>
<p><a href="#37%E3%80%81list%E4%B8%8Eset%E5%8C%BA%E5%88%AB">37、list与Set区别</a></p>
<p><a href="#main-toc">38、HashMap 和 Hashtable 有什么区别？</a></p>
<p><a href="#39%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20hashmap%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F">39、说一下 HashMap 的实现原理？</a></p>
<p><a href="#40%E3%80%81set%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9F">40、set有哪些实现类？</a></p>
<p><a href="#41%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20hashset%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F">41、说一下 HashSet 的实现原理？</a></p>
<p><a href="#42%E3%80%81arraylist%20%E5%92%8C%20linkedlist%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">42、ArrayList 和 LinkedList 的区别是什么？</a></p>
<p><a href="#43%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8C%20list%20%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F">43、如何实现数组和 List 之间的转换？</a></p>
<p><a href="#44%E3%80%81%E5%9C%A8%20queue%20%E4%B8%AD%20poll()%E5%92%8C%20remove()%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">44、在 Queue 中 poll()和 remove()有什么区别？</a></p>
<p><a href="#45%E3%80%81%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84">45、哪些集合类是线程安全的</a></p>
<p><a href="#46%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%20iterator%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">46、迭代器 Iterator 是什么？</a></p>
<p><a href="#47%E3%80%81iterator%20%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F">47、Iterator 怎么使用？有什么特点？</a></p>
<p><a href="#48%E3%80%81iterator%20%E5%92%8C%20listiterator%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">48、Iterator 和 ListIterator 有什么区别？</a></p>
<p><a href="#49%E3%80%81%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%EF%BC%9F">49、怎么确保一个集合不能被修改？</a></p>
<p><a href="#50%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">50、队列和栈是什么？有什么区别？</a></p>
<p><a href="#51%E3%80%81java8%E5%BC%80%E5%A7%8Bconcurrenthashmap,%E4%B8%BA%E4%BB%80%E4%B9%88%E8%88%8D%E5%BC%83%E5%88%86%E6%AE%B5%E9%94%81%EF%BC%9F">51、Java8开始ConcurrentHashMap,为什么舍弃分段锁？</a></p>
<p><a href="#52%E3%80%81concurrenthashmap(jdk18)%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8synchronized%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A6%82reentranlock%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F">52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？</a></p>
<p><a href="#53%E3%80%81concurrenthashmap%E5%92%8Chashtable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">53、concurrentHashMap和HashTable有什么区别</a></p>
<p><a href="#54%E3%80%81hasmmap%E5%92%8Chashset%E7%9A%84%E5%8C%BA%E5%88%AB">54、HasmMap和HashSet的区别</a></p>
<p><a href="#55%E3%80%81%E8%AF%B7%E8%B0%88%E8%B0%88%20readwritelock%20%E5%92%8C%20stampedlock">55、请谈谈 ReadWriteLock 和 StampedLock</a></p>
<p><a href="#56%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84run()%E5%92%8Cstart()%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">56、线程的run()和start()有什么区别？</a></p>
<p><a href="#57%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8%20start()%20%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C%20run()%20%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%20run()%20%E6%96%B9%E6%B3%95%EF%BC%9F">57、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</a></p>
<p><a href="#58%E3%80%81synchronized%20%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%8C%E5%85%B6%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">58、Synchronized 用过吗，其原理是什么？</a></p>
<p><a href="#59%E3%80%81jvm%20%E5%AF%B9%20java%20%E7%9A%84%E5%8E%9F%E7%94%9F%E9%94%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F">59、JVM 对 Java 的原生锁做了哪些优化？</a></p>
<p><a href="#60%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%20wait(),%20notify()%E5%92%8C%20notifyall()%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9F">60、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</a></p>
<p><a href="#61%E3%80%81java%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E5%92%8C%E5%8D%8F%E4%BD%9C%EF%BC%9F">61、Java 如何实现多线程之间的通讯和协作？</a></p>
<p><a href="#62%E3%80%81thread%20%E7%B1%BB%E4%B8%AD%E7%9A%84%20yield%20%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F">62、Thread 类中的 yield 方法有什么作用？</a></p>
<p><a href="#63%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%20synchronized%20%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F">63、为什么说 Synchronized 是非公平锁？</a></p>
<p><a href="#64%E3%80%81%E8%AF%B7%E8%B0%88%E8%B0%88%20volatile%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%AF%B9%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F">64、请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？</a></p>
<p><a href="#65%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%20synchronized%20%E6%98%AF%E4%B8%80%E4%B8%AA%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%20cas%EF%BC%8C%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F">65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</a></p>
<p><a href="#66%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%80%E5%AE%9A%E5%B0%B1%E6%98%AF%E5%A5%BD%E7%9A%84%E5%90%97%EF%BC%9F">66、乐观锁一定就是好的吗？</a></p>
<p><a href="#67%E3%80%81%E8%AF%B7%E5%B0%BD%E5%8F%AF%E8%83%BD%E8%AF%A6%E5%B0%BD%E5%9C%B0%E5%AF%B9%E6%AF%94%E4%B8%8B%20synchronized%20%E5%92%8C%20reentrantlock%20%E7%9A%84%E5%BC%82%E5%90%8C%E3%80%82">67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。</a></p>
<p><a href="#68%E3%80%81reentrantlock%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%E7%9A%84%EF%BC%9F">68、ReentrantLock 是如何实现可重入性的？</a></p>
<p><a href="#69%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E7%B2%97%E5%8C%96%EF%BC%9F">69、什么是锁消除和锁粗化？</a></p>
<p><a href="#70%E3%80%81%E8%B7%9F%20synchronized%20%E7%9B%B8%E6%AF%94%EF%BC%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%20reentrantlock%20%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F">70、跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？</a></p>
<p><a href="#71%E3%80%81%E9%82%A3%E4%B9%88%E8%AF%B7%E8%B0%88%E8%B0%88%20aqs%20%E6%A1%86%E6%9E%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%E5%84%BF%EF%BC%9F">71、那么请谈谈 AQS 框架是怎么回事儿？</a></p>
<p><a href="#72%E3%80%81aqs%20%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%9F">72、AQS 对资源的共享方式？</a></p>
<p><a href="#73%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%20java%20%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%BD%BC%E6%AD%A4%E5%90%8C%E6%AD%A5%EF%BC%9F">73、如何让 Java 的线程彼此同步？</a></p>
<p><a href="#74%E3%80%81%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E5%90%8C%E6%AD%A5%E5%99%A8%EF%BC%9F%E8%AF%B7%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D%E4%B8%8B%E3%80%82">74、你了解过哪些同步器？请分别介绍下。</a></p>
<p><a href="#75%E3%80%81java%20%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">75、Java 中的线程池是如何实现的</a></p>
<p><a href="#76%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0">76、创建线程池的几个核心构造参数</a></p>
<p><a href="#77%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%9F%E6%98%AF%E4%B8%80%E5%BC%80%E5%A7%8B%E5%B0%B1%E9%9A%8F%E7%9D%80%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%90%AF%E5%8A%A8%E5%88%9B%E5%BB%BA%E5%A5%BD%E7%9A%84%E5%90%97%EF%BC%9F">77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？</a></p>
<p><a href="#78%E3%80%81volatile%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8">78、volatile 关键字的作用</a></p>
<p><a href="#79%E3%80%81%E6%97%A2%E7%84%B6%20volatile%20%E8%83%BD%E5%A4%9F%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%8F%98%E9%87%8F%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B0%B1%E6%84%8F%E5%91%B3%E7%9D%80%E5%9F%BA%E4%BA%8E%20volatile%20%E5%8F%98%E9%87%8F%E7%9A%84%E8%BF%90%E7%AE%97%E5%B0%B1%E6%98%AF%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F">79、既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？</a></p>
<p><a href="#80%E3%80%81threadlocal%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F">80、ThreadLocal 是什么？有哪些使用场景？</a></p>
<p><a href="#81%E3%80%81%E8%AF%B7%E8%B0%88%E8%B0%88%20threadlocal%20%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F">81、请谈谈 ThreadLocal 是怎么解决并发安全的？</a></p>
<p><a href="#82%E3%80%81%E5%BE%88%E5%A4%9A%E4%BA%BA%E9%83%BD%E8%AF%B4%E8%A6%81%E6%85%8E%E7%94%A8%20threadlocal%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BD%BF%E7%94%A8%20threadlocal%20%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F">82、很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？</a></p>
<p><a href="#83%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%E4%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F">83、为什么代码会重排序？</a></p>
<p><a href="#84%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B">84、什么是自旋</a></p>
<p><a href="#85%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%20synchronized%20%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">85、多线程中 synchronized 锁升级的原理是什么？</a></p>
<p><a href="#86%E3%80%81synchronized%20%E5%92%8C%20reentrantlock%20%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">86、synchronized 和 ReentrantLock 区别是什么？</a></p>
<p><a href="#87%E3%80%81java%20concurrency%20api%20%E4%B8%AD%E7%9A%84%20lock%20%E6%8E%A5%E5%8F%A3(lock%20interface)%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AF%B9%E6%AF%94%E5%90%8C%E6%AD%A5%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F">87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</a></p>
<p><a href="#88%E3%80%81jsp%20%E5%92%8C%20servlet%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">88、jsp 和 servlet 有什么区别？</a></p>
<p><a href="#89%E3%80%81jsp%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">89、jsp 有哪些内置对象？作用分别是什么？</a></p>
<p><a href="#90%E3%80%81forward%20%E5%92%8C%20redirect%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">90、forward 和 redirect 的区别？</a></p>
<p><a href="#91%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20jsp%20%E7%9A%84%204%20%E7%A7%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F">91、说一下 jsp 的 4 种作用域？</a></p>
<p><a href="#92%E3%80%81session%20%E5%92%8C%20cookie%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">92、session 和 cookie 有什么区别？</a></p>
<p><a href="#93%E3%80%81%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A6%81%E6%AD%A2%20cookie%20%E8%83%BD%E5%AE%9E%E7%8E%B0%20session%20%E8%BF%98%E8%83%BD%E7%94%A8%E5%90%97%EF%BC%9F">93、如果客户端禁止 cookie 能实现 session 还能用吗？</a></p>
<p><a href="#94%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F">94、什么是上下文切换？</a></p>
<p><a href="#95%E3%80%81cookie%E3%80%81session%E3%80%81token">95、cookie、session、token</a></p>
<p><a href="#96%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20session%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F">96、说一下 session 的工作原理？</a></p>
<p><a href="#97%E3%80%81http%20%E5%93%8D%E5%BA%94%E7%A0%81%20301%20%E5%92%8C%20302%20%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">97、http 响应码 301 和 302 代表的是什么？有什么区别？</a></p>
<p><a href="#98%E3%80%81%E7%AE%80%E8%BF%B0%20tcp%20%E5%92%8C%20udp%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">98、简述 tcp 和 udp的区别？</a></p>
<p><a href="#99%E3%80%81tcp%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F">99、tcp 为什么要三次握手，两次不行吗？为什么？</a></p>
<p><a href="#100%E3%80%81osi%20%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">100、OSI 的七层模型都有哪些？</a></p>
<p><a href="#101%E3%80%81get%20%E5%92%8C%20post%20%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F">101、get 和 post 请求有哪些区别？</a></p>
<p><a href="#102%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20xss%20%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F">102、什么是 XSS 攻击，如何避免？</a></p>
<p><a href="#103%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20csrf%20%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F">103、什么是 CSRF 攻击，如何避免？</a></p>
<p><a href="#104%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%20jsonp%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F">104、如何实现跨域？说一下 JSONP 实现原理？</a></p>
<p><a href="#105%E3%80%81websocket%E5%BA%94%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E5%8D%8F%E8%AE%AE">105、websocket应用的是哪个协议</a></p>
<p><a href="#106%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20tcp%20%E7%B2%98%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F">106、说一下 tcp 粘包是怎么产生的？</a></p>
<p><a href="#107%E3%80%81%E8%AF%B7%E5%88%97%E4%B8%BE%E5%87%BA%E5%9C%A8%20jdk%20%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F">107、请列举出在 JDK 中几个常用的设计模式？</a></p>
<p><a href="#108%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E4%BD%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E8%BF%87%E4%BB%BB%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F">108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？</a></p>
<p><a href="#109%E3%80%81java%20%E4%B8%AD%E4%BB%80%E4%B9%88%E5%8F%AB%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E8%AF%B7%E7%94%A8%20java%20%E5%86%99%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式</a></p>
<p><a href="#110%E3%80%81%E5%9C%A8%20java%20%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E5%8F%AB%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88observer%20design%20pattern%EF%BC%89%EF%BC%9F">110、在 Java 中，什么叫观察者设计模式（observer design pattern）？</a></p>
<p><a href="#111%E3%80%81%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%EF%BC%9F">111、使用工厂模式最主要的好处是什么？在哪里使用？</a></p>
<p><a href="#112%E3%80%81%E8%AF%B7%E8%A7%A3%E9%87%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">112、请解释自动装配模式的区别？</a></p>
<p><a href="#113%E3%80%81%E4%B8%BE%E4%B8%80%E4%B8%AA%E7%94%A8%20java%20%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F(decorator%20design%20pattern)%EF%BC%9F%E5%AE%83%E6%98%AF%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%B1%82%E6%AC%A1%E8%BF%98%E6%98%AF%E7%B1%BB%E5%B1%82%E6%AC%A1%EF%BC%9F">113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</a></p>
<p><a href="#114%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20spring%20%E6%A1%86%E6%9E%B6%EF%BC%9Fspring%20%E6%A1%86%E6%9E%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97%EF%BC%9F">114、什么是 Spring 框架？Spring 框架有哪些主要模块？</a></p>
<p><a href="#115%E3%80%81%E4%BD%BF%E7%94%A8%20spring%20%E6%A1%86%E6%9E%B6%E8%83%BD%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84%EF%BC%9F">115、使用 Spring 框架能带来哪些好处？</a></p>
<p><a href="#116%E3%80%81spring%20ioc%E3%80%81aop%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E">116、Spring IOC、AOP举例说明</a></p>
<p><a href="#117%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC(ioc)%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F">117、什么是控制反转(IOC)？什么是依赖注入？</a></p>
<p><a href="#118%E3%80%81beanfactory%20%E5%92%8C%20applicationcontext%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">118、BeanFactory 和 ApplicationContext 有什么区别？</a></p>
<p><a href="#119%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20javaconfig%EF%BC%9F">119、什么是 JavaConfig？</a></p>
<p><a href="#120%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20orm%20%E6%A1%86%E6%9E%B6%EF%BC%9F">120、什么是 ORM 框架？</a></p>
<p><a href="#121%E3%80%81spring%20%E6%9C%89%E5%87%A0%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%9F">121、Spring 有几种配置方式？</a></p>
<p><a href="#122%E3%80%81%E8%AF%B7%E8%A7%A3%E9%87%8A%20spring%20bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F">122、请解释 Spring Bean 的生命周期？</a></p>
<p><a href="#123%E3%80%81spring%20bean%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9Fspring%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84bean%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA5%E4%B8%AA%E8%8C%83%E5%9B%B4%EF%BC%9A">123、Spring Bean 的作用域之间有什么区别？Spring容器中的bean可以分为5个范围：</a></p>
<p><a href="#124%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8%20spring%20boot%20%E4%B8%AD%E7%A6%81%E7%94%A8%20actuator%20%E7%AB%AF%E7%82%B9%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F">124、如何在 Spring Boot 中禁用 Actuator 端点安全性？</a></p>
<p><a href="#125%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20spring%20inner%20beans%EF%BC%9F">125、什么是 Spring inner beans？</a></p>
<p><a href="#126%E3%80%81spring%20%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%20beans%20%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88%EF%BC%9F">126、Spring 框架中的单例 Beans 是线程安全的么？</a></p>
<p><a href="#127%E3%80%81%E8%AF%B7%E8%A7%A3%E9%87%8A%20spring%20bean%20%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%9F">127、请解释 Spring Bean 的自动装配？</a></p>
<p><a href="#128%E3%80%81%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%9F">128、如何开启基于注解的自动装配？</a></p>
<p><a href="#129%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20spring%20batch%EF%BC%9F">129、什么是 Spring Batch？</a></p>
<p><a href="#130%E3%80%81spring%20mvc%20%E5%92%8C%20struts%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">130、spring mvc 和 struts 的区别是什么？</a></p>
<p><a href="#131%E3%80%81%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%A7%A3%E9%87%8A@required%20%E6%B3%A8%E8%A7%A3%EF%BC%9F">131、请举例解释@Required 注解？</a></p>
<p><a href="#132%E3%80%81spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3">132、Spring常用注解</a></p>
<p><a href="#133%E3%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E7%9A%84%EF%BC%8C%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E9%9C%80%E8%A6%81%E5%87%A0%E5%BC%A0%E8%A1%A8">133、项目中是如何实现权限验证的，权限验证需要几张表</a></p>
<p><a href="#134%E3%80%81%E8%B0%88%E8%B0%88controller%EF%BC%8C%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">134、谈谈controller，接口调用的路径问题</a></p>
<p><a href="#135%E3%80%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4">135、如何防止表单重复提交</a></p>
<p><a href="#136%E3%80%81spring%E4%B8%AD%E9%83%BD%E5%BA%94%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">136、Spring中都应用了哪些设计模式</a></p>
<p><a href="#137%E3%80%81%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%A6%82%E4%BD%95%E5%9C%A8%20spring%20%E4%B8%AD%E6%B3%A8%E5%85%A5%E4%B8%80%E4%B8%AA%20java%20collection%EF%BC%9F">137、请举例说明如何在 Spring 中注入一个 Java Collection？</a></p>
<p><a href="#138%E3%80%81mybatis%20%E4%B8%AD%20#%7B%7D%E5%92%8C%20$%7B%7D%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">138、mybatis 中 #{}和 ${}的区别是什么？</a></p>
<p><a href="#139%E3%80%81mybatis%20%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">139、mybatis 是否支持延迟加载？延迟加载的原理是什么？</a></p>
<p><a href="#140%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20mybatis%20%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F">140、说一下 mybatis 的一级缓存和二级缓存？</a></p>
<p><a href="#141%E3%80%81mybatis%20%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%88executor%EF%BC%89%EF%BC%9F">141、mybatis 有哪些执行器（Executor）？</a></p>
<p><a href="#142%E3%80%81mybatis%20%E5%92%8C%20hibernate%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">142、mybatis 和 hibernate 的区别有哪些？</a></p>
<p><a href="#143%E3%80%81mybatis%E6%9F%A5%E8%AF%A2%E5%A4%9A%E4%B8%AAid%E3%80%81mybatis%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7">143、myBatis查询多个id、myBatis常用属性</a></p>
<p><a href="#144%E3%80%81mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98">144、mybatis一级缓存、二级缓存</a></p>
<p><a href="#145%E3%80%81mybatis%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5">145、mybatis如何防止sql注入</a></p>
<p><a href="#146%E3%80%81hibernate%20%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E6%89%93%E5%8D%B0%E7%9A%84%20sql%20%E8%AF%AD%E5%8F%A5%EF%BC%9F">146、hibernate 中如何在控制台查看打印的 sql 语句？</a></p>
<p><a href="#147%E3%80%81hibernate%20%E6%9C%89%E5%87%A0%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%EF%BC%9F">147、hibernate 有几种查询方式？</a></p>
<p><a href="#148%E3%80%81hibernate%20%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AE%9A%E4%B9%89%E4%B8%BA%20final%20%E5%90%97%EF%BC%9F">148、hibernate 实体类可以被定义为 final 吗？</a></p>
<p><a href="#149%E3%80%81%E5%9C%A8%20hibernate%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20integer%20%E5%92%8C%20int%20%E5%81%9A%E6%98%A0%E5%B0%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？</a></p>
<p><a href="#150%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20spring%20boot%EF%BC%9Fspring%20boot%20%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F">150、什么是 Spring Boot？Spring Boot 有哪些优点？</a></p>
<p><a href="#151%E3%80%81spring%20boot%20%E4%B8%AD%E7%9A%84%E7%9B%91%E8%A7%86%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">151、Spring Boot 中的监视器是什么？</a></p>
<p><a href="#152%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20yaml%EF%BC%9F">152、什么是 YAML？</a></p>
<p><a href="#153%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20spring%20boot%20%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E5%92%8C%E6%8E%92%E5%BA%8F%EF%BC%9F">153、如何使用 Spring Boot 实现分页和排序？</a></p>
<p><a href="#154%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20spring%20boot%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9F">154、如何使用 Spring Boot 实现异常处理？</a></p>
<p><a href="#155%E3%80%81%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95">155、单点登录</a></p>
<p><a href="#156%E3%80%81spring%20boot%E6%AF%94spring%E5%A4%9A%E5%93%AA%E4%BA%9B%E6%B3%A8%E8%A7%A3">156、Spring Boot比Spring多哪些注解</a></p>
<p><a href="#157%E3%80%81%E6%89%93%E5%8C%85%E5%92%8C%E9%83%A8%E7%BD%B2">157、打包和部署</a></p>
<p><a href="#158%E3%80%81spring%20boot%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93">158、Spring Boot如何访问不同的数据库</a></p>
<p><a href="#159%E3%80%81%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99%E5%9C%A8%E7%BA%BF%E4%BA%BA%E6%95%B0">159、查询网站在线人数</a></p>
<p><a href="#160%E3%80%81easyexcel%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">160、easyExcel如何实现</a></p>
<p><a href="#161%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20swagger%EF%BC%9F%E4%BD%A0%E7%94%A8%20spring%20boot%20%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%AE%83%E5%90%97%EF%BC%9F">161、什么是 Swagger？你用 Spring Boot 实现了它吗？</a></p>
<p><a href="#162%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">162、数据库的三范式是什么？</a></p>
<p><a href="#163%E3%80%81%E4%B8%80%E5%BC%A0%E8%87%AA%E5%A2%9E%E8%A1%A8%E9%87%8C%E9%9D%A2%E6%80%BB%E5%85%B1%E6%9C%89%207%20%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%A0%E9%99%A4%E4%BA%86%E6%9C%80%E5%90%8E%202%20%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%87%8D%E5%90%AF%20mysql%20%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%8F%88%E6%8F%92%E5%85%A5%E4%BA%86%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%AD%A4%E6%97%B6%20id%20%E6%98%AF%E5%87%A0%EF%BC%9F">163、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</a></p>
<p><a href="#%E5%8D%81%E4%B9%9D%E3%80%81%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%EF%BC%9F">164、如何获取当前数据库版本？</a></p>
<p><a href="#165%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20acid%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">165、说一下 ACID 是什么？</a></p>
<p><a href="#166%E3%80%81char%20%E5%92%8C%20varchar%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">166、char 和 varchar 的区别是什么？</a></p>
<p><a href="#167%E3%80%81float%20%E5%92%8C%20double%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">167、float 和 double 的区别是什么？</a></p>
<p><a href="#168%E3%80%81oracle%E5%88%86%E9%A1%B5sql">168、Oracle分页sql</a></p>
<p><a href="#169%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%BB%E9%94%AE%E5%94%AF%E4%B8%80%E6%80%A7">169、数据库如何保证主键唯一性</a></p>
<p><a href="#170%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93">170、如何设计数据库</a></p>
<p><a href="#171%E3%80%81%E6%80%A7%E5%88%AB%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88%E5%81%9A%E7%B4%A2%E5%BC%95">171、性别是否适合做索引</a></p>
<p><a href="#172%E3%80%81%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE">172、如何查询重复的数据</a></p>
<p><a href="#173%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%88%AC%E4%BC%9A%E9%87%87%E5%8F%96%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9F">173、数据库一般会采取什么样的优化方法？</a></p>
<p><a href="#174%E3%80%81%E7%B4%A2%E5%BC%95%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%88%86%E5%93%AA%E5%87%A0%E7%A7%8D">174、索引怎么定义，分哪几种</a></p>
<p><a href="#175%E3%80%81mysql%20%E7%9A%84%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">175、mysql 的内连接、左连接、右连接有什么区别？</a></p>
<p><a href="#176%E3%80%81rabbitmq%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">176、RabbitMQ的使用场景有哪些？</a></p>
<p><a href="#177%E3%80%81rabbitmq%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E8%A7%92%E8%89%B2%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%9F">177、RabbitMQ有哪些重要的角色？有哪些重要的组件？</a></p>
<p><a href="#178%E3%80%81rabbitmq%E4%B8%AD%20vhost%20%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">178、RabbitMQ中 vhost 的作用是什么？</a></p>
<p><a href="#179%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20jvm%20%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%9F%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9F">179、说一下 jvm 的主要组成部分？及其作用？</a></p>
<p><a href="#180%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20jvm%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%9F">180、说一下 jvm 运行时数据区？</a></p>
<p><a href="#181%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">181、什么是类加载器，类加载器有哪些？</a></p>
<p><a href="#182%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F">182、说一下类加载的执行过程？</a></p>
<p><a href="#183%E3%80%81jvm%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">183、JVM的类加载机制是什么？</a></p>
<p><a href="#184%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F">184、什么是双亲委派模型？</a></p>
<p><a href="#185%E3%80%81%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F">185、怎么判断对象是否可以被回收？</a></p>
<p><a href="#186%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20jvm%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F">186、说一下 jvm 有哪些垃圾回收算法？</a></p>
<p><a href="#187%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%20jvm%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F">187、说一下 jvm 有哪些垃圾回收器？</a></p>
<p><a href="#188%E3%80%81jvm%E6%A0%88%E5%A0%86%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%BD%95%E6%97%B6%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1">188、JVM栈堆概念，何时销毁对象</a></p>
<p><a href="#189%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E8%80%81%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</a></p>
<p><a href="#190%E3%80%81%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%20cms%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F">190、详细介绍一下 CMS 垃圾回收器？</a></p>
<p><a href="#191%E3%80%81%E7%AE%80%E8%BF%B0%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F">191、简述分代垃圾回收器是怎么工作的？</a></p>
<p><a href="#192%E3%80%81redis%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">192、Redis是什么？</a></p>
<p><a href="#193%E3%80%81redis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F">193、Redis都有哪些使用场景？</a></p>
<p><a href="#194%E3%80%81redis%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%9F">194、Redis有哪些功能？</a></p>
<p><a href="#195%E3%80%81redis%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">195、Redis支持的数据类型有哪些？</a></p>
<p><a href="#196%E3%80%81redis%E5%8F%96%E5%80%BC%E5%AD%98%E5%80%BC%E9%97%AE%E9%A2%98">196、Redis取值存值问题</a></p>
<p><a href="#197%E3%80%81redis%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F">197、Redis为什么是单线程的？</a></p>
<p><a href="#198%E3%80%81redis%E7%9C%9F%E7%9A%84%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%97%EF%BC%9F">198、Redis真的是单线程的吗？</a></p>
<p><a href="#199%E3%80%81redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F">199、Redis持久化有几种方式？</a></p>
<p><a href="#200%E3%80%81redis%E5%92%8C%20memecache%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">200、Redis和 memecache 有什么区别？</a></p>
<p><a href="#201%E3%80%81redis%E6%94%AF%E6%8C%81%E7%9A%84%20java%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">201、Redis支持的 java 客户端都有哪些？</a></p>
<p><a href="#202%E3%80%81jedis%20%E5%92%8C%20redisson%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F">202、jedis 和 redisson 有哪些区别？</a></p>
<p><a href="#203%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F">203、什么是缓存穿透？怎么解决？</a></p>
<p><a href="#204%E3%80%81%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F">204、怎么保证缓存和数据库数据的一致性？</a></p>
<p><a href="#205%E3%80%81redis%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F">205、Redis，什么是缓存穿透？怎么解决？</a></p>
<p><a href="#206%E3%80%81redis%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F">206、Redis怎么实现分布式锁？</a></p>
<p><a href="#207%E3%80%81redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%9F">207、Redis分布式锁有什么缺陷？</a></p>
<p><a href="#208%E3%80%81redis%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%9F">208、Redis如何做内存优化？</a></p>
<h3 id="1、JDK-和-JRE-有什么区别？"><a href="#1、JDK-和-JRE-有什么区别？" class="headerlink" title="1、JDK 和 JRE 有什么区别？"></a>1、JDK 和 JRE 有什么区别？</h3><p>JDK（Java Development Kit），Java开发工具包</p>
<p>JRE（Java Runtime Environment），Java运行环境</p>
<p>JDK中包含JRE，JDK中有一个名为jre的目录，里面包含两个文件夹bin和lib，bin就是JVM，lib就是JVM工作所需要的类库。</p>
<h3 id="2、-和-equals-的区别是什么？"><a href="#2、-和-equals-的区别是什么？" class="headerlink" title="2、== 和 equals 的区别是什么？"></a>2、== 和 equals 的区别是什么？</h3><ol>
<li>对于基本类型，==比较的是值；</li>
<li>对于引用类型，==比较的是地址；</li>
<li>equals不能用于基本类型的比较；</li>
<li>如果没有重写equals，equals就相当于==；</li>
<li>如果重写了equals方法，equals比较的是对象的内容；</li>
</ol>
<h3 id="3、final-在-java-中有什么作用？"><a href="#3、final-在-java-中有什么作用？" class="headerlink" title="3、final 在 java 中有什么作用？"></a>3、final 在 java 中有什么作用？</h3><p>（1）用来修饰一个引用</p>
<ol>
<li>如果引用为基本数据类型，则该引用为常量，该值无法修改；</li>
<li>如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。</li>
<li>如果引用时类的成员变量，则必须当场赋值，否则编译会报错。</li>
</ol>
<p>（2）用来修饰一个方法</p>
<p>当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。</p>
<p>（3）用来修饰类</p>
<p>当用final修改类时，该类成为最终类，无法被继承。</p>
<p>比如常用的String类就是最终类。</p>
<h3 id="4、java-中的-Math-round-1-5-等于多少？"><a href="#4、java-中的-Math-round-1-5-等于多少？" class="headerlink" title="4、java 中的 Math.round(-1.5) 等于多少？"></a>4、java 中的 Math.round(-1.5) 等于多少？</h3><p>Math提供了三个与取整有关的方法：ceil、floor、round</p>
<p>（1）ceil：向上取整；</p>
<p>Math.ceil(11.3) = 12;</p>
<p>Math.ceil(-11.3) = 11;</p>
<p>（2）floor：向下取整；</p>
<p>Math.floor(11.3) = 11;</p>
<p>Math.floor(-11.3) = -12;</p>
<p>（3）round：四舍五入；</p>
<p>加0.5然后向下取整。</p>
<p>Math.round(11.3) = 11;</p>
<p>Math.round(11.8) = 12;</p>
<p>Math.round(-11.3) = -11;</p>
<p>Math.round(-11.8) = -12;</p>
<h3 id="5、String-属于基础的数据类型吗？"><a href="#5、String-属于基础的数据类型吗？" class="headerlink" title="5、String 属于基础的数据类型吗？"></a>5、String 属于基础的数据类型吗？</h3><p>不属于。</p>
<p>八种基本数据类型：byte、short、char、int、long、double、float、boolean。</p>
<h3 id="6、String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#6、String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="6、String str=”i”与 String str=new String(“i”)一样吗？"></a>6、String str=”i”与 String str=new String(“i”)一样吗？</h3><p>String str=”i”会将起分配到常量池中，常量池中没有重复的元素，如果常量池中存中i，就将i的地址赋给变量，如果没有就创建一个再赋给变量。</p>
<p>String str=new String(“i”)会将对象分配到堆中，即使内存一样，还是会重新创建一个新的对象。</p>
<h3 id="7、如何将字符串反转？"><a href="#7、如何将字符串反转？" class="headerlink" title="7、如何将字符串反转？"></a>7、如何将字符串反转？</h3><p>将对象封装到stringBuilder中，调用reverse方法反转。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801160716840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<h3 id="8、String-类的常用方法都有那些？"><a href="#8、String-类的常用方法都有那些？" class="headerlink" title="8、String 类的常用方法都有那些？"></a>8、String 类的常用方法都有那些？</h3><p>（1）常见String类的获取功能</p>
<p>length：获取字符串长度；<br>charAt(int index)：获取指定索引位置的字符；<br>indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引；<br>substring(int start)：从指定位置开始截取字符串,默认到末尾；<br>substring(int start,int end)：从指定位置开始到指定位置结束截取字符串；</p>
<p>（2）常见String类的判断功能</p>
<p>equals(Object obj)： 比较字符串的内容是否相同,区分大小写；<br>contains(String str): 判断字符串中是否包含传递进来的字符串；<br>startsWith(String str): 判断字符串是否以传递进来的字符串开头；<br>endsWith(String str): 判断字符串是否以传递进来的字符串结尾；<br>isEmpty(): 判断字符串的内容是否为空串””；</p>
<p>（3）常见String类的转换功能</p>
<p>byte[] getBytes(): 把字符串转换为字节数组；<br>char[] toCharArray(): 把字符串转换为字符数组；<br>String valueOf(char[] chs): 把字符数组转成字符串。valueOf可以将任意类型转为字符串；<br>toLowerCase(): 把字符串转成小写；<br>toUpperCase(): 把字符串转成大写；<br>concat(String str): 把字符串拼接；</p>
<p>（4）常见String类的其他常用功能</p>
<p>replace(char old,char new) 将指定字符进行互换<br>replace(String old,String new) 将指定字符串进行互换<br>trim() 去除两端空格<br>int compareTo(String str) 会对照ASCII 码表 从第一个字母进行减法运算 返回的就是这个减法的结果，如果前面几个字母一样会根据两个字符串的长度进行减法运算返回的就是这个减法的结果，如果连个字符串一摸一样 返回的就是0。</p>
<h3 id="9、new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#9、new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="9、new String(“a”) + new String(“b”) 会创建几个对象？"></a>9、new String(“a”) + new String(“b”) 会创建几个对象？</h3><p>对象1：new StringBuilder()</p>
<p>对象2：new String(“a”)</p>
<p>对象3：常量池中的”a”</p>
<p>对象4：new String(“b”)</p>
<p>对象5：常量池中的”b”</p>
<p>深入剖析：StringBuilder中的toString()：</p>
<p>对象6：new String(“ab”)</p>
<p>强调一下，toString()的调用，在字符串常量池中，没有生成”ab”</p>
<p>附加题</p>
<blockquote>
<p>String s1 = new String(“1”) + new String(“1”);//s1变量记录的地址为：new String<br>s1.intern();//在字符串常量池中生成”11”。如何理解：jdk6：创建了一个新的对象”11”，也就有新的地址；jdk7：此时常量池中并没有创建”11”，而是创建了一个指向堆空间中new String(“11”)的地址；<br>String s2 = “11”;<br>System.out.println(s1 == s2);//jdk6:false;jdk7:true</p>
</blockquote>
<h3 id="10、如何将字符串反转？"><a href="#10、如何将字符串反转？" class="headerlink" title="10、如何将字符串反转？"></a>10、如何将字符串反转？</h3><p>添加到StringBuilder中，然后调用reverse()。</p>
<h3 id="11、String-类的常用方法都有那些？"><a href="#11、String-类的常用方法都有那些？" class="headerlink" title="11、String 类的常用方法都有那些？"></a>11、String 类的常用方法都有那些？</h3><p>equals、length、contains、replace、split、hashcode、indexof、substring、trim、toUpperCase、toLowerCase、isEmpty等等。</p>
<h3 id="12、普通类和抽象类有哪些区别？"><a href="#12、普通类和抽象类有哪些区别？" class="headerlink" title="12、普通类和抽象类有哪些区别？"></a>12、普通类和抽象类有哪些区别？</h3><p>抽象类不能被实例化；<br>抽象类可以有抽象方法，只需申明，无须实现；<br>有抽象方法的类一定是抽象类；<br>抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；<br>抽象方法不能声明为静态、不能被static、final修饰。</p>
<h3 id="13、接口和抽象类有什么区别？"><a href="#13、接口和抽象类有什么区别？" class="headerlink" title="13、接口和抽象类有什么区别？"></a>13、接口和抽象类有什么区别？</h3><p>（1）接口</p>
<p>接口使用interface修饰；<br>接口不能实例化；<br>类可以实现多个接口；</p>
<p>①java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</p>
<p>（2）抽象类</p>
<p>抽象类使用abstract修饰；<br>抽象类不能被实例化；<br>抽象类只能单继承；<br>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；<br>如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。</p>
<h3 id="14、java-中-IO-流分为几种？"><a href="#14、java-中-IO-流分为几种？" class="headerlink" title="14、java 中 IO 流分为几种？"></a>14、java 中 IO 流分为几种？</h3><p>（1）按流划分，可以分为输入流和输出流；</p>
<p>（2）按单位划分，可以分为字节流和字符流；</p>
<p>字节流：inputStream、outputStream；</p>
<p>字符流：reader、writer；</p>
<h3 id="15、BIO、NIO、AIO-有什么区别？"><a href="#15、BIO、NIO、AIO-有什么区别？" class="headerlink" title="15、BIO、NIO、AIO 有什么区别？"></a>15、BIO、NIO、AIO 有什么区别？</h3><p>（1）同步阻塞BIO</p>
<p>一个连接一个线程。</p>
<p>JDK1.4之前，建立网络连接的时候采用BIO模式，先在启动服务端socket，然后启动客户端socket，对服务端通信，客户端发送请求后，先判断服务端是否有线程响应，如果没有则会一直等待或者遭到拒绝请求，如果有的话会等待请求结束后才继续执行。</p>
<p>（2）同步非阻塞NIO</p>
<p>NIO主要是想解决BIO的大并发问题，BIO是每一个请求分配一个线程，当请求过多时，每个线程占用一定的内存空间，服务器瘫痪了。</p>
<p>JDK1.4开始支持NIO，适用于连接数目多且连接比较短的架构，比如聊天服务器，并发局限于应用中。</p>
<p>一个请求一个线程。</p>
<p>（3）异步非阻塞AIO</p>
<p>一个有效请求一个线程。</p>
<p>JDK1.7开始支持AIO，适用于连接数目多且连接比较长的结构，比如相册服务器，充分调用OS参与并发操作。</p>
<h3 id="16、Files的常用方法都有哪些？"><a href="#16、Files的常用方法都有哪些？" class="headerlink" title="16、Files的常用方法都有哪些？"></a>16、Files的常用方法都有哪些？</h3><p>exist<br>createFile<br>createDirectory<br>write<br>read<br>copy<br>size<br>delete<br>move</p>
<h3 id="17、什么是反射？"><a href="#17、什么是反射？" class="headerlink" title="17、什么是反射？"></a>17、什么是反射？</h3><p>所谓反射，是java在运行时进行自我观察的能力，通过class、constructor、field、method四个方法获取一个类的各个组成部分。</p>
<p>在Java运行时环境中，对任意一个类，可以知道类有哪些属性和方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于反射机制。</p>
<h3 id="18、什么是-java-序列化？什么情况下需要序列化？"><a href="#18、什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="18、什么是 java 序列化？什么情况下需要序列化？"></a>18、什么是 java 序列化？什么情况下需要序列化？</h3><p>序列化就是一种用来处理对象流的机制。将对象的内容流化，将流化后的对象传输于网络之间。</p>
<p>序列化是通过实现serializable接口，该接口没有需要实现的方法，implement Serializable只是为了标注该对象是可被序列化的，使用一个输出流（FileOutputStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObejct（Object object）方法就可以将参数的obj对象到磁盘，需要恢复的时候使用输入流。</p>
<p>序列化是将对象转换为容易传输的格式的过程。</p>
<p>例如，可以序列化一个对象，然后通过HTTP通过Internet在客户端和服务器之间传输该对象。在另一端，反序列化将从流中心构造成对象。</p>
<p>一般程序在运行时，产生对象，这些对象随着程序的停止而消失，但我们想将某些对象保存下来，这时，我们就可以通过序列化将对象保存在磁盘，需要使用的时候通过反序列化获取到。</p>
<p>对象序列化的最主要目的就是传递和保存对象，保存对象的完整性和可传递性。</p>
<p>譬如通过网络传输或者把一个对象保存成本地一个文件的时候，需要使用序列化。</p>
<h3 id="19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？"><a href="#19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？" class="headerlink" title="19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？"></a>19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？</h3><p>（1）什么要使用克隆？</p>
<p>想对一个对象进行复制，又想保留原有的对象进行接下来的操作，这个时候就需要克隆了。</p>
<p>（2）如何实现对象克隆？</p>
<p>实现Cloneable接口，重写clone方法；<br>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。<br>BeanUtils，apache和Spring都提供了bean工具，只是这都是浅克隆。</p>
<p>（3）深拷贝和浅拷贝区别是什么？</p>
<p>浅拷贝：仅仅克隆基本类型变量，不克隆引用类型变量；<br>深克隆：既克隆基本类型变量，又克隆引用类型变量；</p>
<p>（4）代码实例</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801160905498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801160958218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<h3 id="20、throw-和-throws-的区别？"><a href="#20、throw-和-throws-的区别？" class="headerlink" title="20、throw 和 throws 的区别？"></a>20、throw 和 throws 的区别？</h3><p>（1）throw</p>
<p>作用在方法内，表示抛出具体异常，由方法体内的语句处理；<br>一定抛出了异常；</p>
<p>（2）throws</p>
<p>作用在方法的声明上，表示抛出异常，由调用者来进行异常处理；<br>可能出现异常，不一定会发生异常；</p>
<h3 id="21、final、finally、finalize-有什么区别？"><a href="#21、final、finally、finalize-有什么区别？" class="headerlink" title="21、final、finally、finalize 有什么区别？"></a>21、final、finally、finalize 有什么区别？</h3><p>final可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写</p>
<p>finally用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</p>
<p>finalize方法用于垃圾回收。</p>
<p>一般情况下不需要我们实现finalize，当对象被回收的时候需要释放一些资源，比如socket链接，在对象初始化时创建，整个生命周期内有效，那么需要实现finalize方法，关闭这个链接。</p>
<p>但是当调用finalize方法后，并不意味着gc会立即回收该对象，所以有可能真正调用的时候，对象又不需要回收了，然后到了真正要回收的时候，因为之前调用过一次，这次又不会调用了，产生问题。所以，不推荐使用finalize方法。</p>
<h3 id="22、try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#22、try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801161038947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<h3 id="23、常见的异常类有哪些？"><a href="#23、常见的异常类有哪些？" class="headerlink" title="23、常见的异常类有哪些？"></a>23、常见的异常类有哪些？</h3><ol>
<li>NullPointerException：空指针异常；</li>
<li>SQLException：数据库相关的异常；</li>
<li>IndexOutOfBoundsException：数组下角标越界异常；</li>
<li>FileNotFoundException：打开文件失败时抛出；</li>
<li>IOException：当发生某种IO异常时抛出；</li>
<li>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出此异常；</li>
<li>NoSuchMethodException：无法找到某一方法时，抛出；</li>
<li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常；</li>
<li>NumberFormatException：当试图将字符串转换成数字时，失败了，抛出；</li>
<li>IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>
<li>ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</li>
</ol>
<h3 id="24、hashcode是什么？有什么作用？"><a href="#24、hashcode是什么？有什么作用？" class="headerlink" title="24、hashcode是什么？有什么作用？"></a>24、hashcode是什么？有什么作用？</h3><p>Java中Object有一个方法：</p>
<p>public native int hashcode();</p>
<p>（1）hashcode()方法的作用</p>
<p>hashcode()方法主要配合基于散列的集合一起使用，比如HashSet、HashMap、HashTable。</p>
<p>当集合需要添加新的对象时，先调用这个对象的hashcode()方法，得到对应的hashcode值，实际上hashmap中会有一个table保存已经存进去的对象的hashcode值，如果table中没有改hashcode值，则直接存入，如果有，就调用equals方法与新元素进行比较，相同就不存了，不同就存入。</p>
<p>（2）equals和hashcode的关系</p>
<p>如果equals为true，hashcode一定相等；</p>
<p>如果equals为false，hashcode不一定不相等；</p>
<p>如果hashcode值相等，equals不一定相等；</p>
<p>如果hashcode值不等，equals一定不等；</p>
<p>（3）重写equals方法时，一定要重写hashcode方法</p>
<p>（4）百度百科</p>
<blockquote>
<p>hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。<br>hashCode 的常规协定是：<br>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。<br>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。<br>以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）<br>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
</blockquote>
<p>（5）小白解释</p>
<blockquote>
<p>1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有<br>例如内存中有这样的位置<br>0 1 2 3 4 5 6 7<br>而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。<br>但如果用hashcode那就会使效率提高很多。<br>我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。<br>2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。<br>也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。<br>那么。重写了equals()，为什么还要重写hashCode()呢？<br>想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊。</p>
</blockquote>
<h3 id="25、java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#25、java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="25、java 中操作字符串都有哪些类？它们之间有什么区别？"></a>25、java 中操作字符串都有哪些类？它们之间有什么区别？</h3><p>（1）String</p>
<p>String是不可变对象，每次对String类型的改变时都会生成一个新的对象。</p>
<p>（2）StringBuilder</p>
<p>线程不安全，效率高，多用于单线程。</p>
<p>（3）StringBuffer</p>
<p>线程安全，由于加锁的原因，效率不如StringBuilder，多用于多线程。</p>
<p>不频繁的字符串操作使用String，操作频繁的情况不建议使用String。</p>
<p>StringBuilder &gt; StringBuffer &gt; String。</p>
<h3 id="26、java-中都有哪些引用类型？"><a href="#26、java-中都有哪些引用类型？" class="headerlink" title="26、java 中都有哪些引用类型？"></a>26、java 中都有哪些引用类型？</h3><p>（1）强引用</p>
<p>Java中默认声明的就是强引用，比如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象。如果想被回收，可以将对象置为null；</p>
<p>（2）软引用（SoftReference）</p>
<p>在内存足够的时候，软引用不会被回收，只有在内存不足时，系统才会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会跑出内存溢出异常。</p>
<p>byte[] buff = new byte[1024 * 1024];<br>SoftReference</p>
<p>（3）弱引用（WeakReference）</p>
<p>进行垃圾回收时，弱引用就会被回收。</p>
<p>（4）虚引用（PhantomReference）</p>
<p>（5）引用队列（ReferenceQueue）</p>
<p>引用队列可以与软引用、弱引用、虚引用一起配合使用。</p>
<p>当垃圾回收器准备回收一个对象时，如果发现它还有引用，就会在回收对象之前，把这个引用加入到引用队列中。</p>
<p>程序可以通过判断引用队列中是否加入了引用，来判断被引用的对象是否将要被垃圾回收，这样可以在对象被回收之前采取一些必要的措施。</p>
<h3 id="27、在-Java-中，为什么不允许从静态方法中访问非静态变量？"><a href="#27、在-Java-中，为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="27、在 Java 中，为什么不允许从静态方法中访问非静态变量？"></a>27、在 Java 中，为什么不允许从静态方法中访问非静态变量？</h3><ol>
<li>静态变量属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问；</li>
<li>非静态变量属于类的对象，只有在类的对象产生时，才会分配内存，通过类的实例去访问；</li>
<li>静态方法也属于类本身，但是此时没有类的实例，内存中没有非静态变量，所以无法调用。</li>
</ol>
<h3 id="28、说说Java-Bean的命名规范"><a href="#28、说说Java-Bean的命名规范" class="headerlink" title="28、说说Java Bean的命名规范"></a>28、说说Java Bean的命名规范</h3><ol>
<li>JavaBean 类必须是一个公共类，并将其访问属性设置为 public</li>
<li>JavaBean 类必须有一个空的构造函数：类中必须有一个不带参数的公用构造器，此构造器也应该通过调用各个特性的设置方法来设置特性的缺省值。</li>
<li>一个javaBean类不应有公共实例变量，类变量都为private</li>
<li>持有值应该通过一组存取方法（getXxx 和 setXxx）来访问：对于每个特性，应该有一个带匹配公用 getter 和 setter 方法的专用实例变量。</li>
</ol>
<p>属性为布尔类型，可以使用 isXxx() 方法代替 getXxx() 方法。</p>
<p>通常属性名是要和 包名、类名、方法名、字段名、常量名作出区别的:</p>
<p>首先:必须用英文，不要用汉语拼音</p>
<p>（1）包(package)</p>
<p>用于将完成不同功能的类分门别类，放在不同的目录(包)下，包的命名规则：将公司域名反转作为包名。比如<a target="_blank" rel="noopener" href="http://www.sohu.com/">www.sohu.com</a> 对于包名：每个字母都需要小写。比如：com.sohu.test;该包下的Test类的全名是：com.sohu.Test.Java 。</p>
<p>如果定义类的时候没有使用package,那么java就认为我们所定义的类位于默认包里面(default package)。</p>
<p>（2）类</p>
<p>首字母大写，如果一个类由多个单词构成，那么每个单词的首字母都大写，而且中间不使用任何的连接符。尽量使用英文。如ConnectionFactory</p>
<p>（3）方法</p>
<p>首单词全部小写，如果一个方法由多个单词构成，那么从第二个单词开始首字母大写，不使用连接符。addPerson</p>
<p>（4）字段</p>
<p>与方法相同。如ageOfPerson</p>
<p>（5）常量</p>
<p>所有单词的字母都是大写，如果有多个单词，那么使用下划线链接即可。</p>
<p>如：public static final int AGE_OF_PERSON = 20; //通常加上static</p>
<h3 id="29、Java-Bean-属性命名规范问题分析"><a href="#29、Java-Bean-属性命名规范问题分析" class="headerlink" title="29、Java Bean 属性命名规范问题分析"></a>29、Java Bean 属性命名规范问题分析</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">	<span class="keyword">private</span> String busName;</span><br><span class="line">	<span class="keyword">private</span> String pCount;</span><br><span class="line">	<span class="keyword">private</span> Boolean isRunning;</span><br><span class="line">	<span class="comment">//正确的命名方式，驼峰式的</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getBusName</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> busName;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBusName</span><span class="params">(String busName)</span> {</span><br><span class="line">		<span class="built_in">this</span>.busName = busName;</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">//这是什么？</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getpCount</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> pCount;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setpCount</span><span class="params">(String pCount)</span> {</span><br><span class="line">		<span class="built_in">this</span>.pCount = pCount;</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">//这个也是不允许的</span></span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">getIsRunning</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> isRunning;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIsRunning</span><span class="params">(Boolean isRunning)</span> {</span><br><span class="line">		<span class="built_in">this</span>.isRunning = isRunning;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>javabean属性命名尽量使用常规的驼峰式命名规则</li>
<li>属性名第一个单词尽量避免使用一个字母：如eBook， eMail。</li>
<li>boolean属性名避免使用 “is” 开头的名称</li>
<li>随着jdk， eclipse， spring 等软件版本的不断提高， 底版本的出现的问题可能在高版本中解决了， 低版本原来正常的代码可能在高版本环境下不再支持。</li>
</ol>
<h3 id="30、什么是-Java-的内存模型"><a href="#30、什么是-Java-的内存模型" class="headerlink" title="30、什么是 Java 的内存模型?"></a>30、什么是 Java 的内存模型?</h3><p>在了解什么是 Java 内存模型之前，先了解一下为什么要提出 Java 内存模型。</p>
<p>之前提到过并发编程有三大问题</p>
<p>CPU 缓存，在多核 CPU 的情况下，带来了可见性问题<br>操作系统对当前执行线程的切换，带来了原子性问题<br>译器指令重排优化，带来了有序性问题<br>为了解决并发编程的三大问题，提出了 JSR-133，新的 Java 内存模型，JDK 5 开始使用。</p>
<p>简单总结下</p>
<p>Java 内存模型是 JVM 的一种规范<br>定义了共享内存在多线程程序中读写操作行为的规范<br>屏蔽了各种硬件和操作系统的访问差异，保证了 Java 程序在各种平台下对内存的访问效果一致<br>解决并发问题采用的方式：限制处理器优化和使用内存屏障<br>增强了三个同步原语（synchronized、volatile、final）的内存语义<br>定义了 happens-before 规则</p>
<h3 id="31、在-Java-中，什么时候用重载，什么时候用重写？"><a href="#31、在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="31、在 Java 中，什么时候用重载，什么时候用重写？"></a>31、在 Java 中，什么时候用重载，什么时候用重写？</h3><p>（1）重载是多态的集中体现，在类中，要以统一的方式处理不同类型数据的时候，可以用重载。</p>
<p>（2）重写的使用是建立在继承关系上的，子类在继承父类的基础上，增加新的功能，可以用重写。</p>
<p>（3）简单总结：</p>
<p>重载是多样性，重写是增强剂；<br>目的是提高程序的多样性和健壮性，以适配不同场景使用时，使用重载进行扩展；<br>目的是在不修改原方法及源代码的基础上对方法进行扩展或增强时，使用重写；</p>
<p>生活例子：</p>
<blockquote>
<p>你想吃一碗面，我给你提供了拉面，炒面，刀削面，担担面供你选择，这是重载；<br>你想吃一碗面，我不但给你端来了面，还给你加了青菜，加了鸡蛋，这个是重写；</p>
</blockquote>
<p>设计模式：</p>
<blockquote>
<p>cglib实现动态代理，核心原理用的就是方法的重写；</p>
</blockquote>
<p>详细解答：</p>
<blockquote>
<p>Java的重载(overload) 最重要的应用场景就是构造器的重载，构造器重载后，提供多种形参形式的构造器，可以应对不同的业务需求，加强程序的健壮性和可扩展性，比如我们最近学习的Spring源码中的ClassPathXmlApplicationContext，它的构造函数使用重载一共提供了10个构造函数，这样就为业务的选择提供了多选择性。在应用到方法中时，主要是为了增强方法的健壮性和可扩展性，比如我们在开发中常用的各种工具类，比如我目前工作中的短信工具类SMSUtil, 发短信的方法就会使用重载，针对不同业务场景下的不同形参，提供短信发送方法，这样提高了工具类的扩展性和健壮性。<br>总结：重载必须要修改方法(构造器)的形参列表，可以修改方法的返回值类型，也可以修改方法的异常信息即访问权限；使用范围是在同一个类中，目的是对方法(构造器)进行功能扩展，以应对多业务场景的不同使用需求。提高程序的健壮性和扩展性。<br>java的重写(override) 只要用于子类对父类方法的扩展或修改，但是在我们开发中，为了避免程序混乱，重写一般都是为了方法的扩展，比如在cglib方式实现的动态代理中，代理类就是继承了目标类，对目标类的方法进行重写，同时在方法前后进行切面织入。</p>
</blockquote>
<p>总结：方法重写时，参数列表，返回值得类型是一定不能修改的，异常可以减少或者删除，但是不能抛出新的异常或者更广的异常，方法的访问权限可以降低限制，但是不能做更严格的限制。</p>
<p>（4）在里氏替换原则中，子类对父类的方法尽量不要重写和重载。（我们可以采用final的手段强制来遵循）</p>
<h3 id="32、举例说明什么情况下会更倾向于使用抽象类而不是接口？"><a href="#32、举例说明什么情况下会更倾向于使用抽象类而不是接口？" class="headerlink" title="32、举例说明什么情况下会更倾向于使用抽象类而不是接口？"></a>32、举例说明什么情况下会更倾向于使用抽象类而不是接口？</h3><p>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。</p>
<p>接口通常被用来表示附属描述或行为如： Runnable 、 Clonable 、 Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable( 注：这里的意思是指如果把 Runnable 等实现为抽象类的情况 ) ，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</p>
<p>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</p>
<h3 id="33、实例化对象有哪几种方式"><a href="#33、实例化对象有哪几种方式" class="headerlink" title="33、实例化对象有哪几种方式"></a>33、实例化对象有哪几种方式</h3><ul>
<li>new</li>
<li>clone()</li>
<li>通过反射机制创建</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用 Class.forName方法获取类，在调用类的newinstance（）方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">"com.dao.User"</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)cls.newInstance();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>序列化反序列化</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个对象实例化后，进行序列化，再反序列化，也可以获得一个对象（远程通信的场景下使用）</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span> (<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"D:/data.txt"</span>));</span><br><span class="line"><span class="comment">//序列化对象</span></span><br><span class="line">out.writeObject(user1);</span><br><span class="line">out.close();</span><br><span class="line"><span class="comment">//反序列化对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"D:/data.txt"</span>));</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) in.readObject();</span><br><span class="line">System.out.println(<span class="string">"反序列化user："</span> + user2);</span><br><span class="line">in.close();</span><br></pre></td></tr></tbody></table></figure>

<h3 id="34、byte类型127-1等于多少"><a href="#34、byte类型127-1等于多少" class="headerlink" title="34、byte类型127+1等于多少"></a>34、byte类型127+1等于多少</h3><p>byte的范围是-128~127。</p>
<p>字节长度为8位，最左边的是符号位，而127的二进制为01111111，所以执行+1操作时，01111111变为10000000。</p>
<p>大家知道，计算机中存储负数，存的是补码的兴衰。左边第一位为符号位。</p>
<p>那么负数的补码转换成十进制如下：</p>
<p>一个数如果为正，则它的原码、反码、补码相同；一个正数的补码，将其转化为十进制，可以直接转换。</p>
<p>已知一个负数的补码，将其转换为十进制数，步骤如下：</p>
<ol>
<li>先对各位取反；</li>
<li>将其转换为十进制数；</li>
<li>加上负号，再减去1；</li>
</ol>
<p>例如10000000，最高位是1，是负数，①对各位取反得01111111，转换为十进制就是127，加上负号得-127，再减去1得-128；</p>
<h3 id="35、Java-容器都有哪些？"><a href="#35、Java-容器都有哪些？" class="headerlink" title="35、Java 容器都有哪些？"></a>35、Java 容器都有哪些？</h3><p>（1）Collection</p>
<p>① set</p>
<p>HashSet、TreeSet</p>
<p>② list</p>
<p>ArrayList、LinkedList、Vector</p>
<p>（2）Map</p>
<p>HashMap、HashTable、TreeMap</p>
<h3 id="36、Collection-和-Collections-有什么区别？"><a href="#36、Collection-和-Collections-有什么区别？" class="headerlink" title="36、Collection 和 Collections 有什么区别？"></a>36、Collection 和 Collections 有什么区别？</h3><p>（1）Collection是最基本的集合接口，Collection派生了两个子接口list和set，分别定义了两种不同的存储方式。</p>
<p>（2）Collections是一个包装类，它包含各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等）。</p>
<p>此类不能实例化，就像一个工具类，服务于Collection框架。</p>
<h3 id="37、list与Set区别"><a href="#37、list与Set区别" class="headerlink" title="37、list与Set区别"></a>37、list与Set区别</h3><p>（1）List简介</p>
<p>实际上有两种List：一种是基本的ArrayList,其优点在于随机访问元素，另一种是LinkedList,它并不是为快速随机访问设计的，而是快速的插入或删除。<br>ArrayList：由数组实现的List。允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。<br>LinkedList ：对顺序访问进行了优化，向List中间插入与删除的开销并不大。随机访问则相对较慢。<br>还具有下列方 法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法 (没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。</p>
<p>（2）Set简介</p>
<p>Set具有与Collection完全一样的接口，因此没有任何额外的功能。实际上Set就是Collection,只是行为不同。这是继承与多态思想的典型应用：表现不同的行为。Set不保存重复的元素(至于如何判断元素相同则较为负责)</p>
<p>Set : 存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。<br>HashSet：为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。<br>TreeSet： 保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。</p>
<p>（3）list与Set区别</p>
<p>① List,Set都是继承自Collection接口</p>
<p>② List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）</p>
<p>③ Set和List对比：</p>
<p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</p>
<h3 id="38、HashMap-和-Hashtable-有什么区别？"><a href="#38、HashMap-和-Hashtable-有什么区别？" class="headerlink" title="38、HashMap 和 Hashtable 有什么区别？"></a>38、HashMap 和 Hashtable 有什么区别？</h3><ol>
<li>HashMap是线程不安全的，HashTable是线程安全的；</li>
<li>HashMap中允许键和值为null，HashTable不允许；</li>
<li>HashMap的默认容器是16，为2倍扩容，HashTable默认是11，为2倍+1扩容；</li>
</ol>
<h3 id="39、说一下-HashMap-的实现原理？"><a href="#39、说一下-HashMap-的实现原理？" class="headerlink" title="39、说一下 HashMap 的实现原理？"></a>39、说一下 HashMap 的实现原理？</h3><p>（1）简介</p>
<p>HashMap基于map接口，元素以键值对方式存储，允许有null值，HashMap是线程不安全的。</p>
<p>（2）基本属性</p>
<p>初始化大小，默认16，2倍扩容；<br>负载因子0.75；<br>初始化的默认数组；<br>size<br>threshold。判断是否需要调整hashmap容量</p>
<p>（3）HashMap的存储结构</p>
<p>JDK1.7中采用数组+链表的存储形式。</p>
<p>HashMap采取Entry数组来存储key-value，每一个键值对组成了一个Entry实体，Entry类时机上是一个单向的链表结构，它具有next指针，指向下一个Entry实体，以此来解决Hash冲突的问题。</p>
<p>HashMap实现一个内部类Entry，重要的属性有hash、key、value、next。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801163033687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p>JDK1.8中采用数据+链表+红黑树的存储形式。当链表长度超过阈值（8）时，将链表转换为红黑树。在性能上进一步得到提升。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/2021080116310757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<h3 id="40、set有哪些实现类？"><a href="#40、set有哪些实现类？" class="headerlink" title="40、set有哪些实现类？"></a>40、set有哪些实现类？</h3><p>（1）HashSet</p>
<p>HashSet是set接口的实现类，set下面最主要的实现类就是HashSet（也就是用的最多的），此外还有LinkedHashSet和TreeSet。<br>HashSet是无序的、不可重复的。通过对象的hashCode和equals方法保证对象的唯一性。<br>HashSet内部的存储结构是哈希表，是线程不安全的。</p>
<p>（2）TreeSet</p>
<p>TreeSet对元素进行排序的方式：</p>
<p>元素自身具备比较功能，需要实现Comparable接口，并覆盖compareTo方法。<br>元素自身不具备比较功能，需要实现Comparator接口，并覆盖compare方法。</p>
<p>（3）LinkedHashSet</p>
<p>LinkedHashSet是一种有序的Set集合，即其元素的存入和输出的顺序是相同的。</p>
<h3 id="41、说一下-HashSet-的实现原理？"><a href="#41、说一下-HashSet-的实现原理？" class="headerlink" title="41、说一下 HashSet 的实现原理？"></a>41、说一下 HashSet 的实现原理？</h3><p>HashSet实际上是一个HashMap实例，数据存储结构都是数组+链表。</p>
<p>HashSet是基于HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value都是一个统一的对象PRESENT。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>HashSet中add方法调用的是底层HashMap中的put方法，put方法要判断插入值是否存在，而HashSet的add方法，首先判断元素是否存在，如果存在则插入，如果不存在则不插入，这样就保证了HashSet中不存在重复值。</p>
<p>通过对象的hashCode和equals方法保证对象的唯一性。</p>
<p>ArrayList是动态数组的数据结构实现，查找和遍历的效率较高；</p>
<p>LinkedList 是双向链表的数据结构，增加和删除的效率较高；</p>
<h3 id="43、如何实现数组和-List-之间的转换？"><a href="#43、如何实现数组和-List-之间的转换？" class="headerlink" title="43、如何实现数组和 List 之间的转换？"></a>43、如何实现数组和 List 之间的转换？</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = {<span class="string">"zs"</span>,<span class="string">"ls"</span>,<span class="string">"ww"</span>};</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list1.add(<span class="string">"张三"</span>);</span><br><span class="line">list1.add(<span class="string">"李四"</span>);</span><br><span class="line">list1.add(<span class="string">"王五"</span>);</span><br><span class="line">String[] arr1 = list1.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list1.size()]);</span><br><span class="line">System.out.println(arr1);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++){</span><br><span class="line">    System.out.println(arr1[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="44、在-Queue-中-poll-和-remove-有什么区别？"><a href="#44、在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="44、在 Queue 中 poll()和 remove()有什么区别？"></a>44、在 Queue 中 poll()和 remove()有什么区别？</h3><p>（1）offer()和add()区别：</p>
<p>增加新项时，如果队列满了，add会抛出异常，offer返回false。</p>
<p>（2）poll()和remove()区别：</p>
<p>poll()和remove()都是从队列中删除第一个元素，remove抛出异常，poll返回null。</p>
<p>（3）peek()和element（）区别：</p>
<p>peek()和element（）用于查询队列头部元素，为空时element抛出异常，peek返回null。</p>
<h3 id="45、哪些集合类是线程安全的"><a href="#45、哪些集合类是线程安全的" class="headerlink" title="45、哪些集合类是线程安全的"></a>45、哪些集合类是线程安全的</h3><p>Vector：就比Arraylist多了个同步化机制（线程安全）。<br>Stack：栈，也是线程安全的，继承于Vector。<br>Hashtable：就比Hashmap多了个线程安全。<br>ConcurrentHashMap:是一种高效但是线程安全的集合。</p>
<h3 id="46、迭代器-Iterator-是什么？"><a href="#46、迭代器-Iterator-是什么？" class="headerlink" title="46、迭代器 Iterator 是什么？"></a>46、迭代器 Iterator 是什么？</h3><p>为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator)。</p>
<h3 id="47、Iterator-怎么使用？有什么特点？"><a href="#47、Iterator-怎么使用？有什么特点？" class="headerlink" title="47、Iterator 怎么使用？有什么特点？"></a>47、Iterator 怎么使用？有什么特点？</h3><p>Iterator 接口源码中的方法：</p>
<ol>
<li>java.lang.Iterable 接口被 java.util.Collection 接口继承，java.util.Collection 接口的 iterator() 方法返回一个 Iterator 对象</li>
<li>next() 方法获得集合中的下一个元素</li>
<li>hasNext() 检查集合中是否还有元素</li>
<li>remove() 方法将迭代器新返回的元素删除</li>
</ol>
<h3 id="48、Iterator-和-ListIterator-有什么区别？"><a href="#48、Iterator-和-ListIterator-有什么区别？" class="headerlink" title="48、Iterator 和 ListIterator 有什么区别？"></a>48、Iterator 和 ListIterator 有什么区别？</h3><p>（1）ListIterator 继承 Iterator</p>
<p>（2）ListIterator 比 Iterator多方法</p>
<ol>
<li>add(E e) 将指定的元素插入列表，插入位置为迭代器当前位置之前</li>
<li>set(E e) 迭代器返回的最后一个元素替换参数e</li>
<li>hasPrevious() 迭代器当前位置，反向遍历集合是否含有元素</li>
<li>previous() 迭代器当前位置，反向遍历集合，下一个元素</li>
<li>previousIndex() 迭代器当前位置，反向遍历集合，返回下一个元素的下标</li>
<li>nextIndex() 迭代器当前位置，返回下一个元素的下标</li>
</ol>
<p>（3）使用范围不同，Iterator可以迭代所有集合；ListIterator 只能用于List及其子类</p>
<ol>
<li>ListIterator 有 add 方法，可以向 List 中添加对象；Iterator 不能</li>
<li>ListIterator 有 hasPrevious() 和 previous() 方法，可以实现逆向遍历；Iterator不可以</li>
<li>ListIterator 有 nextIndex() 和previousIndex() 方法，可定位当前索引的位置；Iterator不可以</li>
<li>ListIterator 有 set()方法，可以实现对 List 的修改；Iterator 仅能遍历，不能修改。</li>
</ol>
<h3 id="49、怎么确保一个集合不能被修改？"><a href="#49、怎么确保一个集合不能被修改？" class="headerlink" title="49、怎么确保一个集合不能被修改？"></a>49、怎么确保一个集合不能被修改？</h3><p>我们很容易想到用final关键字进行修饰，我们都知道</p>
<p>final关键字可以修饰类，方法，成员变量，final修饰的类不能被继承，final修饰的方法不能被重写，final修饰的成员变量必须初始化值，如果这个成员变量是基本数据类型，表示这个变量的值是不可改变的，如果说这个成员变量是引用类型，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变的。</p>
<p>那么，我们怎么确保一个集合不能被修改？首先我们要清楚，集合（map,set,list…）都是引用类型，所以我们如果用final修饰的话，集合里面的内容还是可以修改的。</p>
<p>我们可以做一个实验：</p>
<p>可以看到：我们用final关键字定义了一个map集合，这时候我们往集合里面传值，第一个键值对1,1；我们再修改后，可以把键为1的值改为100，说明我们是可以修改map集合的值的。</p>
<p>那我们应该怎么做才能确保集合不被修改呢？<br>我们可以采用Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。</p>
<p>同理：Collections包也提供了对list和set集合的方法。</p>
<p>Collections.unmodifiableList(List)<br>Collections.unmodifiableSet(Set)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/2021080116342771.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<h3 id="50、队列和栈是什么？有什么区别？"><a href="#50、队列和栈是什么？有什么区别？" class="headerlink" title="50、队列和栈是什么？有什么区别？"></a>50、队列和栈是什么？有什么区别？</h3><p>（1）队列先进先出，栈先进后出。</p>
<p>（2）遍历数据速度不同。</p>
<p>栈只能从头部取数据 也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性；</p>
<p>队列则不同，他基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的多。</p>
<h3 id="51、Java8开始ConcurrentHashMap-为什么舍弃分段锁？"><a href="#51、Java8开始ConcurrentHashMap-为什么舍弃分段锁？" class="headerlink" title="51、Java8开始ConcurrentHashMap,为什么舍弃分段锁？"></a>51、Java8开始ConcurrentHashMap,为什么舍弃分段锁？</h3><p>ConcurrentHashMap的原理是引用了内部的 Segment ( ReentrantLock ) 分段锁，保证在操作不同段 map 的时候， 可以并发执行， 操作同段 map 的时候，进行锁的竞争和等待。从而达到线程安全， 且效率大于 synchronized。</p>
<p>但是在 Java 8 之后， JDK 却弃用了这个策略，重新使用了 synchronized+CAS。</p>
<p>弃用原因</p>
<p>通过 JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点：</p>
<p>加入多个分段锁浪费内存空间。<br>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。<br>为了提高 GC 的效率<br>新的同步方案</p>
<p>既然弃用了分段锁， 那么一定由新的线程安全方案， 我们来看看源码是怎么解决线程安全的呢？（源码保留了segment 代码， 但并没有使用）。</p>
<h3 id="52、ConcurrentHashMap-JDK1-8-为什么要使用synchronized而不是如ReentranLock这样的可重入锁？"><a href="#52、ConcurrentHashMap-JDK1-8-为什么要使用synchronized而不是如ReentranLock这样的可重入锁？" class="headerlink" title="52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？"></a>52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？</h3><p>我想从下面几个角度讨论这个问题：</p>
<p>（1）锁的粒度</p>
<p>首先锁的粒度并没有变粗，甚至变得更细了。每当扩容一次，ConcurrentHashMap的并发度就扩大一倍。</p>
<p>（2）Hash冲突</p>
<p>JDK1.7中，ConcurrentHashMap从过二次hash的方式（Segment -&gt; HashEntry）能够快速的找到查找的元素。在1.8中通过链表加红黑树的形式弥补了put、get时的性能差距。<br>JDK1.8中，在ConcurrentHashmap进行扩容时，其他线程可以通过检测数组中的节点决定是否对这条链表（红黑树）进行扩容，减小了扩容的粒度，提高了扩容的效率。</p>
<p>下面是我对面试中的那个问题的一下看法。</p>
<p>为什么是synchronized，而不是ReentranLock</p>
<p>（1）减少内存开销</p>
<p>假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</p>
<p>（2）获得JVM的支持</p>
<p>可重入锁毕竟是API这个级别的，后续的性能优化空间很小。<br>synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</p>
<h3 id="53、concurrentHashMap和HashTable有什么区别"><a href="#53、concurrentHashMap和HashTable有什么区别" class="headerlink" title="53、concurrentHashMap和HashTable有什么区别"></a>53、concurrentHashMap和HashTable有什么区别</h3><p>concurrentHashMap融合了hashmap和hashtable的优势，hashmap是不同步的，但是单线程情况下效率高，hashtable是同步的同步情况下保证程序执行的正确性。</p>
<p>但hashtable每次同步执行的时候都要锁住整个结构，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801163535297.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p>concurrentHashMap锁的方式是细粒度的。concurrentHashMap将hash分为16个桶（默认值），诸如get、put、remove等常用操作只锁住当前需要用到的桶。</p>
<p>concurrentHashMap的读取并发，因为读取的大多数时候都没有锁定，所以读取操作几乎是完全的并发操作，只是在求size时才需要锁定整个hash。</p>
<p>而且在迭代时，concurrentHashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，弱一致迭代器。在这种方式中，当iterator被创建后集合再发生改变就不会抛出ConcurrentModificationException，取而代之的是在改变时new新的数据而不是影响原来的数据，iterator完成后再讲头指针替代为新的数据，这样iterator时使用的是原来的数据。</p>
<h3 id="54、HasmMap和HashSet的区别"><a href="#54、HasmMap和HashSet的区别" class="headerlink" title="54、HasmMap和HashSet的区别"></a>54、HasmMap和HashSet的区别</h3><p>（1）先了解一下HashCode</p>
<p>Java中的集合有两类，一类是List，一类是Set。</p>
<p>List：元素有序，可以重复；</p>
<p>Set：元素无序，不可重复；</p>
<p>要想保证元素的不重复，拿什么来判断呢？这就是Object.equals方法了。如果元素有很多，增加一个元素，就要判断n次吗？</p>
<p>显然不现实，于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是将数据依特定算法直接指定到一根地址上，初学者可以简单的理解为，HashCode方法返回的就是对象存储的物理位置（实际上并不是）。</p>
<p>这样一来，当集合添加新的元素时，先调用这个元素的hashcode()方法，就一下子能定位到他应该放置的物理位置上。如果这个位置上没有元素，他就可以直接存储在这个位置上，不用再进行任何比较了。如果这个位置上有元素，就调用它的equals方法与新元素进行比较，想同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际上调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
<p>简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率。</p>
<p>Java对象的equals方法和hashCode方法时这样规定的：</p>
<p>相等的对象就必须具有相等的hashcode。</p>
<ol>
<li>如果两个对象的hashcode相同，他们并不一定相同。</li>
<li>如果两个对象的hashcode相同，他们并不一定相同。</li>
</ol>
<p>如果两个Java对象A和B，A和B不相等，但是A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同，这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用规则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法避免哈希冲突。</p>
<p>equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。</p>
<p>（2）HashMap和HashSet的区别</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801163631659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801163653626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<h3 id="55、请谈谈-ReadWriteLock-和-StampedLock"><a href="#55、请谈谈-ReadWriteLock-和-StampedLock" class="headerlink" title="55、请谈谈 ReadWriteLock 和 StampedLock"></a>55、请谈谈 ReadWriteLock 和 StampedLock</h3><p>ReadWriteLock包括两种子锁</p>
<p>（1）ReadWriteLock</p>
<p>ReadWriteLock 可以实现多个读锁同时进行，但是读与写和写于写互斥，只能有一个写锁线程在进行。</p>
<p>（2）StampedLock</p>
<p>StampedLock是Jdk在1.8提供的一种读写锁，相比较ReentrantReadWriteLock性能更好，因为ReentrantReadWriteLock在读写之间是互斥的，使用的是一种悲观策略，在读线程特别多的情况下，会造成写线程处于饥饿状态，虽然可以在初始化的时候设置为true指定为公平，但是吞吐量又下去了，而StampedLock是提供了一种乐观策略，更好的实现读写分离，并且吞吐量不会下降。</p>
<p>StampedLock包括三种锁：</p>
<p>（1）写锁writeLock：</p>
<p>writeLock是一个独占锁写锁，当一个线程获得该锁后，其他请求读锁或者写锁的线程阻塞， 获取成功后，会返回一个stamp（凭据）变量来表示该锁的版本，在释放锁时调用unlockWrite方法传递stamp参数。提供了非阻塞式获取锁tryWriteLock。</p>
<p>（2）悲观读锁readLock：</p>
<p>readLock是一个共享读锁，在没有线程获取写锁情况下，多个线程可以获取该锁。如果有写锁获取，那么其他线程请求读锁会被阻塞。悲观读锁会认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据进行加锁，这是在读少写多的情况下考虑的。请求该锁成功后会返回一个stamp值，在释放锁时调用unlockRead方法传递stamp参数。提供了非阻塞式获取锁方法tryWriteLock。</p>
<p>（3）乐观读锁tryOptimisticRead：</p>
<p>tryOptimisticRead相对比悲观读锁，在操作数据前并没有通过CAS设置锁的状态，如果没有线程获取写锁，则返回一个非0的stamp变量，获取该stamp后在操作数据前还需要调用validate方法来判断期间是否有线程获取了写锁，如果是返回值为0则有线程获取写锁，如果不是0则可以使用stamp变量的锁来操作数据。由于tryOptimisticRead并没有修改锁状态，所以不需要释放锁。这是读多写少的情况下考虑的，不涉及CAS操作，所以效率较高，在保证数据一致性上需要复制一份要操作的变量到方法栈中，并且在操作数据时可能其他写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性得到了保证。</p>
<h3 id="56、线程的run-和start-有什么区别？"><a href="#56、线程的run-和start-有什么区别？" class="headerlink" title="56、线程的run()和start()有什么区别？"></a>56、线程的run()和start()有什么区别？</h3><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<p>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<h3 id="57、为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#57、为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="57、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>57、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p>
<p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p>
<h3 id="58、Synchronized-用过吗，其原理是什么？"><a href="#58、Synchronized-用过吗，其原理是什么？" class="headerlink" title="58、Synchronized 用过吗，其原理是什么？"></a>58、Synchronized 用过吗，其原理是什么？</h3><p>（1）可重入性</p>
<p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁；</p>
<ol>
<li>可重入的好处：</li>
<li>可以避免死锁；</li>
<li>可以让我们更好的封装代码；</li>
</ol>
<p>synchronized是可重入锁，每部锁对象会有一个计数器记录线程获取几次锁，在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。</p>
<p>（2）不可中断性</p>
<ol>
<li>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直阻塞或等待，不可被中断；</li>
<li>synchronized 属于不可被中断；</li>
<li>Lock lock方法是不可中断的；</li>
<li>Lock tryLock方法是可中断的；</li>
</ol>
<h3 id="59、JVM-对-Java-的原生锁做了哪些优化？"><a href="#59、JVM-对-Java-的原生锁做了哪些优化？" class="headerlink" title="59、JVM 对 Java 的原生锁做了哪些优化？"></a>59、JVM 对 Java 的原生锁做了哪些优化？</h3><p>（1）自旋锁</p>
<p>在线程进行阻塞的时候，先让线程自旋等待一段时间，可能这段时间其它线程已经解锁，这时就无需让线程再进行阻塞操作了。</p>
<p>自旋默认次数是10次。</p>
<p>（2）自适应自旋锁</p>
<p>自旋锁的升级，自旋的次数不再固定，由前一次自旋次数和锁的拥有者的状态决定。</p>
<p>（3）锁消除</p>
<p>在动态编译同步代码块的时候，JIT编译器借助逃逸分析技术来判断锁对象是否只被一个线程访问，而没有其他线程，这时就可以取消锁了。</p>
<p>4、锁粗化</p>
<p>当JIT编译器发现一系列的操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环中，此时会将加锁同步的范围粗化到整个操作系列的外部。</p>
<p>锁粒度：不要锁住一些无关的代码。</p>
<p>锁粗化：可以一次性执行完的不要多次加锁执行。</p>
<h3 id="60、为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#60、为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="60、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>60、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h3><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p>
<p>wait(), notify()和 notifyAll()这些方法在同步代码块中调用</p>
<p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p>
<p>综上所述，wait()、notify()和notifyAll()方法要定义在Object类中。</p>
<h3 id="61、Java-如何实现多线程之间的通讯和协作？"><a href="#61、Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="61、Java 如何实现多线程之间的通讯和协作？"></a>61、Java 如何实现多线程之间的通讯和协作？</h3><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</p>
<p>比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p>
<p>Java中线程通信协作的最常见的两种方式：</p>
<p>1、syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()</p>
<p>2、ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()</p>
<p>线程间直接的数据交换：</p>
<p>通过管道进行线程间通信：1）字节流；2）字符流</p>
<h3 id="62、Thread-类中的-yield-方法有什么作用？"><a href="#62、Thread-类中的-yield-方法有什么作用？" class="headerlink" title="62、Thread 类中的 yield 方法有什么作用？"></a>62、Thread 类中的 yield 方法有什么作用？</h3><p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<p>结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。</p>
<h3 id="63、为什么说-Synchronized-是非公平锁？"><a href="#63、为什么说-Synchronized-是非公平锁？" class="headerlink" title="63、为什么说 Synchronized 是非公平锁？"></a>63、为什么说 Synchronized 是非公平锁？</h3><p>当锁被释放后，任何一个线程都有机会竞争得到锁，这样做的目的是提高效率，但缺点是可能产生线程饥饿现象。</p>
<h3 id="64、请谈谈-volatile-有什么特点，为什么它能保证变量对所有线程的可见性？"><a href="#64、请谈谈-volatile-有什么特点，为什么它能保证变量对所有线程的可见性？" class="headerlink" title="64、请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？"></a>64、请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？</h3><p>volatile只能作用于变量，保证了操作可见性和有序性，不保证原子性。</p>
<p>在Java的内存模型中分为主内存和工作内存，Java内存模型规定所有的变量存储在主内存中，每条线程都有自己的工作内存。</p>
<p>主内存和工作内存之间的交互分为8个原子操作：</p>
<ol>
<li>lock</li>
<li>unlock</li>
<li>read</li>
<li>load</li>
<li>assign</li>
<li>use</li>
<li>store</li>
<li>write</li>
</ol>
<p>volatile修饰的变量，只有对volatile进行assign操作，才可以load，只有load才可以use，，这样就保证了在工作内存操作volatile变量，都会同步到主内存中。</p>
<h3 id="65、为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？"><a href="#65、为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？" class="headerlink" title="65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？"></a>65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</h3><p>Synchronized的并发策略是悲观的，不管是否产生竞争，任何数据的操作都必须加锁。</p>
<p>乐观锁的核心是CAS，CAS包括内存值、预期值、新值，只有当内存值等于预期值时，才会将内存值修改为新值。</p>
<h3 id="66、乐观锁一定就是好的吗？"><a href="#66、乐观锁一定就是好的吗？" class="headerlink" title="66、乐观锁一定就是好的吗？"></a>66、乐观锁一定就是好的吗？</h3><p>乐观锁认为对一个对象的操作不会引发冲突，所以每次操作都不进行加锁，只是在最后提交更改时验证是否发生冲突，如果冲突则再试一遍，直至成功为止，这个尝试的过程称为自旋。</p>
<p>乐观锁没有加锁，但乐观锁引入了ABA问题，此时一般采用版本号进行控制；<br>也可能产生自旋次数过多问题，此时并不能提高效率，反而不如直接加锁的效率高；<br>只能保证一个对象的原子性，可以封装成对象，再进行CAS操作；</p>
<h3 id="67、请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。"><a href="#67、请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。" class="headerlink" title="67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。"></a>67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。</h3><p>（1）相似点</p>
<p>它们都是阻塞式的同步，也就是说一个线程获得了对象锁，进入代码块，其它访问该同步块的线程都必须阻塞在同步代码块外面等待，而进行线程阻塞和唤醒的代码是比较高的。</p>
<p>（2）功能区别</p>
<p>Synchronized是java语言的关键字，是原生语法层面的互斥，需要JVM实现；ReentrantLock 是JDK1.5之后提供的API层面的互斥锁，需要lock和unlock()方法配合try/finally代码块来完成。<br>Synchronized使用较ReentrantLock 便利一些；<br>锁的细粒度和灵活性：ReentrantLock强于Synchronized；</p>
<p>（3）性能区别</p>
<p>Synchronized引入偏向锁，自旋锁之后，两者的性能差不多，在这种情况下，官方建议使用Synchronized。</p>
<p>① Synchronized</p>
<p>Synchronized会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。</p>
<p>在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计数器+1，相应的执行monitorexit时，计数器-1，当计数器为0时，锁就会被释放。如果获取锁失败，当前线程就要阻塞，知道对象锁被另一个线程释放为止。</p>
<p>② ReentrantLock</p>
<p>ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有如下三项：</p>
<p>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized避免出现死锁的情况。通过lock.lockInterruptibly()来实现这一机制；<br>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁是非公平锁；ReentrantLock默认也是非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好；<br>锁绑定多个条件，一个ReentrantLock对象可以同时绑定多个对象。ReentrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像Synchronized要么随机唤醒一个线程，要么唤醒全部线程。</p>
<h3 id="68、ReentrantLock-是如何实现可重入性的？"><a href="#68、ReentrantLock-是如何实现可重入性的？" class="headerlink" title="68、ReentrantLock 是如何实现可重入性的？"></a>68、ReentrantLock 是如何实现可重入性的？</h3><p>（1）什么是可重入性</p>
<p>一个线程持有锁时，当其他线程尝试获取该锁时，会被阻塞；而这个线程尝试获取自己持有锁时，如果成功说明该锁是可重入的，反之则不可重入。</p>
<p>（2）synchronized是如何实现可重入性</p>
<p>synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。每个锁对象内部维护一个计数器，该计数器初始值为0，表示任何线程都可以获取该锁并执行相应的方法。根据虚拟机规范要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了对象的锁，把锁的计数器+1，相应的在执行monitorexit指令后锁计数器-1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p>
<p>（3）ReentrantLock如何实现可重入性</p>
<p>ReentrantLock使用内部类Sync来管理锁，所以真正的获取锁是由Sync的实现类控制的。Sync有两个实现，分别为NonfairSync（非公公平锁）和FairSync（公平锁）。Sync通过继承AQS实现，在AQS中维护了一个private volatile int state来计算重入次数，避免频繁的持有释放操作带来的线程问题。</p>
<p>（4）ReentrantLock代码实例</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync继承于AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> {</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">// ReentrantLock默认是非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> {</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line"> }</span><br><span class="line"><span class="comment">// 可以通过向构造方法中传true来实现公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> {</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> {</span><br><span class="line">        <span class="comment">// 当前想要获取锁的线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 当前锁的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">            <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">                <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">                <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">          <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">        <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>（5）代码分析</p>
<p>当一个线程在获取锁过程中，先判断state的值是否为0，如果是表示没有线程持有锁，就可以尝试获取锁。<br>当state的值不为0时，表示锁已经被一个线程占用了，这时会做一个判断current==getExclusiveOwnerThread()，这个方法返回的是当前持有锁的线程，这个判断是看当前持有锁的线程是不是自己，如果是自己，那么将state的值+1，表示重入返回即可。</p>
<h3 id="69、什么是锁消除和锁粗化？"><a href="#69、什么是锁消除和锁粗化？" class="headerlink" title="69、什么是锁消除和锁粗化？"></a>69、什么是锁消除和锁粗化？</h3><p>（1）锁消除</p>
<p>所消除就是虚拟机根据一个对象是否真正存在同步情况，若不存在同步情况，则对该对象的访问无需经过加锁解锁的操作。</p>
<p>比如StringBuffer的append方法，因为append方法需要判断对象是否被占用，而如果代码不存在锁竞争，那么这部分的性能消耗是无意义的。于是虚拟机在即时编译的时候就会将上面的代码进行优化，也就是锁消除。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> {</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从源码可以看出，append方法用了 synchronized关键字，它是线程安全的。但我们可能仅在线程内部把StringBuffer当做局部变量使用；StringBuffer仅在方法内作用域有效，不存在线程安全的问题，这时我们可以通过编译器将其优化，将锁消除，前提是Java必须运行在server模式，同时必须开启逃逸分析；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br><span class="line"></span><br><span class="line">其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String str1, String str2)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sBuf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sBuf.append(str1);<span class="comment">// append方法是同步操作</span></span><br><span class="line">    sBuf.append(str2);</span><br><span class="line">    <span class="keyword">return</span> sBuf.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>逃逸分析：比如上面的代码，它要看sBuf是否可能逃出它的作用域？如果将sBuf作为方法的返回值进行返回，那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题，这时就可以说sBuf这个对象发生逃逸了，因而不应将append操作的锁消除，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。</p>
<p>（2）锁粗化</p>
<p>锁的请求、同步、释放都会消耗一定的系统资源，如果高频的锁请求反而不利于系统性能的优化，锁粗化就是把多次的锁请求合并成一个请求，扩大锁的范围，降低锁请求、同步、释放带来的性能损耗。</p>
<h3 id="70、跟-Synchronized-相比，可重入锁-ReentrantLock-其实现原理有什么不同？"><a href="#70、跟-Synchronized-相比，可重入锁-ReentrantLock-其实现原理有什么不同？" class="headerlink" title="70、跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？"></a>70、跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？</h3><p>（1）都是可重入锁；</p>
<p>（2）ReentrantLock内部是实现了Sync，Sync继承于AQS抽象类。Sync有两个实现，一个是公平锁，一个是非公平锁，通过构造函数定义。AQS中维护了一个state来计算重入次数，避免频繁的持有释放操作带来的线程问题。</p>
<p>（3）ReentrantLock只能定义代码块，而Synchronized可以定义方法和代码块；</p>
<p>4、Synchronized是JVM的一个内部关键字，ReentrantLock是JDK1.5之后引入的一个API层面的互斥锁；</p>
<p>5、Synchronized实现自动的加锁、释放锁，ReentrantLock需要手动加锁和释放锁，中间可以暂停；</p>
<p>6、Synchronized由于引进了偏向锁和自旋锁，所以性能上和ReentrantLock差不多，但操作上方便很多，所以优先使用Synchronized。</p>
<h3 id="71、那么请谈谈-AQS-框架是怎么回事儿？"><a href="#71、那么请谈谈-AQS-框架是怎么回事儿？" class="headerlink" title="71、那么请谈谈 AQS 框架是怎么回事儿？"></a>71、那么请谈谈 AQS 框架是怎么回事儿？</h3><p>（1）AQS是AbstractQueuedSynchronizer的缩写，它提供了一个FIFO队列，可以看成是一个实现同步锁的核心组件。</p>
<p>AQS是一个抽象类，主要通过继承的方式来使用，它本身没有实现任何的同步接口，仅仅是定义了同步状态的获取和释放的方法来提供自定义的同步组件。</p>
<p>（2）AQS的两种功能：独占锁和共享锁</p>
<p>（3）AQS的内部实现</p>
<p>AQS的实现依赖内部的同步队列，也就是FIFO的双向队列，如果当前线程竞争失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点（线程）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801171611775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p>AQS队列内部维护的是一个FIFO的双向链表，这种结构的特点是每个数据结构都有两个指针，分别指向直接的后继节点和直接前驱节点。所以双向链表可以从任意一个节点开始很方便的范文前驱和后继节点。每个Node其实是由线程封装，当线程争抢锁失败后会封装成Node加入到AQS队列中。</p>
<h3 id="72、AQS-对资源的共享方式？"><a href="#72、AQS-对资源的共享方式？" class="headerlink" title="72、AQS 对资源的共享方式？"></a>72、AQS 对资源的共享方式？</h3><p>AQS定义两种资源共享方式</p>
<p>（1）Exclusive（独占）</p>
<p>只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</p>
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
<p>（2）Share（共享）</p>
<p>多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p>
<p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p>
<h3 id="73、如何让-Java-的线程彼此同步？"><a href="#73、如何让-Java-的线程彼此同步？" class="headerlink" title="73、如何让 Java 的线程彼此同步？"></a>73、如何让 Java 的线程彼此同步？</h3><ol>
<li>synchronized</li>
<li>volatile</li>
<li>ReenreantLock</li>
<li>使用局部变量实现线程同步</li>
</ol>
<h3 id="74、你了解过哪些同步器？请分别介绍下。"><a href="#74、你了解过哪些同步器？请分别介绍下。" class="headerlink" title="74、你了解过哪些同步器？请分别介绍下。"></a>74、你了解过哪些同步器？请分别介绍下。</h3><p>（1）Semaphore同步器</p>
<p>特征：</p>
<p>经典的信号量，通过计数器控制对共享资源的访问<br>Semaphore(int count):创建拥有count个许可证的信号量<br>acquire()/acquire(int num) : 获取1/num个许可证<br>release/release(int num) : 释放1/num个许可证</p>
<p>（2）CountDownLatch同步器</p>
<p>特征：</p>
<p>必须发生指定数量的事件后才可以继续运行(比如赛跑比赛，裁判喊出3,2,1之后大家才同时跑)<br>CountDownLatch(int count):必须发生count个数量才可以打开锁存器<br>await:等待锁存器<br>countDown:触发事件</p>
<p>（3）CyclicBarrier同步器</p>
<p>特征：</p>
<p>适用于只有多个线程都到达预定点时才可以继续执行(比如斗地主，需要等齐三个人才开始)<br>CyclicBarrier(int num) :等待线程的数量<br>CyclicBarrier(int num, Runnable action) :等待线程的数量以及所有线程到达后的操作<br>await() : 到达临界点后暂停线程</p>
<p>（4）交换器(Exchanger)同步器</p>
<p>（5）Phaser同步器</p>
<h3 id="75、Java-中的线程池是如何实现的"><a href="#75、Java-中的线程池是如何实现的" class="headerlink" title="75、Java 中的线程池是如何实现的"></a>75、Java 中的线程池是如何实现的</h3><p>创建一个阻塞队列来容纳任务，在第一次执行任务时创建足够多的线程，并处理任务，之后每个工作线程自动从任务队列中获取线程，直到任务队列中任务为0为止，此时线程处于等待状态，一旦有工作任务加入任务队列中，即刻唤醒工作线程进行处理，实现线程的可复用性。</p>
<p>线程池一般包括四个基本组成部分：</p>
<p>（1）线程池管理器</p>
<p>用于创建线程池，销毁线程池，添加新任务。</p>
<p>（2）工作线程</p>
<p>线程池中线程，可循环执行任务，在没有任务时处于等待状态。</p>
<p>（3）任务队列</p>
<p>用于存放没有处理的任务，一种缓存机制。</p>
<p>（4）任务接口</p>
<p>每个任务必须实现的接口，供工作线程调度任务的执行，主要规定了任务的开始和收尾工作，和任务的状态。</p>
<h3 id="76、创建线程池的几个核心构造参数"><a href="#76、创建线程池的几个核心构造参数" class="headerlink" title="76、创建线程池的几个核心构造参数"></a>76、创建线程池的几个核心构造参数</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java线程池的完整构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> corePoolSize, // 线程池长期维持的最小线程数，即使线程处于Idle状态，也不会回收。</span></span><br><span class="line"><span class="params">  <span class="type">int</span> maximumPoolSize, // 线程数的上限</span></span><br><span class="line"><span class="params">  <span class="type">long</span> keepAliveTime, // 线程最大生命周期。</span></span><br><span class="line"><span class="params">  TimeUnit unit, //时间单位</span></span><br><span class="line"><span class="params">  BlockingQueue workQueue, //任务队列。当线程池中的线程都处于运行状态，而此时任务数量继续增加，则需要一个容器来容纳这些任务，这就是任务队列。</span></span><br><span class="line"><span class="params">  ThreadFactory threadFactory, // 线程工厂。定义如何启动一个线程，可以设置线程名称，并且可以确认是否是后台线程等。</span></span><br><span class="line"><span class="params">  RejectedExecutionHandler handler // 拒绝任务处理器。由于超出线程数量和队列容量而对继续增加的任务进行处理的程序。</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？"><a href="#77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？" class="headerlink" title="77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？"></a>77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？</h3><p>线程池中的线程是在第一次提交任务submit时创建的</p>
<p>创建线程的方式有继承Thread和实现Runnable，重写run方法，start开始执行，wait等待，sleep休眠，shutdown停止。</p>
<p>（1）newSingleThreadExecutor：单线程池。</p>
<p>顾名思义就是一个池中只有一个线程在运行，该线程永不超时，而且由于是一个线程，当有多个任务需要处理时，会将它们放置到一个无界阻塞队列中逐个处理，它的实现代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span></span><br></pre></td></tr></tbody></table></figure>

<p>它的使用方法也很简单，下面是简单的示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,InterruptedException {</span><br><span class="line">    <span class="comment">// 创建单线程执行器</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="comment">// 执行一个任务</span></span><br><span class="line">    <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="comment">// 获得任务执行后的返回值</span></span><br><span class="line">    System.out.println(<span class="string">"返回值："</span> + future.get());</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    es.shutdown();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>（2）newCachedThreadPool：缓冲功能的线程。</p>
<p>建立了一个线程池，而且线程数量是没有限制的(当然，不能超过Integer的最大值)，新增一个任务即有一个线程处理，或者复用之前空闲的线程，或者重亲启动一个线程，但是一旦一个线程在60秒内一直处于等待状态时（也就是一分钟无事可做），则会被终止，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里需要说明的是，任务队列使用了同步阻塞队列，这意味着向队列中加入一个元素，即可唤醒一个线程(新创建的线程或复用空闲线程来处理)，这种队列已经没有队列深度的概念了。</p>
<p>（3）newFixedThreadPool：固定线程数量的线程池。</p>
<p>在初始化时已经决定了线程的最大数量，若任务添加的能力超出了线程的处理能力，则建立阻塞队列容纳多余的任务，其源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面返回的是一个ThreadPoolExecutor，它的corePoolSize和maximumPoolSize是相等的，也就是说，最大线程数量为nThreads。如果任务增长的速度非常快，超过了LinkedBlockingQuene的最大容量(Integer的最大值)，那此时会如何处理呢？会按照ThreadPoolExecutor默认的拒绝策略(默认是DiscardPolicy，直接丢弃)来处理。</p>
<p>以上三种线程池执行器都是ThreadPoolExecutor的简化版，目的是帮助开发人员屏蔽过得线程细节，简化多线程开发。当需要运行异步任务时，可以直接通过Executors获得一个线程池，然后运行任务，不需要关注ThreadPoolExecutor的一系列参数时什么含义。当然，有时候这三个线程不能满足要求，此时则可以直接操作ThreadPoolExecutor来实现复杂的多线程计算。</p>
<p>newSingleThreadExecutor、newCachedThreadPool、newFixedThreadPool是线程池的简化版，而ThreadPoolExecutor则是旗舰版___简化版容易操作，需要了解的知识相对少些，方便使用，而旗舰版功能齐全，适用面广，难以驾驭。</p>
<h3 id="78、volatile-关键字的作用"><a href="#78、volatile-关键字的作用" class="headerlink" title="78、volatile 关键字的作用"></a>78、volatile 关键字的作用</h3><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。</p>
<p>volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</p>
<h3 id="79、既然-volatile-能够保证线程间的变量可见性，是不是就意味着基于-volatile-变量的运算就是并发安全的？"><a href="#79、既然-volatile-能够保证线程间的变量可见性，是不是就意味着基于-volatile-变量的运算就是并发安全的？" class="headerlink" title="79、既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？"></a>79、既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？</h3><p>volatile修饰的变量在各个线程的工作内存中不存在一致性的问题（在各个线程工作的内存中，volatile修饰的变量也会存在不一致的情况，但是由于每次使用之前都会先刷新主存中的数据到工作内存，执行引擎看不到不一致的情况，因此可以认为不存在不一致的问题），但是java的运算并非原子性的操作，导致volatile在并发下并非是线程安全的。</p>
<h3 id="80、ThreadLocal-是什么？有哪些使用场景？"><a href="#80、ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="80、ThreadLocal 是什么？有哪些使用场景？"></a>80、ThreadLocal 是什么？有哪些使用场景？</h3><p>ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象，简单说 ThreadLocal 就是一种以空间换时间的做法，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享。</p>
<p>原理：线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<p>经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。</p>
<h3 id="81、请谈谈-ThreadLocal-是怎么解决并发安全的？"><a href="#81、请谈谈-ThreadLocal-是怎么解决并发安全的？" class="headerlink" title="81、请谈谈 ThreadLocal 是怎么解决并发安全的？"></a>81、请谈谈 ThreadLocal 是怎么解决并发安全的？</h3><p>在java程序中，常用的有两种机制来解决多线程并发问题，一种是sychronized方式，通过锁机制，一个线程执行时，让另一个线程等待，是以时间换空间的方式来让多线程串行执行。而另外一种方式就是ThreadLocal方式，通过创建线程局部变量，以空间换时间的方式来让多线程并行执行。两种方式各有优劣，适用于不同的场景，要根据不同的业务场景来进行选择。</p>
<p>在spring的源码中，就使用了ThreadLocal来管理连接，在很多开源项目中，都经常使用ThreadLocal来控制多线程并发问题，因为它足够的简单，我们不需要关心是否有线程安全问题，因为变量是每个线程所特有的。</p>
<h3 id="82、很多人都说要慎用-ThreadLocal，谈谈你的理解，使用-ThreadLocal-需要注意些什么？"><a href="#82、很多人都说要慎用-ThreadLocal，谈谈你的理解，使用-ThreadLocal-需要注意些什么？" class="headerlink" title="82、很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？"></a>82、很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？</h3><p>ThreadLocal 变量解决了多线程环境下单个线程中变量的共享问题，使用名为ThreadLocalMap的哈希表进行维护（key为ThreadLocal变量名，value为ThreadLocal变量的值）；</p>
<p>使用时需要注意以下几点：</p>
<ul>
<li>线程之间的threadLocal变量是互不影响的，</li>
<li>使用private final static进行修饰，防止多实例时内存的泄露问题</li>
<li>线程池环境下使用后将threadLocal变量remove掉或设置成一个初始值</li>
</ul>
<h3 id="83、为什么代码会重排序？"><a href="#83、为什么代码会重排序？" class="headerlink" title="83、为什么代码会重排序？"></a>83、为什么代码会重排序？</h3><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>
<ul>
<li>在单线程环境下不能改变程序运行的结果；</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
<p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>
<h3 id="84、什么是自旋"><a href="#84、什么是自旋" class="headerlink" title="84、什么是自旋"></a>84、什么是自旋</h3><p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
<h3 id="85、多线程中-synchronized-锁升级的原理是什么？"><a href="#85、多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="85、多线程中 synchronized 锁升级的原理是什么？"></a>85、多线程中 synchronized 锁升级的原理是什么？</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="86、synchronized-和-ReentrantLock-区别是什么？"><a href="#86、synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="86、synchronized 和 ReentrantLock 区别是什么？"></a>86、synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p>
<p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p>
<p>相同点：两者都是可重入锁</p>
<p>两者都是可重入锁。”可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p>主要区别如下：</p>
<ul>
<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>
<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
<li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li>
<li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word</li>
</ul>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ul>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的class对象</li>
<li>同步方法块，锁是括号里面的对象</li>
</ul>
<h3 id="87、Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#87、Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？"></a>87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<p>（1）可以使锁更公平</p>
<p>（2）可以使线程在等待锁的时候响应中断</p>
<p>（3）可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p>
<p>（4）可以在不同的范围，以不同的顺序获取和释放锁</p>
<p>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p>
<h3 id="88、jsp-和-servlet-有什么区别？"><a href="#88、jsp-和-servlet-有什么区别？" class="headerlink" title="88、jsp 和 servlet 有什么区别？"></a>88、jsp 和 servlet 有什么区别？</h3><p>（1）servlet是服务器端的Java程序，它担当客户端和服务端的中间层。</p>
<p>（2）jsp全名为Java server pages，中文名叫Java服务器页面，其本质是一个简化的servlet设计。JSP是一种动态页面设计，它的主要目的是将表示逻辑从servlet中分离出来。</p>
<p>（3）JVM只能识别Java代码，不能识别JSP，JSP编译后变成了servlet，web容器将JSP的代码编译成JVM能够识别的Java类（servlet）。</p>
<p>（4）JSP有内置对象、servlet没有内置对象。</p>
<h3 id="89、jsp-有哪些内置对象？作用分别是什么？"><a href="#89、jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="89、jsp 有哪些内置对象？作用分别是什么？"></a>89、jsp 有哪些内置对象？作用分别是什么？</h3><p>JSP九大内置对象：</p>
<ol>
<li>pageContext，页面上下文对象，相当于页面中所有功能的集合，通过它可以获取JSP页面的out、request、response、session、application对象。</li>
<li>request</li>
<li>response</li>
<li>session</li>
<li>application，应用程序对象，application实现了用户间数据的共享，可存放全局变量，它开始于服务器启动，知道服务器关闭。</li>
<li>page，就是JSP本身。</li>
<li>exception</li>
<li>out，out用于在web浏览器内输出信息，并且管理应用服务器上的输出缓冲区，作用域page。</li>
<li>config，取得服务器的配置信息。</li>
</ol>
<h3 id="90、forward-和-redirect-的区别？"><a href="#90、forward-和-redirect-的区别？" class="headerlink" title="90、forward 和 redirect 的区别？"></a>90、forward 和 redirect 的区别？</h3><ol>
<li>forward是直接请求转发；redirect是间接请求转发，又叫重定向。</li>
<li>forward，客户端和浏览器执行一次请求；redirect，客户端和浏览器执行两次请求。</li>
<li>forward，经典的MVC模式就是forward；redirect，用于避免用户的非正常访问。（例如用户非正常访问，servlet就可以将HTTP请求重定向到登录页面）。</li>
<li>forward，地址不变；redirect，地址改变。</li>
<li>forward常用方法：RequestDispatcher类的forward()方法；redirect常用方法：HttpServletRequest类的sendRedirect()方法。</li>
</ol>
<h3 id="91、说一下-jsp-的-4-种作用域？"><a href="#91、说一下-jsp-的-4-种作用域？" class="headerlink" title="91、说一下 jsp 的 4 种作用域？"></a>91、说一下 jsp 的 4 种作用域？</h3><p>application、session、request、page</p>
<h3 id="92、session-和-cookie-有什么区别？"><a href="#92、session-和-cookie-有什么区别？" class="headerlink" title="92、session 和 cookie 有什么区别？"></a>92、session 和 cookie 有什么区别？</h3><p>（1）存储位置不同</p>
<ul>
<li>cookie在客户端浏览器；</li>
<li>session在服务器；</li>
</ul>
<p>（2）存储容量不同</p>
<ul>
<li>cookie</li>
</ul>
<p>（3）存储方式不同</p>
<ul>
<li>cookie只能保存ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据；</li>
<li>session中能存储任何类型的数据，包括并不局限于String、integer、list、map等；</li>
</ul>
<p>（4）隐私策略不同</p>
<ul>
<li>cookie对客户端是可见的，不安全；</li>
<li>session存储在服务器上，安全；</li>
</ul>
<p>（5）有效期不同</p>
<ul>
<li>开发可以通过设置cookie的属性，达到使cookie长期有效的效果；</li>
<li>session依赖于名为JESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session达不到长期有效的效果；</li>
</ul>
<p>（6）跨域支持上不同</p>
<ul>
<li>cookie支持跨域；</li>
<li>session不支持跨域；</li>
</ul>
<h3 id="93、如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#93、如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="93、如果客户端禁止 cookie 能实现 session 还能用吗？"></a>93、如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>一般默认情况下，在会话中，服务器存储 session 的 sessionid 是通过 cookie 存到浏览器里。</p>
<p>如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，session失效。</p>
<p>但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用session。</p>
<ol>
<li>通过url重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中携带 sessionid 参数。</li>
<li>服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。</li>
<li>通过 Http 协议其他 header 字段，服务器每次返回时设置该 header 字段信息，浏览器中 js 读取该 header 字段，请求服务器时，js设置携带该 header 字段。</li>
</ol>
<h3 id="94、什么是上下文切换？"><a href="#94、什么是上下文切换？" class="headerlink" title="94、什么是上下文切换？"></a>94、什么是上下文切换？</h3><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h3 id="95、cookie、session、token"><a href="#95、cookie、session、token" class="headerlink" title="95、cookie、session、token"></a>95、cookie、session、token</h3><p>1、session机制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801175715748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p>session是服务端存储的一个对象，主要用来存储所有访问过该服务端的客户端的用户信息（也可以存储其他信息），从而实现保持用户会话状态。但是服务器重启时，内存会被销毁，存储的用户信息也就消失了。</p>
<p>不同的用户访问服务端的时候会在session对象中存储键值对，”键”用来存储开启这个用户信息的”钥匙”，在登录成功后，”钥匙”通过cookie返回给客户端，客户端存储为sessionId记录在cookie中。当客户端再次访问时，会默认携带cookie中的sessionId来实现会话机制。</p>
<p>（1）session是基于cookie的。</p>
<ul>
<li>cookie的数据4k左右；</li>
<li>cookie存储数据的格式：字符串key=value</li>
<li>cookie存储有效期：可以自行通过expires进行具体的日期设置，如果没设置，默认是关闭浏览器时失效。</li>
<li>cookie有效范围：当前域名下有效。所以session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上（前后端项目协议、域名、端口号都一致，即在一个项目下）</li>
</ul>
<p>（2）session持久化</p>
<p>用于解决重启服务器后session消失的问题。在数据库中存储session，而不是存储在内存中。通过包：express-mysql-session。</p>
<p>当客户端存储的cookie失效后，服务端的session不会立即销毁，会有一个延时，服务端会定期清理无效session，不会造成无效数据占用存储空间的问题。</p>
<p>2、token机制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801175804261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p>适用于前后端分离的项目（前后端代码运行在不同的服务器下）</p>
<p>请求登录时，token和sessionid原理相同，是对key和key对应的用户信息进行加密后的加密字符，登录成功后，会在响应主体中将{token：”字符串”}返回给客户端。</p>
<p>客户端通过cookie都可以进行存储。再次请求时不会默认携带，需要在请求拦截器位置给请求头中添加认证字段Authorization携带token信息，服务器就可以通过token信息查找用户登录状态。</p>
<h3 id="96、说一下-session-的工作原理？"><a href="#96、说一下-session-的工作原理？" class="headerlink" title="96、说一下 session 的工作原理？"></a>96、说一下 session 的工作原理？</h3><p>当客户端登录完成后，会在服务端产生一个session，此时服务端会将sessionid返回给客户端浏览器。客户端将sessionid储存在浏览器的cookie中，当用户再次登录时，会获得对应的sessionid，然后将sessionid发送到服务端请求登录，服务端在内存中找到对应的sessionid，完成登录，如果找不到，返回登录页面。</p>
<h3 id="97、http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#97、http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="97、http 响应码 301 和 302 代表的是什么？有什么区别？"></a>97、http 响应码 301 和 302 代表的是什么？有什么区别？</h3><ol>
<li>301和302状态码都表示重定向，当浏览器拿到服务器返回的这个状态码后悔自动跳转到一个新的URL地址。</li>
<li>301代表永久性重定向，旧地址被永久移除，客户端向新地址发送请求。</li>
<li>302代表暂时性重定向，旧地址还在，客户端继续向旧地址发送请求。</li>
<li>303代表暂时性重定向，重定向到新地址时，必须使用GET方法请求新地址。</li>
<li>307代表暂时性重定向，与302的区别在于307不允许从POST改为GET。</li>
<li>307代表永久性重定向，与301的区别在于308不允许从POST改为GET。</li>
</ol>
<h3 id="98、简述-tcp-和-udp的区别？"><a href="#98、简述-tcp-和-udp的区别？" class="headerlink" title="98、简述 tcp 和 udp的区别？"></a>98、简述 tcp 和 udp的区别？</h3><ol>
<li>TCP是传输控制协议，UDP是用户数据表协议；</li>
<li>TCP长连接，UDP无连接；</li>
<li>UDP程序结构较简单，只需发送，无须接收；</li>
<li>TCP可靠，保证数据正确性、顺序性；UDP不可靠，可能丢数据；</li>
<li>TCP适用于少量数据，UDP适用于大量数据传输；</li>
<li>TCP速度慢，UDP速度快；</li>
</ol>
<h3 id="99、tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#99、tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="99、tcp 为什么要三次握手，两次不行吗？为什么？"></a>99、tcp 为什么要三次握手，两次不行吗？为什么？</h3><p>因为客户端和服务端都要确认连接，①客户端请求连接服务端；②针对客户端的请求确认应答，并请求建立连接；③针对服务端的请求确认应答，建立连接；</p>
<p>两次无法确保A能收到B的数据；</p>
<h3 id="100、OSI-的七层模型都有哪些？"><a href="#100、OSI-的七层模型都有哪些？" class="headerlink" title="100、OSI 的七层模型都有哪些？"></a>100、OSI 的七层模型都有哪些？</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801175909518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<h3 id="101、get-和-post-请求有哪些区别？"><a href="#101、get-和-post-请求有哪些区别？" class="headerlink" title="101、get 和 post 请求有哪些区别？"></a>101、get 和 post 请求有哪些区别？</h3><ol>
<li>get请求参数是连接在url后面的,而post请求参数是存放在requestbody内的；</li>
<li>get请求因为浏览器对url长度有限制，所以参数个数有限制，而post请求参数个数没有限制；</li>
<li>因为get请求参数暴露在url上,所以安全方面post比get更加安全；</li>
<li>get请求只能进行url编码,而post请求可以支持多种编码方式；</li>
<li>get请求参数会保存在浏览器历史记录内,post请求并不会；</li>
<li>get请求浏览器会主动cache,post并不会,除非主动设置；</li>
<li>get请求产生1个tcp数据包,post请求产生2个tcp数据包；</li>
<li>在浏览器进行回退操作时,get请求是无害的,而post请求则会重新请求一次；</li>
<li>浏览器在发送get请求时会将header和data一起发送给服务器,服务器返回200状态码,而在发送post请求时,会先将header发送给服务器,服务器返回100,之后再将data发送给服务器,服务器返回200 OK；</li>
</ol>
<h3 id="102、什么是-XSS-攻击，如何避免？"><a href="#102、什么是-XSS-攻击，如何避免？" class="headerlink" title="102、什么是 XSS 攻击，如何避免？"></a>102、什么是 XSS 攻击，如何避免？</h3><p>xss(Cross Site Scripting)，即跨站脚本攻击，是一种常见于web应用程序中的计算机安全漏洞。指的是在用户浏览器上，在渲染DOM树的时候，执行了不可预期的JS脚本，从而发生了安全问题。</p>
<p>XSS就是通过在用户端注入恶意的可运行脚本，若服务端对用户的输入不进行处理，直接将用户的输入输出到浏览器，然后浏览器将会执行用户注入的脚本。 所以XSS攻击的核心就是浏览器渲染DOM的时候将文本信息解析成JS脚本从而引发JS脚本注入，那么XSS攻击的防御手段就是基于浏览器渲染这一步去做防御。只要我们使用HTML编码将浏览器需要渲染的信息编码后，浏览器在渲染DOM元素的时候，会自动解码需要渲染的信息，将上述信息解析成字符串而不是JS脚本，这就是我们防御XSS攻击的核心想法。</p>
<p>预防：</p>
<p>1、获取用户的输入，不用innerHtml,用innerText.</p>
<p>2、对用户的输入进行过滤，如对&amp; &lt; &gt; “ ‘ /等进行转义；</p>
<h3 id="103、什么是-CSRF-攻击，如何避免？"><a href="#103、什么是-CSRF-攻击，如何避免？" class="headerlink" title="103、什么是 CSRF 攻击，如何避免？"></a>103、什么是 CSRF 攻击，如何避免？</h3><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<p>1、攻击细节</p>
<p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>
<p>例子</p>
<p>假如一家银行用以运行转账操作的URL地址如下：<a target="_blank" rel="noopener" href="http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</a></p>
<p>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman"></p>
<p>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。</p>
<p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成信息的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p>
<p>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义运行操作。</p>
<p>2、防御措施</p>
<p>检查Referer字段</p>
<p>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于<a target="_blank" rel="noopener" href="http://www.examplebank.com之下.而如果是csrf攻击传来的请求,referer字段会是包含恶意网址的地址,不会位于www.examplebank.com之下,这时候服务器就能识别出恶意的访问./">www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。</a></p>
<p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。</p>
<p>3、添加校验token</p>
<p>由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。</p>
<h3 id="104、如何实现跨域？说一下-JSONP-实现原理？"><a href="#104、如何实现跨域？说一下-JSONP-实现原理？" class="headerlink" title="104、如何实现跨域？说一下 JSONP 实现原理？"></a>104、如何实现跨域？说一下 JSONP 实现原理？</h3><p>1、<a target="_blank" rel="noopener" href="https://blog.csdn.net/guorui_java/article/details/107345499" title="jsonp原理详解——终于搞清楚jsonp是啥了">jsonp原理详解——终于搞清楚jsonp是啥了</a></p>
<p>2、最流行的跨域方案cors</p>
<p>cors是目前主流的跨域解决方案，跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>
<p>3、最方便的跨域方案Nginx</p>
<p>nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</p>
<p>现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。</p>
<p>反向代理的原理很简单，即所有客户端的请求都必须先经过nginx的处理，nginx作为代理服务器再讲请求转发给node或者java服务，这样就规避了同源策略。</p>
<h3 id="105、websocket应用的是哪个协议"><a href="#105、websocket应用的是哪个协议" class="headerlink" title="105、websocket应用的是哪个协议"></a>105、websocket应用的是哪个协议</h3><p>WebSocket是一个允许Web应用程序(通常指浏览器)与服务器进行双向通信的协议。HTML5的WebSocket API主要是为浏览器端提供了一个基于TCP协议实现全双工通信的方法。</p>
<p>WebSocket优势： 浏览器和服务器只需要要做一个握手的动作，在建立连接之后，双方可以在任意时刻，相互推送信息。同时，服务器与客户端之间交换的头信息很小。</p>
<h3 id="106、说一下-tcp-粘包是怎么产生的？"><a href="#106、说一下-tcp-粘包是怎么产生的？" class="headerlink" title="106、说一下 tcp 粘包是怎么产生的？"></a>106、说一下 tcp 粘包是怎么产生的？</h3><p>发送方需要等缓冲区满才能发送出去，造成粘包；<br>接收方不及时接收缓冲区的包，造成粘包；</p>
<h3 id="107、请列举出在-JDK-中几个常用的设计模式？"><a href="#107、请列举出在-JDK-中几个常用的设计模式？" class="headerlink" title="107、请列举出在 JDK 中几个常用的设计模式？"></a>107、请列举出在 JDK 中几个常用的设计模式？</h3><p>1、单例模式</p>
<p>作用：保证类只有一个实例。</p>
<p>JDK中体现：Runtime类。</p>
<p>2、静态工厂模式</p>
<p>作用：代替构造函数创建对象，方法名比构造函数清晰。</p>
<p>JDK中体现：Integer.valueOf、Class.forName</p>
<p>3、抽象工厂</p>
<p>作用：创建某一种类的对象。</p>
<p>JDK中体现：Java.sql包。</p>
<p>4、原型模式</p>
<p>clone()；</p>
<p>原型模式的本质是拷贝原型来创建新的对象，拷贝是比new更快的创建对象的方法，当需要大批量创建新对象而且都是同一个类的对象的时候考虑使用原型模式。</p>
<p>一般的克隆只是浅拷贝（对象的hash值不一样，但是对象里面的成员变量的hash值是一样的）。</p>
<p>有些场景需要深拷贝，这时我们就要重写clone方法，以ArrayList为例：</p>
<p>5、适配器模式</p>
<p>作用：使不兼容的接口相容。</p>
<p>JDK中体现：InputStream、OutputStream。</p>
<p>6、装饰器模式</p>
<p>作用：为类添加新的功能，防止类继承带来的类爆炸。</p>
<p>JDK中体现：io类、Collections、List。</p>
<p>7、外观模式</p>
<p>作用：封装一组交互类，一直对外提供接口。</p>
<p>JDK中体现：logging包。</p>
<p>8、享元模式</p>
<p>作用：共享对象、节省内存。</p>
<p>JDK中体现：Integer.valueOf、String常量池。</p>
<p>9、代理模式</p>
<p>作用：</p>
<p>（1）透明调用被代理对象，无须知道复杂实现细节；</p>
<p>（2）增加被代理类的功能；</p>
<p>JDK中体现：动态代理。</p>
<p>10、迭代器模式</p>
<p>作用：将集合的迭代和集合本身分离。</p>
<p>JDK中体现：Iterator</p>
<p>11、命令模式</p>
<p>作用：封装操作，使接口一致。</p>
<p>JDK中体现：Runable、Callable、ThreadPoolExecutor。</p>
<h3 id="108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？"><a href="#108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？" class="headerlink" title="108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？"></a>108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？</h3><p>1、什么是设计模式？</p>
<p>设计模式是解决软件开发某些特定问题而提出的一些解决方案，也可以理解为解决问题的一些固定思路。</p>
<p>通过设计模式可以帮助我们增强代码的可复用性、可扩展性、灵活性。</p>
<p>我们使用设计模式的最终目的是实现代码的高内聚、低耦合。</p>
<p>2、设计模式的七大原则</p>
<ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转原则</li>
<li>里式替换原则</li>
<li>开闭原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ol>
<p>3、你是否在你的代码里面使用过任何设计模式？</p>
<p>（1）单例模式</p>
<p>JDK种的runtime，Spring种的singeton。</p>
<p>（2）简单工厂模式</p>
<p>Spring的BeanFactory，根据传入一个唯一标识来获得bean对象。</p>
<p>（3）原型模式</p>
<p>clone()</p>
<p>（4）代理模式</p>
<p>Spring的AOP中，Spring实现AOP功能的原理就是代理模式，①JDK动态代理。②CGLIB动态代理，使用Advice（通知）对类进行方法级别的切面增强。</p>
<p>（5）装饰器模式</p>
<p>为类添加新的功能，防止类爆炸；</p>
<p>IO流、数据源包装，Spring中用到的装饰器模式表现在Wrapper。</p>
<h3 id="109、Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式"><a href="#109、Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式" class="headerlink" title="109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式"></a>109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式</h3><ol>
<li>保证程序只有一个对象的实例，叫做单例模式；</li>
<li>内部类的方式实现单例模式，是线程安全的；</li>
<li>双重验证方式实现单例模式也是线程安全的；</li>
</ol>
<h3 id="110、在-Java-中，什么叫观察者设计模式（observer-design-pattern）？"><a href="#110、在-Java-中，什么叫观察者设计模式（observer-design-pattern）？" class="headerlink" title="110、在 Java 中，什么叫观察者设计模式（observer design pattern）？"></a>110、在 Java 中，什么叫观察者设计模式（observer design pattern）？</h3><p>1、观察者模式是一种一对多的依赖关系，让多个观察者同时监听某一主题对象。当这个主题对象发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<p>2、JAVA提供的对观察者模式的支持</p>
<p>在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。</p>
<p>（1）Observer接口</p>
<p>这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>（2）Observable类</p>
<p>被观察者类都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。</p>
<h3 id="111、使用工厂模式最主要的好处是什么？在哪里使用？"><a href="#111、使用工厂模式最主要的好处是什么？在哪里使用？" class="headerlink" title="111、使用工厂模式最主要的好处是什么？在哪里使用？"></a>111、使用工厂模式最主要的好处是什么？在哪里使用？</h3><p>1、工厂模式好处</p>
<ul>
<li>良好的封装性、代码结构清晰；</li>
<li>扩展性好，如果想增加一个产品，只需扩展一个工厂类即可；</li>
<li>典型的解耦框架；</li>
</ul>
<p>2、在哪里使用？</p>
<ul>
<li>需要生成对象的地方；</li>
<li>不同数据库的访问；</li>
</ul>
<h3 id="112、请解释自动装配模式的区别？"><a href="#112、请解释自动装配模式的区别？" class="headerlink" title="112、请解释自动装配模式的区别？"></a>112、请解释自动装配模式的区别？</h3><p>有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。</p>
<p>1、no</p>
<p>默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。第 402 页 共 485 页</p>
<p>2、byName</p>
<p>通过参数名 自动装配，Spring 容器在配置文件中发现 bean</p>
<p>的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属</p>
<p>性具有相同名字的 bean。</p>
<p>3、byType:</p>
<p>通过参数类型自动装配，Spring 容器在配置文件中发现 bean</p>
<p>的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属</p>
<p>性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。</p>
<p>4、constructor</p>
<p>这个方式类似于 byType， 但是要提供给构造器参数，如</p>
<p>果没有确定的带参数的构造器参数类型，将会抛出异常。</p>
<p>5、autodetect</p>
<p>首先尝试使用 constructor 来自动装配，如果无法工作，</p>
<p>则使用 byType 方式。</p>
<h3 id="113、举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？"><a href="#113、举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？" class="headerlink" title="113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？"></a>113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</h3><p>在Java IO中运用了装饰器模式，inputStream作为抽象类，其下有几个实现类，表示从不同的数据源输入：</p>
<ol>
<li>byteArrayInputStream</li>
<li>fileInputStream</li>
<li>StringBufferInputStream</li>
<li>PipedInputStream，从管道产生输入；</li>
<li>SequenceInputStream，可将其他流收集合并到一个流内；</li>
</ol>
<p>FilterInputStream作为装饰器在JDK中是一个普通类，其下面有多个具体装饰器比如BufferedInputStream、DataInputStream等。</p>
<p>FilterInputStream内部封装了基础构件：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br></pre></td></tr></tbody></table></figure>

<p>而BufferedInputStream在调用其read()读取数据时会委托基础构件来进行更底层的操作，而它自己所起的装饰作用就是缓冲，在源码中可以很清楚的看到这一切。</p>
<h3 id="114、什么是-Spring-框架？Spring-框架有哪些主要模块？"><a href="#114、什么是-Spring-框架？Spring-框架有哪些主要模块？" class="headerlink" title="114、什么是 Spring 框架？Spring 框架有哪些主要模块？"></a>114、什么是 Spring 框架？Spring 框架有哪些主要模块？</h3><p>Spring是一个控制反转和面向切面的容器框架。</p>
<p>Spring有七大功能模块：</p>
<p>1、Core</p>
<p>Core模块是Spring的核心类库，Core实现了IOC功能。</p>
<p>2、AOP</p>
<p>Apring AOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常见的拦截器，供用户自定义和配置。</p>
<p>3、orm</p>
<p>提供对常用ORM框架的管理和支持，hibernate、mybatis等。</p>
<p>4、Dao</p>
<p>Spring提供对JDBC的支持，对JDBC进行封装。</p>
<p>5、Web</p>
<p>对Struts2的支持。</p>
<p>6、Context</p>
<p>Context模块提供框架式的Bean的访问方式，其它程序可以通过Context访问Spring的Bean资源，相当于资源注入。</p>
<p>7、MVC</p>
<p>MVC模块为spring提供了一套轻量级的MVC实现，即Spring MVC。</p>
<h3 id="115、使用-Spring-框架能带来哪些好处？"><a href="#115、使用-Spring-框架能带来哪些好处？" class="headerlink" title="115、使用 Spring 框架能带来哪些好处？"></a>115、使用 Spring 框架能带来哪些好处？</h3><p>1、轻量级框架、容器</p>
<p>Spring是一个容器，管理对象的生命周期和配置。基于一个可配置原型prototype，你的bean可以使单利的，也可以每次需要时都生成一个新的实例。</p>
<p>2、控制反转IOC</p>
<p>Spring通过控制反转实现松耦合。</p>
<p>3、支持AOP</p>
<p>Spring提供对AOP的支持，它允许将一些通用任务，如安全、事务、日志等进行集中式处理，从而提高了程序的复用性。</p>
<p>4、轻量级框架</p>
<p>5、方便测试</p>
<p>Spring提供Junit4的支持，可以通过注解方便测试spring程序。</p>
<p>6、对Java中很多API进行了封装</p>
<p>7、方便集成各种优秀框架</p>
<p>如Struts、hibernate、mybstis。</p>
<p>8、支持声明式事务处理</p>
<p>只需通过配置就可以完成对事务的管理，而无须手动编程。</p>
<h3 id="116、Spring-IOC、AOP举例说明"><a href="#116、Spring-IOC、AOP举例说明" class="headerlink" title="116、Spring IOC、AOP举例说明"></a>116、Spring IOC、AOP举例说明</h3><p>1、IOC理论的背景</p>
<p>我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。</p>
<p>如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。<br>齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p>
<p>耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的”解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。</p>
<p>2、什么是控制反转</p>
<p>IOC是Inversion of Control的缩写，多数书籍翻译成”控制反转”，还有些书籍翻译成为”控制反向”或者”控制倒置”。<br>1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC理论提出的观点大体是这样的：借助于”第三方”实现具有依赖关系的对象之间的解耦，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801180652362.jpg"></p>
<p>大家看到了吧，由于引进了中间位置的”第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠”第三方”了，全部对象的控制权全部上缴给”第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似”粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个”粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成”粘合剂”的由来。<br>我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统（拿掉IoC容器后的系统）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801180714819.jpg"></p>
<p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！<br>我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：<br>软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。<br>软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。<br>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是”控制反转”这个名称的由来。</p>
<p>3、IOC的别名：依赖注入（DI）</p>
<p>2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是”哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：”获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给”控制反转”取了一个更合适的名字叫做”依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。<br>我们举一个生活中的例子，来帮助理解依赖注入的过程。大家对USB接口和USB设备应该都很熟悉吧，USB为我们使用电脑提供了很大的方便，现在有很多的外部设备都支持USB接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801180744625.jpg"></p>
<p>现在，我们利用电脑主机和USB接口来实现一个任务：从外部USB设备读取一个文件。<br>电脑主机读取文件的时候，它一点也不会关心USB接口上连接的是什么外部设备，而且它确实也无须知道。它的任务就是读取USB接口，挂接的外部设备只要符合USB接口标准即可。所以，如果我给电脑主机连接上一个U盘，那么主机就从U盘上读取文件；如果我给电脑主机连接上一个外置硬盘，那么电脑主机就从外置硬盘上读取文件。挂接外部设备的权力由我作主，即控制权归我，至于USB接口挂接的是什么设备，电脑主机是决定不了，它只能被动的接受。电脑主机需要外部设备的时候，根本不用它告诉我，我就会主动帮它挂上它想要的外部设备，你看我的服务是多么的到位。这就是我们生活中常见的一个依赖注入的例子。在这个过程中，我就起到了IOC容器的作用。<br>通过这个例子,依赖注入的思路已经非常清楚：当电脑主机读取文件的时候，我就把它所要依赖的外部设备，帮他挂接上。整个外部设备注入的过程和一个被依赖的对象在系统运行时被注入另外一个对象内部的过程完全一样。<br>我们把依赖注入应用到软件系统中，再来描述一下这个过程：<br>对象A依赖于对象B,当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。<br>在传统的实现中，由程序内部代码来控制组件之间的关系。我们经常使用new关键字来实现两个组件之间关系的组合，这种实现方式会造成组件之间耦合。IOC很好地解决了该问题，它将实现组件间关系从程序内部提到外部容器，也就是说由容器在运行期将组件间的某种依赖关系动态注入组件中。</p>
<p>4、IOC为我们带来了什么好处</p>
<p>我们还是从USB的例子说起，使用USB外部设备比使用内置硬盘，到底带来什么好处？<br>第一、USB设备作为电脑主机的外部设备，在插入主机之前，与电脑主机没有任何的关系，只有被我们连接在一起之后，两者才发生联系，具有相关性。所以，无论两者中的任何一方出现什么的问题，都不会影响另一方的运行。这种特性体现在软件工程中，就是可维护性比较好，非常便于进行单元测试，便于调试程序和诊断故障。代码中的每一个Class都可以单独测试，彼此之间互不影响，只要保证自身的功能无误即可，这就是组件之间低耦合或者无耦合带来的好处。<br>第二、USB设备和电脑主机的之间无关性，还带来了另外一个好处，生产USB设备的厂商和生产电脑主机的厂商完全可以是互不相干的人，各干各事，他们之间唯一需要遵守的就是USB接口标准。这种特性体现在软件开发过程中，好处可是太大了。每个开发团队的成员都只需要关心实现自身的业务逻辑，完全不用去关心其它的人工作进展，因为你的任务跟别人没有任何关系，你的任务可以单独测试，你的任务也不用依赖于别人的组件，再也不用扯不清责任了。所以，在一个大中型项目中，团队成员分工明确、责任明晰，很容易将一个大的任务划分为细小的任务，开发效率和产品质量必将得到大幅度的提高。<br>第三、同一个USB外部设备可以插接到任何支持USB的设备，可以插接到电脑主机，也可以插接到DV机，USB外部设备可以被反复利用。在软件工程中，这种特性就是可复用性好，我们可以把具有普遍性的常用组件独立出来，反复利用到项目中的其它部分，或者是其它项目，当然这也是面向对象的基本特征。显然，IOC不仅更好地贯彻了这个原则，提高了模块的可复用性。符合接口标准的实现，都可以插接到支持此标准的模块中。<br>第四、同USB外部设备一样，模块具有热插拔特性。IOC生成对象的方式转为外置方式，也就是把对象生成放在配置文件里进行定义，这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拨的特性。<br>以上几点好处，难道还不足以打动我们，让我们在项目开发过程中使用IOC框架吗？</p>
<p>5、IOC容器的技术剖析</p>
<p>IOC中最基本的技术就是”反射(Reflection)”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成”映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。反射的应用是很广泛的，很多的成熟的框架，比如象Java中的Hibernate、Spring框架，.Net中 NHibernate、Spring.Net框架都是把”反射”做为最基本的技术手段。<br>反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少得10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约为1-2倍的差距。<br>我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<p>6、IOC容器的一些产品</p>
<p>Sun ONE技术体系下的IOC容器有：轻量级的有Spring、Guice、Pico Container、Avalon、HiveMind；重量级的有EJB；不轻不重的有JBoss，Jdon等等。Spring框架作为Java开发中SSH(Struts、Spring、Hibernate)三剑客之一，大中小项目中都有使用，非常成熟，应用广泛，EJB在关键性的工业级项目中也被使用，比如某些电信业务。<br>.Net技术体系下的IOC容器有：Spring.Net、Castle等等。Spring.Net是从Java的Spring移植过来的IOC容器，Castle的IOC容器就是Windsor部分。它们均是轻量级的框架，比较成熟，其中Spring.Net已经被逐渐应用于各种项目中。</p>
<p>7、使用IOC框架应该注意什么</p>
<p>使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。</p>
<p>（1）软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</p>
<p>（2）由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</p>
<p>（3）、具体到IOC框架产品(比如：Spring)来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</p>
<p>（4）IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。<br>我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，象WEB2.0网站就是这种情况。</p>
<h3 id="117、什么是控制反转-IOC-？什么是依赖注入？"><a href="#117、什么是控制反转-IOC-？什么是依赖注入？" class="headerlink" title="117、什么是控制反转(IOC)？什么是依赖注入？"></a>117、什么是控制反转(IOC)？什么是依赖注入？</h3><p>借助Spring实现具有依赖关系的对象之间的解耦。</p>
<p>对象A运行需要对象B，由主动创建变为IOC容器注入，这便是控制反转。</p>
<p>获得依赖对象的过程被反转了，获取依赖对象的过程由自身创建变为由IOC容器注入，这便是依赖注入。</p>
<h3 id="118、BeanFactory-和-ApplicationContext-有什么区别？"><a href="#118、BeanFactory-和-ApplicationContext-有什么区别？" class="headerlink" title="118、BeanFactory 和 ApplicationContext 有什么区别？"></a>118、BeanFactory 和 ApplicationContext 有什么区别？</h3><p>1、BeanFactory是Spring的最底层接口，包含bean的定义，管理bean的加载，实例化，控制bean的生命周期，特点是每次获取对象时才会创建对象。</p>
<p>ApplicationContext是BeanFactory的子接口，拥有BeanFactory的全部功能，并且扩展了很多高级特性，每次容器启动时就会创建所有的对象。</p>
<ol>
<li>ApplicationContext的额外功能：</li>
<li>继承MessageSource，支持国际化；</li>
<li>统一的资源文件访问方式；</li>
<li>提供在监听器中注册bean；</li>
<li>同时加载过个配置文件；</li>
<li>载入多个（有继承关系）上下文，使得每个上下文都专注于一个特定的层次，比如应用的web层；</li>
</ol>
<p>2、BeanFactory通常以编程的方式被创建，ApplicationContext可以以声明的方式创建，如使用ContextLoader。</p>
<p>3、BeanFactory 和 ApplicationContext都支持BeanPostProcessor，BeanFactoryPostProcessor，但BeanFactory需要手动注册，ApplicationContext则是自动注册。</p>
<h3 id="119、什么是-JavaConfig？"><a href="#119、什么是-JavaConfig？" class="headerlink" title="119、什么是 JavaConfig？"></a>119、什么是 JavaConfig？</h3><p>JavaConfig是Spring3.0新增的概念，就是以注解的形式取代Spring中繁琐的xml文件。</p>
<p>JavaConfig结合了xml的解耦和java编译时检查的优点。</p>
<ol>
<li>@Configuration，表示这个类是配置类；</li>
<li>@ComponentScan，相当于xml的</li>
<li>@Bean，相当于xml的</li>
<li>@EnableWebMvc，相当于xml的</li>
<li>@ImportResource，相当于xml的</li>
<li>@PropertySource，用于读取properties配置文件；</li>
<li>@Profile，一般用于多环境配置，激活时可用@ActiveProfile(“dev”)注解；</li>
</ol>
<h3 id="120、什么是-ORM-框架？"><a href="#120、什么是-ORM-框架？" class="headerlink" title="120、什么是 ORM 框架？"></a>120、什么是 ORM 框架？</h3><p>ORM（Object-relational mapping），对象关系映射。</p>
<p>是为了解决面向对象与关系型数据库存在的不匹配问题。</p>
<p>ORM框架的优点：</p>
<ol>
<li>开发效率更高</li>
<li>数据访问更抽象、轻便</li>
<li>支持面向对象封装</li>
</ol>
<h3 id="121、Spring-有几种配置方式？"><a href="#121、Spring-有几种配置方式？" class="headerlink" title="121、Spring 有几种配置方式？"></a>121、Spring 有几种配置方式？</h3><p>1、xml配置文件</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>2、基于注解的方式</p>
<p>项目越来越大，基于xml配置太麻烦，Spring 2.x时代提供了声明bean的注解。</p>
<p>（1）Bean的定义</p>
<p>@Component、@Controller、@Service、@Repository。</p>
<p>（2）Bean的注入</p>
<p>@Autowire</p>
<p>3、基于Java的方式</p>
<p>Spring 3.x以后，可以通过Java代码装配Bean。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">zs</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//两个狗</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">haqi</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component("zs")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//get，set方法略</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>原来就是配置类啊，通过@Bean、@Component、getBean方式进行Bean的注册和发现。</p>
<h3 id="122、请解释-Spring-Bean-的生命周期？"><a href="#122、请解释-Spring-Bean-的生命周期？" class="headerlink" title="122、请解释 Spring Bean 的生命周期？"></a>122、请解释 Spring Bean 的生命周期？</h3><ol>
<li>通过构造器或工厂方法创建bean实例；</li>
<li>为bean的属性赋值；</li>
<li>调用bean的初始化方法；</li>
<li>使用bean；</li>
<li>当容器关闭时，调用bean的销毁方法；</li>
</ol>
<h3 id="123、Spring-Bean-的作用域之间有什么区别？-Spring容器中的bean可以分为5个范围："><a href="#123、Spring-Bean-的作用域之间有什么区别？-Spring容器中的bean可以分为5个范围：" class="headerlink" title="123、Spring Bean 的作用域之间有什么区别？ Spring容器中的bean可以分为5个范围："></a>123、Spring Bean 的作用域之间有什么区别？ Spring容器中的bean可以分为5个范围：</h3><ol>
<li>singleton：这种bean范围是默认的，这种范围确保不管接受多少请求，每个容器中只哟一个bean的实例，单例模式；</li>
<li>prototype：为每一个bean提供一个实例；</li>
<li>request：在请求bean范围内为每一个来自客户端的网络请求创建一个实例，在请求完毕后，bean会失效并被垃圾回收器回收；</li>
<li>session：为每个session创建一个实例，session过期后，bean会随之消失；</li>
<li>global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet公用全局的存储变量的话，那么全局变量需要存储在global-session中。</li>
</ol>
<h3 id="124、如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#124、如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="124、如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>124、如何在 Spring Boot 中禁用 Actuator 端点安全性？</h3><p>默认情况下，所有敏感的HTTP端点都是安全的，只有具有Actuator角色的用户才能访问它们。安全性是使用标准的HTTPServletRequest.isUserInRole方法实施的。我们可以使用management.security.enable = false来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p>
<h3 id="125、什么是-Spring-inner-beans？"><a href="#125、什么是-Spring-inner-beans？" class="headerlink" title="125、什么是 Spring inner beans？"></a>125、什么是 Spring inner beans？</h3><p>在Spring框架中，无论何时bean被使用时，当仅被调用一个属性。可以将这个bean声明为内部bean。内部bean可以用setter注入”属性”和构造方法注入”构造参数”的方式来实现。比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们要做的是创建一个Person实例，然后再Customer内部使用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> {</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="126、Spring-框架中的单例-Beans-是线程安全的么？"><a href="#126、Spring-框架中的单例-Beans-是线程安全的么？" class="headerlink" title="126、Spring 框架中的单例 Beans 是线程安全的么？"></a>126、Spring 框架中的单例 Beans 是线程安全的么？</h3><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态，所以在某种程度上说Spring的单例bean时线程安全的。如果你的bean有多种状态的话，比如view model，就需要自行保证线程安全啦。</p>
<p>最浅显的解决办法就是将多态bean的作用域由singleton变更为prototype。</p>
<h3 id="127、请解释-Spring-Bean-的自动装配？"><a href="#127、请解释-Spring-Bean-的自动装配？" class="headerlink" title="127、请解释 Spring Bean 的自动装配？"></a>127、请解释 Spring Bean 的自动装配？</h3><p>Spring支持IOC，自动装配不用类实例化，直接从bean容器中取。</p>
<p>1、配置在xml中</p>
<h3 id="128、如何开启基于注解的自动装配？"><a href="#128、如何开启基于注解的自动装配？" class="headerlink" title="128、如何开启基于注解的自动装配？"></a>128、如何开启基于注解的自动装配？</h3><p>要使用 <code>@Autowired</code>，需要注册 <code>AutowiredAnnotationBeanPostProcessor</code>，可以有以下两种方式来实现：</p>
<p>引入配置文件中的 <code>&lt;bean&gt;&lt;/bean&gt;</code>下引入 <code>&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;</code></p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在bean配置文件中直接引入 <code>AutowiredAnnotationBeanPostProcessor</code></p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="129、什么是-Spring-Batch？"><a href="#129、什么是-Spring-Batch？" class="headerlink" title="129、什么是 Spring Batch？"></a>129、什么是 Spring Batch？</h3><p>1、什么是spring batch?</p>
<p>spring batch是一个轻量级的、完善的批处理框架，它主要的目的在于帮助企业建立健壮、高效的批处理应用。</p>
<p>spring batch是Spring的一个子项目，它使用java语言并基于spring框架作为基础开发，使得已经使用Spring框架的开发者或者是企业可以更加容易访问和利用企业服务。</p>
<p>spring batch提供了大量可重用的组件,包括了日志、追踪、事务、任务作业统计、任务重启、跳过、重复、资源管理。</p>
<p>对大数据量和高性能的批处理任务，spring batch同样提供了高级功能和特性来支持。</p>
<p>例如：分区功能、远程功能。</p>
<p>总的来说，spring batch可以支持简单的、复杂的和大数据量的批处理作业。</p>
<p>2、spring batch业务场景</p>
<p>周期性的提交批处理</p>
<p>把一个任务并行处理</p>
<p>消息驱动应用分级处理</p>
<p>大规模并行批处理</p>
<p>手工或调度使任务失败之后重新启动</p>
<p>有依赖步骤的顺序执行(使用工作流驱动扩展)</p>
<p>处理时跳过部分记录</p>
<p>成批事务：为小批量的或有的存储过程/脚本的场景使用</p>
<h3 id="130、spring-mvc-和-struts-的区别是什么？"><a href="#130、spring-mvc-和-struts-的区别是什么？" class="headerlink" title="130、spring mvc 和 struts 的区别是什么？"></a>130、spring mvc 和 struts 的区别是什么？</h3><p>1、拦截机制的不同</p>
<p>Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p>
<p>SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p>
<p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<p>2、底层框架的不同</p>
<p>Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p>
<p>3、性能方面</p>
<p>Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p>
<p>4、配置方面</p>
<p>spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p>
<h3 id="131、请举例解释-Required-注解？"><a href="#131、请举例解释-Required-注解？" class="headerlink" title="131、请举例解释@Required 注解？"></a>131、请举例解释@Required 注解？</h3><p>@Required注解应用于bean属性的setter方法，它表明影响的bean属性在配置时必须放在XML配置文件中。</p>
<p>十九、请举例说明@Qualifier 注解？<br>如果在xml中定义了一种类型的多个bean，同时在java注解中又想把其中一个bean对象作为属性，那么此时可以使用@Qualifier加@Autowired来达到这一目的，若不加@Qualifier这个注解，在运行时会出现” No qualifying bean of type [com.tutorialspoint.Student] is defined: expected single matching bean but found 2: student1,student2”这个异常。</p>
<h3 id="132、Spring常用注解"><a href="#132、Spring常用注解" class="headerlink" title="132、Spring常用注解"></a>132、Spring常用注解</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guorui_java/article/details/107347754" title="Spring常用注解（绝对经典）">Spring常用注解（绝对经典）</a></p>
<h3 id="133、项目中是如何实现权限验证的，权限验证需要几张表"><a href="#133、项目中是如何实现权限验证的，权限验证需要几张表" class="headerlink" title="133、项目中是如何实现权限验证的，权限验证需要几张表"></a>133、项目中是如何实现权限验证的，权限验证需要几张表</h3><p>通过了解，现在最普遍的权限管理模型就是RBAC（Role-Based Access Control）。</p>
<p>1、权限控制分类</p>
<p>菜单功能<br>url控制（控制访问不同的控制器）<br>2、RBAC的优缺点</p>
<p>（1）优点</p>
<p>简化了用户和权限的关系<br>易扩展、易维护</p>
<p>（2）缺点</p>
<p>RBAC模型没有提供操作顺序的控制机制，这一缺陷使得RBAC模型很难适应哪些对操作次序有严格要求的系统。</p>
<p>3、RBAC支持的安全原则</p>
<p>（1）最小权限原则</p>
<p>RBAC可以将角色配置成其完成任务所需的最小权限集合。</p>
<p>（2）责任分离原则</p>
<p>可以通过调用相互独立互斥的角色来共同完成敏感的任务，例如要求一个记账员和财务管理员共同参与统一过账操作。</p>
<p>（3）数据抽象原则</p>
<p>可以通过权限的抽象来体现，例如财务操作用借款、存款等抽象权限，而不是使用典型的读写权限。</p>
<p>4、远古时代的权限控制</p>
<p>当时还没有RBAC，也没有这个概念，就是一堆程序员在那鼓捣，觉得登录这块该做点什么。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801181255483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<blockquote>
<p>1、新建一个用户，对这个用户进行赋予权限。<br>2、但是一旦用户多了，权限复杂了，这工作量也是蛮大的。</p>
</blockquote>
<p>5、RBAC</p>
<p>RBAC 1.0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801181330199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801181401168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p>直接上图，一目了然，当程序不是很复杂的时候，RBAC就是这样设计的，我们公司的权限验证模块就是这样设计的。</p>
<p>简简单单，五张表，解</p>
<p>RBAC 2.0</p>
<p>基于RBAC 1.0模型的基础上，进行了角色的访问控制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801181428450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p>RBAC2中的一个基本限制是互斥角色的限制，互斥角色是指各自权限可以互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。</p>
<p>该模型有以下几种约束</p>
<ul>
<li>互斥角色 ：同一用户只能分配到一组互斥角色集合中至多一个角色，支持责任分离的原则。互斥角色是指各自权限互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。常举的例子：在审计活动中，一个角色不能同时被指派给会计角色和审计员角色。</li>
<li>基数约束 ：一个角色被分配的用户数量受限；一个用户可拥有的角色数目受限；同样一个角色对应的访问权限数目也应受限，以控制高级权限在系统中的分配。</li>
<li>先决条件角色 ：可以分配角色给用户仅当该用户已经是另一角色的成员；对应的可以分配访问权限给角色，仅当该角色已经拥有另一种访问权限。指要想获得较高的权限，要首先拥有低一级的权限。</li>
<li>运行时互斥 ：例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。</li>
</ul>
<p>6、rbac的实现理论分析</p>
<p>进入登录页面；<br>拿到通过post传过来的用户名和密码；<br>使用orm进行过滤查找；<br>如果能找到值，则说明登录成功：登录成功后调用rbac初始化函数，初始化函数的主要功能是获取用户的权限和菜单保存到session中，并跳转客户列表页面；如果失败，页面进行友好提示；</p>
<p>7、url权限控制关键代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801181510714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<h3 id="134、谈谈controller，接口调用的路径问题"><a href="#134、谈谈controller，接口调用的路径问题" class="headerlink" title="134、谈谈controller，接口调用的路径问题"></a>134、谈谈controller，接口调用的路径问题</h3><p>1、Spring MVC如何匹配请求路径</p>
<p>@RequestMapping是用来映射请求的，比如get请求、post请求、或者REST风格与非REST风格的。该注解可以用在类上或方法上，如果用在类上，表示是该类中所有方法的父路径。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/springmvc")</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCTest</span> {</span><br><span class="line">    <span class="meta">@RequestMapping("/testRequestMapping")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"testRequestMapping"</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在类上还添加了一个@Controller注解，该注解在SpringMVC中负责处理由DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个model，然后再把该model返回给对应的view进行展示。</p>
<p>我们可以通过”springmvc/testRequestMapping”这个路径来定位到testRequestMapping这个方法，然后执行方法内的方法体。</p>
<p>RequestMapping可以实现模糊匹配路径，比如：</p>
<ol>
<li>？表示一个字符；</li>
<li>*表示任意字符；</li>
<li>**匹配多层路径；</li>
</ol>
<p>/springmvc/**/testRequestMapping 就可以匹配/springmvc/stu/getStudentInfo/testRequestMapping 这样的路径了。</p>
<p>2、SpringMVC如何获取请求的参数</p>
<p>（1）@PathVariable</p>
<p>该注解用来映射请求URL中绑定的占位符。通过@PathVariable可以将URL中占位符的参数绑定到controller处理方法的入参中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/testPathVariable/{id}")</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPathVariable</span><span class="params">(<span class="meta">@PathVariable(value="id")</span> Integer id)</span>{</span><br><span class="line">    System.out.println(<span class="string">"testPathVariable:"</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在index.jsp中我们添加一条连接，用来触发一个请求：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testPathVariable</span><br></pre></td></tr></tbody></table></figure>

<p>（2） @RequestParam</p>
<p>该注解也是用来获取请求参数的，那么该注解和@PathVariable有什么不同呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value="/testRequestParam")</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestParam</span><span class="params">(<span class="meta">@RequestParam(value="username")</span> String username, <span class="meta">@RequestParam(value="age", required=false, defaultValue="0")</span> <span class="type">int</span> age)</span>{</span><br><span class="line">    System.out.println(<span class="string">"testRequestParam"</span> + <span class="string">" username:"</span> + username + <span class="string">" age:"</span> +age);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在index.jsp添加超链接标签</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testRequestParam</span><br></pre></td></tr></tbody></table></figure>

<p>3、REST风格的请求</p>
<p>在SpringMVC中业务最多的应该是CRUD了</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value="/testRest/{id}", method=RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRestPut</span><span class="params">(<span class="meta">@PathVariable(value="id")</span> Integer id)</span>{</span><br><span class="line">    System.out.println(<span class="string">"test put:"</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value="/testRest/{id}", method=RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRestDelete</span><span class="params">(<span class="meta">@PathVariable(value="id")</span> Integer id)</span>{</span><br><span class="line">    System.out.println(<span class="string">"test delete:"</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value="/testRest", method=RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">()</span>{</span><br><span class="line">    System.out.println(<span class="string">"test post"</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value="/testRest/{id}", method=RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">(<span class="meta">@PathVariable(value="id")</span> Integer id)</span>{</span><br><span class="line">    System.out.println(<span class="string">"test get:"</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="135、如何防止表单重复提交"><a href="#135、如何防止表单重复提交" class="headerlink" title="135、如何防止表单重复提交"></a>135、如何防止表单重复提交</h3><p>1、通过JavaScript屏蔽提交按钮（不推荐）</p>
<p>2、给数据库增加唯一键约束（简单粗暴）</p>
<p>3、利用Session防止表单重复提交（推荐）</p>
<p>4、使用AOP自定义切入实现</p>
<h3 id="136、Spring中都应用了哪些设计模式"><a href="#136、Spring中都应用了哪些设计模式" class="headerlink" title="136、Spring中都应用了哪些设计模式"></a>136、Spring中都应用了哪些设计模式</h3><p>1、简单工厂模式</p>
<p>简单工厂模式的本质就是一个工厂类根据传入的参数，动态的决定实例化哪个类。</p>
<p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象。</p>
<p>2、工厂方法模式</p>
<p>应用程序将对象的创建及初始化职责交给工厂对象，工厂Bean。</p>
<p>定义工厂方法，然后通过config.xml配置文件，将其纳入Spring容器来管理，需要通过factory-method指定静态方法名称。</p>
<p>3、单例模式</p>
<p>Spring用的是双重判断加锁的单例模式，通过getSingleton方法从singletonObjects中获取bean。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Checks already instantiated singletons and also allows for an early</span></span><br><span class="line"><span class="comment"> * reference to a currently created singleton (resolving a circular reference).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowEarlyReference whether early references should be created or not</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object, or {<span class="doctag">@code</span> null} if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> {</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) {</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) {</span><br><span class="line">                <span class="type">ObjectFactory</span> <span class="variable">singletonFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) {</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、代理模式</p>
<p>Spring的AOP中，使用的Advice（通知）来增强被代理类的功能。Spring实现AOP功能的原理就是代理模式（① JDK动态代理，② CGLIB字节码生成技术代理。）对类进行方法级别的切面增强。</p>
<p>5、装饰器模式</p>
<p>装饰器模式：动态的给一个对象添加一些额外的功能。</p>
<p>Spring的ApplicationContext中配置所有的DataSource。这些DataSource可能是不同的数据库，然后SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的。</p>
<p>在Spring中有两种表现：</p>
<p>一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<p>6、观察者模式</p>
<p>定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p>
<p>Spring中观察者模式一般用在listener的实现。</p>
<p>7、策略模式</p>
<p>策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。</p>
<p>getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。</p>
<p>8、模板方法模式</p>
<p>Spring JdbcTemplate的query方法总体结构是一个模板方法+回调函数，query方法中调用的execute()是一个模板方法，而预期的回调doInStatement(Statement state)方法也是一个模板方法。</p>
<h3 id="137、请举例说明如何在-Spring-中注入一个-Java-Collection？"><a href="#137、请举例说明如何在-Spring-中注入一个-Java-Collection？" class="headerlink" title="137、请举例说明如何在 Spring 中注入一个 Java Collection？"></a>137、请举例说明如何在 Spring 中注入一个 Java Collection？</h3><p>Spring注入有四种方式，</p>
<ol>
<li>set注入；</li>
<li>构造器注入；</li>
<li>基于注解的注入；</li>
<li>xml配置文件注入；</li>
</ol>
<p>想要注入java collection，就是注入集合类：</p>
<ol>
<li>list</li>
<li>set</li>
<li>map</li>
<li>props：该标签支持注入键和值都是字符串类型的键值对。</li>
</ol>
<p>list和set都使用value标签；map使用entry标签；props使用prop标签；</p>
<h3 id="138、mybatis-中-和-的区别是什么？"><a href="#138、mybatis-中-和-的区别是什么？" class="headerlink" title="138、mybatis 中 #{}和 ${}的区别是什么？"></a>138、mybatis 中 #{}和 ${}的区别是什么？</h3><ol>
<li>#{}带引号，${}不带引号；</li>
<li>#{}可以防止SQL注入；</li>
<li>${}常用于数据库表名、order by子句；</li>
<li>一般能用#{}就不要使用${}；</li>
</ol>
<h3 id="139、mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#139、mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="139、mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a>139、mybatis 是否支持延迟加载？延迟加载的原理是什么？</h3><p>1、mybatis 是否支持延迟加载？</p>
<p>延迟加载其实就是讲数据加载时机推迟，比如推迟嵌套查询的时机。</p>
<p>延迟加载可以实现先查询主表，按需实时做关联查询，返回关联表结果集，一定程度上提高了效率。</p>
<p>mybatis仅支持关联对象association和关联集合对象collection的延迟加载，association是一对一，collection是一对多查询，在mybatis配置文件中可以配置lazyloadingEnable=true/false。</p>
<p>2、延迟加载的原理是什么？</p>
<p>使用CGLIB为目标对象建立代理对象，当调用目标对象的方法时进入拦截器方法。</p>
<p>比如调用a.getB().getName()，拦截器方法invoke()发现a.getB()为null，会单独发送事先准备好的查询关联B对象的sql语句，把B查询出来然后调用a.setB(b)，也是a的对象的属性b就有值了，然后调用getName()，这就是延迟加载的原理。</p>
<h3 id="140、说一下-mybatis-的一级缓存和二级缓存？"><a href="#140、说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="140、说一下 mybatis 的一级缓存和二级缓存？"></a>140、说一下 mybatis 的一级缓存和二级缓存？</h3><p>一级缓存是session级别的缓存，默认开启，当查询一次数据库时，对查询结果进行缓存，如果之后的查询在一级缓存中存在，则无需再访问数据库；</p>
<p>二级缓存是sessionFactory级别的缓存，需要配置才会开启。当进行sql语句查询时，先查看一级缓存，如果不存在，访问二级缓存，降低数据库访问压力。</p>
<h3 id="141、mybatis-有哪些执行器（Executor）？"><a href="#141、mybatis-有哪些执行器（Executor）？" class="headerlink" title="141、mybatis 有哪些执行器（Executor）？"></a>141、mybatis 有哪些执行器（Executor）？</h3><p>1、mybatis有三种基本的Executor执行器：</p>
<p>（1）、SimpleExecutor</p>
<p>每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
<p>（2）、PauseExecutor</p>
<p>执行update或select，以sql做为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而且放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</p>
<p>（3）、BatchExecutor</p>
<p>执行update，将所有sql通过addBatch()都添加到批处理中，等待统一执行executeBatch()，它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<p>2、作用范围：</p>
<p>Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<p>3、Mybatis中如何指定使用哪一种Executor执行器？</p>
<p>在mybatis的配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
<h3 id="142、mybatis-和-hibernate-的区别有哪些？"><a href="#142、mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="142、mybatis 和 hibernate 的区别有哪些？"></a>142、mybatis 和 hibernate 的区别有哪些？</h3><p>1、两者最大的区别</p>
<p>针对简单逻辑，都有对应的代码生成工具，可以生成简单基本的dao层方法；</p>
<p>针对高级查询，mybatis要手动编写sql语句和resultMap，而hibernate有良好的映射机制；</p>
<p>2、开发难度对比</p>
<p>hibernate &gt; mybatis</p>
<p>3、日志统计</p>
<p>hibernate有自己的日志统计功能，而mybatis需要借助log4j来记录日志。</p>
<p>4、数据库扩展比较</p>
<p>hibernate &gt; mybatis</p>
<p>5、缓存机制比较</p>
<p>因为hibernate对查询对象有良好的管理机制，用户无需关心sql，所以使用二级缓存如果出现脏数据，系统会报错。</p>
<p>而mybatis，如果不能获取最新数据，应该避免缓存的使用，脏数据的出现会给系统的正常运行带来很大的隐患。</p>
<p>6、如何选择</p>
<ol>
<li>mybatis需要编写sql和映射规则，工作量大于hibernate；</li>
<li>mybatis支持的工具也有限，不能像hibernate那样有许多插件可以帮助生成映射代码和关联关系；</li>
<li>对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐hibernate；</li>
<li>对于性能要求高、响应快、灵活的系统，比如电商系统，推荐使用mybatis；</li>
</ol>
<h3 id="143、myBatis查询多个id、myBatis常用属性"><a href="#143、myBatis查询多个id、myBatis常用属性" class="headerlink" title="143、myBatis查询多个id、myBatis常用属性"></a>143、myBatis查询多个id、myBatis常用属性</h3><p>myBatis查询多个id（我居然回答用对象来传递…）</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page  getUserListByIds(@Param("ids") List ids);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select * from student</span><br><span class="line">where id in</span><br><span class="line"></span><br><span class="line">    #{userid}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="144、mybatis一级缓存、二级缓存"><a href="#144、mybatis一级缓存、二级缓存" class="headerlink" title="144、mybatis一级缓存、二级缓存"></a>144、mybatis一级缓存、二级缓存</h3><p>1、一级缓存：指的是mybatis中sqlSession对象的缓存，当我们执行查询以后，查询的结果会同时存入sqlSession中，再次查询的时候，先去sqlSession中查询，有的话直接拿出，当sqlSession消失时，mybatis的一级缓存也就消失了，当调用sqlSession的修改、添加、删除、commit()、close()等方法时，会清空一级缓存。</p>
<p>2、二级缓存：指的是mybatis中的sqlSessionFactory对象的缓存，由同一个sqlSessionFactory对象创建的sqlSession共享其缓存，但是其中缓存的是数据而不是对象。当命中二级缓存时，通过存储的数据构造成对象返回。查询数据的时候，查询的流程是二级缓存 &gt; 一级缓存 &gt; 数据库。</p>
<p>3、如果开启了二级缓存，sqlSession进行close()后，才会把sqlSession一级缓存中的数据添加到二级缓存中，为了将缓存数据取出执行反序列化，还需要将要缓存的pojo实现Serializable接口，因为二级缓存数据存储介质多种多样，不一定只存在内存中，也可能存在硬盘中。</p>
<p>4、mybatis框架主要是围绕sqlSessionFactory进行的，具体的步骤：</p>
<ol>
<li>定义一个configuration对象，其中包含数据源、事务、mapper文件资源以及影响数据库行为属性设置settings。</li>
<li>通过配置对象，则可以创建一个sqlSessionFactoryBuilder对象。</li>
<li>通过sqlSessionFactoryBuilder获得sqlSessionFactory实例。</li>
<li>通过sqlSessionFactory实例创建qlSession实例，通过sqlSession对数据库进行操作。</li>
</ol>
<p>5、代码实例</p>
<p>mybatis-config.xml</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//读取mybatis-config.xml文件</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">            <span class="comment">//初始化mybatis,创建SqlSessionFactory类的实例</span></span><br><span class="line">            <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">            <span class="comment">//创建session实例</span></span><br><span class="line">            <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 接下来在这里做很多事情,到目前为止,目的已经达到得到了SqlSession对象.通过调用SqlSession里面的方法,</span></span><br><span class="line"><span class="comment">             * 可以测试MyBatis和Dao层接口方法之间的正确性,当然也可以做别的很多事情,在这里就不列举了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//插入数据</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setC_password(<span class="string">"123"</span>);</span><br><span class="line">            user.setC_username(<span class="string">"123"</span>);</span><br><span class="line">            user.setC_salt(<span class="string">"123"</span>);</span><br><span class="line">            <span class="comment">//第一个参数为方法的完全限定名:位置信息+映射文件当中的id</span></span><br><span class="line">            session.insert(<span class="string">"com.cn.dao.UserMapping.insertUserInformation"</span>, user);</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            session.commit();</span><br><span class="line">            <span class="comment">//关闭session</span></span><br><span class="line">            session.close();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="145、mybatis如何防止sql注入"><a href="#145、mybatis如何防止sql注入" class="headerlink" title="145、mybatis如何防止sql注入"></a>145、mybatis如何防止sql注入</h3><p>注意：但凡是sql注入漏洞的程序，都是因为程序要接受来自客户端用户输入的变量或URL传递的参数，并且这个变量或参数是组成sql语句的一部分，对于用户输入的内容或传递的参数，我们应该要时刻保持警惕，这是安全领域里的【外部数据不可信任】的原则，纵观web安全领域的各种攻击方式，大多数都是因为开发者违反了这个原则而导致的，所以自然能想到，就是变量的检测、过滤、验证下手，确保变量是开发者所预想的。</p>
<p>1、检查变量数据类型和格式</p>
<p>数据类型检查，sql执行前，要进行数据类型检查，如果是邮箱，参数就必须是邮箱的格式，如果是日期，就必须是日期格式；</p>
<p>只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度上可以避免SQL注入攻击。</p>
<p>如果上述例子中id是int型的，效果会怎样呢？无法注入，因为输入注入参数会失败。比如上述中的name字段，我们应该在用户注册的时候，就确定一个用户名规则，比如5-20个字符，只能由大小写字母、数字以及汉字组成，不包含特殊字符。此时我们应该有一个函数来完成统一的用户名检查。不过，仍然有很多场景并不能用到这个方法，比如写博客，评论系统，弹幕系统，必须允许用户可以提交任意形式的字符才行，否则用户体验感太差了。</p>
<p>2、过滤特殊符号</p>
<p>3、绑定变量，使用预编译语句</p>
<p>146、为什么要使用 hibernate？</p>
<ol>
<li>hibernate对jdbc进行了封装，简化了JDBC的重复性代码；</li>
<li>hibernate对dao有一个封装类hibernateTemplate，可以继承它，实现简单的CRUD接口。</li>
<li>hibernate使用注解和配置文件，可以对实体类和映射文件进行映射；</li>
<li>hibernate有事务管理机制，保证了数据的安全性；</li>
<li>hibernate有一级缓存和二级缓存；</li>
</ol>
<h3 id="146、hibernate-中如何在控制台查看打印的-sql-语句？"><a href="#146、hibernate-中如何在控制台查看打印的-sql-语句？" class="headerlink" title="146、hibernate 中如何在控制台查看打印的 sql 语句？"></a>146、hibernate 中如何在控制台查看打印的 sql 语句？</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.show_sql=true</span><br><span class="line">spring.jpa.properties.hibernate.format_sql=true</span><br><span class="line">spring.jpa.properties.hibernate.use_sql_comments=true</span><br></pre></td></tr></tbody></table></figure>

<h3 id="147、hibernate-有几种查询方式？"><a href="#147、hibernate-有几种查询方式？" class="headerlink" title="147、hibernate 有几种查询方式？"></a>147、hibernate 有几种查询方式？</h3><p>1、导航对象图查询：根据已加载的对象，导航到其他对象。</p>
<p>例如，对于已经加载的Customer对象，调用它的getOrders().iterator()方法就可以导航到所有关联的Order对象，假如在关联级别使用了延迟加载检索策略，那么首次执行此方法时，hibernate会从数据库中加载关联的Order对象，否则就从缓存中获得Order对象。</p>
<p>2、OID方式：按照对象的OID来检索对象</p>
<p>Session的get()和load()方法提供了这种功能，如果在应用程序中先知道了OID，就可以使用这种方式检索对象。</p>
<p>get()和load()的用法完全一样，都需要两个参数，一个是持久化对象类名class，一个是行号OID，返回固定的某一行的数据，但是需要注意的是，当输入的OID不存在时，get()会返回一个空对象，load()则直接报错。</p>
<p>3、HQL检索方式：（hibernate query language）</p>
<p>使用面向对象的HQL查询语言，session的find()方法用于执行HQL查询语句。此外，hibernate还提供了query接口，它是hibernate提供的专门的HQL查询接口，能够执行各种复杂的HQL查询语句。</p>
<p>它具备以下功能：</p>
<ol>
<li>在查询语句中设定各种查询条件；</li>
<li>支持投影查询，即仅检索出对象的部分属性；</li>
<li>支持分页查询；</li>
<li>支持连接查询；</li>
<li>支持分组查询；</li>
<li>提供内置函数；</li>
<li>能够调用用户自定义的SQL函数；</li>
<li>支持子查询；</li>
<li>支持动态绑定参数；</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(<span class="string">"from UserPo"</span>）；</span><br></pre></td></tr></tbody></table></figure>

<p>获得一个query对象，注意参数字符串中不是一个SQL语句，from后面的是持久化对象名称；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br></pre></td></tr></tbody></table></figure>

<p>就可以获取数据库中对应表的数据集合。</p>
<p>4、QBC检索方式：Query By Criteria的API来检索对象</p>
<p>这种API封装了基于字符串形式的查询语句，提供了更加面向对象的接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：<span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> session.createCriteria(UserPo.class);</span><br></pre></td></tr></tbody></table></figure>

<p>创建一个Criteria对象，参数是所关联的持久化对象，criteria.add(Restrictions.ge(“id”,2));将查询条件加入对象中，后面的操作就和Query对象一样了。</p>
<p>5、本地SQL</p>
<p>使用本地数据库的SQL查询语句，hibernate会负责把检索到的JDBC ResultSet结果映射为持久化对象图。</p>
<h3 id="148、hibernate-实体类可以被定义为-final-吗？"><a href="#148、hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="148、hibernate 实体类可以被定义为 final 吗？"></a>148、hibernate 实体类可以被定义为 final 吗？</h3><p>可以将hibernate的实体类定义为final，但这种做法不好。</p>
<p>因为hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为Java不允许对final类进行扩展，所以hibernate就无法再使用代理了，如此一来就限制了使用可以提升性能的手段。</p>
<p>不过，如果你的持久化类实现了一个接口，而且在该接口中声明了所有定义于实体类中的所有public的方法的话，就能避免出现前面所说的不利后果。</p>
<h3 id="149、在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#149、在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h3><p>hibernate是面向对象的ORM，所以一般定义成封装类型，要看数据库中的定义，如果数据库中有对应字段存在null值，就要定义Integer。也可以定义基本类型，在配置文件中写清楚即可。</p>
<h3 id="150、什么是-Spring-Boot？Spring-Boot-有哪些优点？"><a href="#150、什么是-Spring-Boot？Spring-Boot-有哪些优点？" class="headerlink" title="150、什么是 Spring Boot？Spring Boot 有哪些优点？"></a>150、什么是 Spring Boot？Spring Boot 有哪些优点？</h3><p>1、Spring Boot简介</p>
<p>基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突、引用的不稳定性得到了解决。</p>
<p>2、Spring Boot 有哪些优点？</p>
<ol>
<li>快速构建项目，可以选一些必要的组件；</li>
<li>对主流框架的无配置集成；</li>
<li>内嵌Tomcat容器，项目可独立运行；</li>
<li>删除了繁琐的xml配置文件；</li>
<li>极大地提高了开发和部署效率；</li>
<li>提供starter，简化maven配置；</li>
</ol>
<p>3、SpringBoot有哪些缺点？</p>
<ol>
<li>版本迭代速度快，一些模块改动很大；</li>
<li>由于无须配置，报错时很难定位；</li>
</ol>
<h3 id="151、Spring-Boot-中的监视器是什么？"><a href="#151、Spring-Boot-中的监视器是什么？" class="headerlink" title="151、Spring Boot 中的监视器是什么？"></a>151、Spring Boot 中的监视器是什么？</h3><p>监听器也叫listener，是servlet的监听器，可以用于监听web应用程序中某些对象的创建、销毁、增加、修改、删除等动作的发生，然后做出相应的响应处理。当范围对象的状态发生变化时，服务器自动调用监听器对象中的方法，常用于系统加载时进行信息初始化，统计在线人数和在线用户，统计网站的访问量。</p>
<p>配置监听器的方法：</p>
<p>通过@Component把监听器加入Spring容器中管理；<br>在application.properties中添加context.listener.classes配置；<br>在方法上加@EventListener注解；</p>
<h3 id="152、什么是-YAML？"><a href="#152、什么是-YAML？" class="headerlink" title="152、什么是 YAML？"></a>152、什么是 YAML？</h3><p>YAML是JSON的一个超集，可以非常方便地将外部配置以层次结构形式存储起来。YAML可以作为properties配置文件的替代。</p>
<p>YAML使用的注意事项：</p>
<ol>
<li>在properties文件中是以”.”进行分割的，在yml中是用”.”进行分割的；</li>
<li>yml的数据格式和json的格式很像，都是K-V格式，并且通过”:”进行赋值；</li>
<li>每个冒号后面一定要加一个空格；</li>
</ol>
<h3 id="153、如何使用-Spring-Boot-实现分页和排序？"><a href="#153、如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="153、如何使用 Spring Boot 实现分页和排序？"></a>153、如何使用 Spring Boot 实现分页和排序？</h3><p>使用Spring Data Jpa可以实现将可分页的传递给存储库方法。</p>
<h3 id="154、如何使用-Spring-Boot-实现异常处理？"><a href="#154、如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="154、如何使用 Spring Boot 实现异常处理？"></a>154、如何使用 Spring Boot 实现异常处理？</h3><p>1、使用 @ExceptionHandler 注解处理局部异常(只能处理当前controller中的ArithmeticException和NullPointerException异常，缺点就是只能处理单个controller的异常)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlerController</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping("/excep")</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">exceptionMethod</span><span class="params">(Model model)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">		String a=<span class="literal">null</span>;</span><br><span class="line">		System.out.println(a.charAt(<span class="number">1</span>));</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">		model.addAttribute(<span class="string">"message"</span>, <span class="string">"没有抛出异常"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ExceptionHandler(value = {ArithmeticException.class,NullPointerException.class})</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">arithmeticExceptionHandle</span><span class="params">(Model model, Exception e)</span> {</span><br><span class="line">		model.addAttribute(<span class="string">"message"</span>, <span class="string">"@ExceptionHandler"</span> + e.getMessage());</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、使用 @ControllerAdvice + @ExceptionHandler 注解处理全局异常(value后面可以填写数组)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerAdviceException</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ExceptionHandler(value = {NullPointerException.class})</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">NullPointerExceptionHandler</span><span class="params">(Model model, Exception e)</span> {</span><br><span class="line">		model.addAttribute(<span class="string">"message"</span>, <span class="string">"@ControllerAdvice + @ExceptionHandler :"</span> + e.getMessage());</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、配置 SimpleMappingExceptionResolver 类处理异常（配置类）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMappingException</span> {</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title function_">getSimpleMappingExceptionResolver</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">		<span class="type">SimpleMappingExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">		<span class="type">Properties</span> <span class="variable">mappings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		<span class="comment">//第一个参数为异常全限定名，第二个为跳转视图名称</span></span><br><span class="line">		mappings.put(<span class="string">"java.lang.NullPointerException"</span>, <span class="string">"index"</span>);</span><br><span class="line">		mappings.put(<span class="string">"java.lang.ArithmeticException"</span>, <span class="string">"index"</span>);</span><br><span class="line">		<span class="comment">//设置异常与视图映射信息的</span></span><br><span class="line">		resolver.setExceptionMappings(mappings);</span><br><span class="line">		<span class="keyword">return</span> resolver;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、实现 HandlerExceptionResolver 接口处理异常</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerException</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> {</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> {</span><br><span class="line"></span><br><span class="line">		<span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">		modelAndView.addObject(<span class="string">"message"</span>, <span class="string">"实现HandlerExceptionResolver接口"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断不同异常类型，做不同视图跳转</span></span><br><span class="line">		<span class="keyword">if</span>(ex <span class="keyword">instanceof</span> NullPointerException){</span><br><span class="line">			modelAndView.setViewName(<span class="string">"index"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(ex <span class="keyword">instanceof</span> ArithmeticException){</span><br><span class="line">			modelAndView.setViewName(<span class="string">"index"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> modelAndView;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="155、单点登录"><a href="#155、单点登录" class="headerlink" title="155、单点登录"></a>155、单点登录</h3><p>1、概念</p>
<p>单点登录SSO，说的是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。</p>
<p>2、单点登录的要点</p>
<p>存储信任；<br>验证信任；</p>
<p>3、实现单点登录的三种方式</p>
<p>（1）以cookie作为凭证</p>
<p>最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。</p>
<p>用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie进行校验，校验通过则登录当前用户。</p>
<p>缺点：</p>
<p>cookie不安全</p>
<p>通过加密可以保证安全性，但如果对方掌握了解密算法就完蛋了。</p>
<p>不能跨域实现免登</p>
<p>（2）通过JSONP实现</p>
<p>对于跨域问题，可以使用JSONP实现。用户在父应用中登录后，跟session匹配的cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。</p>
<p>缺点：</p>
<p>这种方法虽然能解决跨域问题，但是治标不治本，没有解决cookie安全性的问题。</p>
<p>（3）通过页面重定向的方式</p>
<p>最后一种介绍的方式，是通过父应用和子应用来回重定向进行通信，实现信息的安全传递。</p>
<p>父应用提供一个GET方式的登录接口A（此时的父应用接口固定，攻击者无法去伪造），用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个登录页面，用户输入账号密码进行登录，如果用户已经登录了，则生成加密的token，并且重定向到子应用提供的验证token的接口B（此时的子应用接口固定，攻击者无法去伪造），通过解密和校验之后，子应用登录当前用户。</p>
<p>缺点：</p>
<p>这种方式较前面的两种方式，是解决了安全性和跨域的问题，但是并没有前面两种方式简单，安全与方便，本来就是矛盾的。</p>
<p>4、使用独立登录系统</p>
<p>一般来说，大型应用会把授权的逻辑和用户信息的相关逻辑独立成一个应用，称为用户中心。用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕后返回凭证，第三方应用验证凭证，通过后就登录用户。</p>
<p>5、sso（单点登录）与OAuth2.0（授权）的区别？</p>
<p>（1）sso（单点登录）</p>
<p>通常处理的是一个公司的不同应用间的访问登录问题，如企业应用有很多子系统，只需登录一个系统，就可以实现不同子系统间的跳转，而避免了登录操作；<br>通过cookie、jsonp、重定向来实现；</p>
<p>（2）OAuth2.0（授权）</p>
<p>解决的是服务提供方（如微信）给第三方应用授权的问题，简称微信登录；<br>是一种具体的协议，只是为用户资源的授权提供了一个安全的、开放的而又简易的标准，OAuth2.0（授权）为客户开发者开发web应用，桌面应用程序，移动应用及客厅设备提供特定的授权流程。</p>
<h3 id="156、Spring-Boot比Spring多哪些注解"><a href="#156、Spring-Boot比Spring多哪些注解" class="headerlink" title="156、Spring Boot比Spring多哪些注解"></a>156、Spring Boot比Spring多哪些注解</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guorui_java/article/details/107379648" title="Spring Boot常用注解（绝对经典）">Spring Boot常用注解（绝对经典）</a></p>
<h3 id="157、打包和部署"><a href="#157、打包和部署" class="headerlink" title="157、打包和部署"></a>157、打包和部署</h3><p>Spring和Spring Boot都支持maven和Gradle通用打包管理技术。</p>
<p>Spring Boot相对Spring的一些优点：</p>
<ul>
<li>提供嵌入式容器支持；</li>
<li>使用命令java -jar独立运行jar；</li>
<li>部署时可以灵活指定配置文件；</li>
</ul>
<p>最近项目是分布式的项目，都是通过分项目打包部署，然后部署在docker中运行。</p>
<h3 id="158、Spring-Boot如何访问不同的数据库"><a href="#158、Spring-Boot如何访问不同的数据库" class="headerlink" title="158、Spring Boot如何访问不同的数据库"></a>158、Spring Boot如何访问不同的数据库</h3><p>可以使用druidDataSource创建DataSource，然后通过jdbcTemplate执行sql。</p>
<h3 id="159、查询网站在线人数"><a href="#159、查询网站在线人数" class="headerlink" title="159、查询网站在线人数"></a>159、查询网站在线人数</h3><p>通过监听session对象的方式来实现在线人数的统计和在线人信息展示，并且让超时的自动销毁。</p>
<blockquote>
<p>对session对象实现监听，首先必须继承HttpSessionListener类，该程序的基本原理就是当浏览器访问页面的时候必定会产生一个session对象，当关闭该页面的时候必然会删除session对象。所以每当产生一个新的session对象就让在线人数+1，当删除一个session对象就让在线人数-1。<br>还要继承一个HttpSessionAttributeListener，来实现对其属性的监听。分别实现attributeAdded方法，attributeReplace方法以及attributeRemove方法。<br>sessionCreated//新建一个会话的时候触发，也可以说是客户端第一次喝服务器交互时触发。<br>sessionDestroyed//销毁会话的时候，一般来说只有某个按钮触发进行销毁，或者配置定时销毁。<br>HttpSessionAttributeListener有三个方法需要实现<br>attributeAdded//在session中添加对象时触发此操作 笼统的说就是调用setAttribute这个方法时候会触发的<br>attributeRemoved//修改、删除session中添加对象时触发此操作 笼统的说就是调用 removeAttribute这个方法时候会触发的<br>attributeReplaced//在Session属性被重新设置时。</p>
</blockquote>
<h3 id="160、easyExcel如何实现"><a href="#160、easyExcel如何实现" class="headerlink" title="160、easyExcel如何实现"></a>160、easyExcel如何实现</h3><p>异步读取<br>新建一个 ExcelModelListener 监听类出来，并且 继承 AnalysisEventListener 类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zh.oukele.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> com.zh.oukele.model.ExcelMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *  监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelModelListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(ExcelMode data, AnalysisContext context)</span> {</span><br><span class="line">        System.out.println(<span class="string">"解析到一条数据:{ "</span>+ data.toString() +<span class="string">" }"</span>);</span><br><span class="line">        list.add(data);</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt;= BATCH_COUNT) {</span><br><span class="line">            saveData( count );</span><br><span class="line">            list.clear();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> {</span><br><span class="line">        saveData( count );</span><br><span class="line">        System.out.println(<span class="string">"所有数据解析完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">" count ："</span> + count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">(<span class="type">int</span> count)</span> {</span><br><span class="line">        System.out.println(<span class="string">"{ "</span>+ count +<span class="string">" }条数据，开始存储数据库！"</span> + list.size());</span><br><span class="line">        System.out.println(<span class="string">"存储数据库成功！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="161、什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#161、什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="161、什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>161、什么是 Swagger？你用 Spring Boot 实现了它吗？</h3><p>Swagger是用于生成RestFul Web服务的可视化表示工具，它使文档和服务器可视化更新；</p>
<p>当定义好Swagger后，可以调用服务端接口，来查看接口的返回值，验证返回数据的正确性；</p>
<h3 id="162、数据库的三范式是什么？"><a href="#162、数据库的三范式是什么？" class="headerlink" title="162、数据库的三范式是什么？"></a>162、数据库的三范式是什么？</h3><p>1、列不可再分；</p>
<p>2、每一行数据只做一件事，只与一列相关，主键；</p>
<p>3、每个属性都与主键有直接关系，而不是间接关系；</p>
<p>三大范式只是设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情结，当然要特殊对待，数据库设计最重要的是看需求和性能，需求&gt;性能&gt;表结构。</p>
<p>所以不能一味的追求三范式建立数据库。</p>
<h3 id="163、一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？"><a href="#163、一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="163、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？"></a>163、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</h3><p>一般情况下，我们创建的表类型是InnoDB。</p>
<p>不重启MySQL，如果新增一条记录，id是8；<br>重启，ID是6；因为InnoDB表只把自增主键的最大ID记录在内存中，如果重启，已删除的最大ID会丢失。<br>如果表类型是MyISAM，重启之后，最大ID也不会丢失，ID是8；</p>
<p>InnoDB必须有主键（建议使用自增主键，不用UUID，自增主键索引查询效率高）、支持外键、支持事务、支持行级锁。</p>
<p>系统崩溃后，MyISAM很难恢复；</p>
<p>综合考虑，优先选择InnoDB，MySQL默认也是InnoDB。</p>
<h3 id="164、如何获取当前数据库版本？"><a href="#164、如何获取当前数据库版本？" class="headerlink" title="164、如何获取当前数据库版本？"></a>164、如何获取当前数据库版本？</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>MySQL,,mysql <span class="operator">-</span>v</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>Oracle</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$version;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="165、说一下-ACID-是什么？"><a href="#165、说一下-ACID-是什么？" class="headerlink" title="165、说一下 ACID 是什么？"></a>165、说一下 ACID 是什么？</h3><p>ACID是数据库事务执行的四大基本要素，包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<p>1、原子性</p>
<p>整个事务中的所有操作，要么全部完成，要不全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被roolback回滚到事务开始前的状态，就像这个事务从未执行过一样。</p>
<p>2、一致性</p>
<p>事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。</p>
<p>3、隔离性</p>
<p>隔离状态执行事务，使他们好像是系统在给定时间内执行的唯一操作。</p>
<p>如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性确保每一个事务在系统中认为只有自己在使用系统。这种属性称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</p>
<p>4、持久性</p>
<p>一个成功的事务将永久的改变系统的状态。</p>
<h3 id="166、char-和-varchar-的区别是什么？"><a href="#166、char-和-varchar-的区别是什么？" class="headerlink" title="166、char 和 varchar 的区别是什么？"></a>166、char 和 varchar 的区别是什么？</h3><ol>
<li>char的长度是固定的，varchar的长度的可变的；</li>
<li>char的效率比varchar的效率高；</li>
<li>char占用空间比varchar大，char在查询时需要使用trim；</li>
</ol>
<h3 id="167、float-和-double-的区别是什么？"><a href="#167、float-和-double-的区别是什么？" class="headerlink" title="167、float 和 double 的区别是什么？"></a>167、float 和 double 的区别是什么？</h3><p>1、float 和 double 的区别是什么？</p>
<p>（1）内存中占有的字节数不同</p>
<p>单精度浮点数在内存中占有4个字节；</p>
<p>双精度浮点数在内存中占有8个字节；</p>
<p>（2）有效数字位数不同</p>
<p>单精度浮点数有效数字8位；</p>
<p>双精度浮点数有效数字16位；</p>
<p>（3）数值取值范围不同</p>
<p>单精度浮点数的表示范围：-3.40E+38~3.40E+38</p>
<p>双精度浮点数的表示范围：-1.79E+308~-1.79E+308</p>
<p>（4）在程序中处理速度不同</p>
<p>一般来说，CPU处理单精度浮点数的速度比双精度浮点数的速度快</p>
<p>如果不声明，默认小数是double类型，如果想用float，要进行强转；</p>
<p>2、例如</p>
<p>float f = 1.3；会编译报错，正确的写法是float f = (float)1.3;或者float a = 1.3f;（f或F都可以不区分大小写）</p>
<p>3、注意</p>
<p>float是八位有效数字，第七位会四舍五入；</p>
<p>4、面试题</p>
<p>（1）java中3*0.1==0.3将会返回什么？true还是false？</p>
<p>答：返回false，因为浮点数不能完全精确的表示出来，一般会损失精度；</p>
<p>（2）java中float f = 3.4;是否正确？</p>
<p>答：不正确。因为3.4是双精度浮点数，将双精度赋给单精度属于向下转型，会造成精度损失，因此需要强制类型转换float=（float）3.4;或者写成float f = 3.4f;</p>
<h3 id="168、Oracle分页sql"><a href="#168、Oracle分页sql" class="headerlink" title="168、Oracle分页sql"></a>168、Oracle分页sql</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#不带排序的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> ROWNUM <span class="keyword">AS</span> rowno, t.<span class="operator">*</span> <span class="keyword">FROM</span> worker t <span class="keyword">where</span> ROWNUM  <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#带排序的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> tt.<span class="operator">*</span>, ROWNUM <span class="keyword">AS</span> rowno <span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> t.<span class="operator">*</span> <span class="keyword">FROM</span> worker t <span class="keyword">ORDER</span> <span class="keyword">BY</span> wkid <span class="keyword">aSC</span>) tt <span class="keyword">WHERE</span> ROWNUM <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="169、数据库如何保证主键唯一性"><a href="#169、数据库如何保证主键唯一性" class="headerlink" title="169、数据库如何保证主键唯一性"></a>169、数据库如何保证主键唯一性</h3><p>1、主键约束</p>
<p>主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）；</p>
<p>2、唯一性约束</p>
<p>保证一个字段或者一组字段里的数据都与表中其它行的对应数据不同。和主键约束不同，唯一性约束允许为null，但是只能有一行；</p>
<p>3、唯一性索引</p>
<p>不允许具有索引值相同的行，从而禁止重复的索引和键值；</p>
<p>4、三者的区别</p>
<ul>
<li>约束是用来检查数据的正确性；</li>
<li>索引是用来优化查询的；</li>
<li>创建唯一性约束会创建一个约束和一个唯一性索引；</li>
<li>创建唯一性索引只会创建一个唯一性索引；</li>
<li>主键约束和唯一性约束都会创建一个唯一性索引。</li>
</ul>
<h3 id="170、如何设计数据库"><a href="#170、如何设计数据库" class="headerlink" title="170、如何设计数据库"></a>170、如何设计数据库</h3><p>1、数据库设计最起码要占用这个项目开发的40%以上的时间</p>
<p>2、数据库设计不仅仅停留在页面demo的表面</p>
<p>页面内容所需字段，在数据库设计中只是一部分，还有系统运转、模块交互、中转数据、表之间的联系等等所需要的字段，因此数据库设计绝对不是简单的基本数据存储，还有逻辑数据存储。</p>
<p>3、数据库设计完成后，项目80%的设计开发都要存在你的脑海中</p>
<p>每个字段的设计都要有他存在的意义，要清楚的知道程序中如何去运用这些字段，多张表的联系在程序中是如何体现的。</p>
<p>4、数据库设计时就要考虑效率和优化问题</p>
<p>数据量大的表示粗粒度的，会冗余一些必要字段，达到用最少的表，最弱的表关系去存储海量的数据。大数据的表要建立索引，方便查询。对于含有计算、数据交互、统计这类需求时，还有考虑是否有必要采用存储过程。</p>
<p>5、添加必要的冗余字段</p>
<p>像创建时间、修改时间、操作用户IP、备注这些字段，在每张表中最好都有，一些冗余的字段便于日后维护、分析、拓展而添加。</p>
<p>6、设计合理的表关联</p>
<p>若两张表之间的关系复杂，建议采用第三张映射表来关联维护两张表之间的关系，以降低表之间的直接耦合度。</p>
<p>7、设计表时不加主外键等约束关联，系统编码阶段完成后再添加约束性关联</p>
<p>8、选择合适的主键生成策略</p>
<p>数据库的设计难度其实比单纯的技术实现难很多，他充分体现了一个人的全局设计能力和掌控能力，最后说一句，数据库设计，很重要，很复杂。</p>
<h3 id="171、性别是否适合做索引"><a href="#171、性别是否适合做索引" class="headerlink" title="171、性别是否适合做索引"></a>171、性别是否适合做索引</h3><p>区分度不高的字段不适合做索引，因为索引页是需要有开销的，需要存储的，不过这类字段可以做联合索引的一部分。</p>
<h3 id="172、如何查询重复的数据"><a href="#172、如何查询重复的数据" class="headerlink" title="172、如何查询重复的数据"></a>172、如何查询重复的数据</h3><p>1、查询重复的单个字段（group by）</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 重复字段A, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表 <span class="keyword">group</span> <span class="keyword">by</span> 重复字段A <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>2、查询重复的多个字段（group by）</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 重复字段A, 重复字段B, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表 <span class="keyword">group</span> <span class="keyword">by</span> 重复字段A, 重复字段B <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="173、数据库一般会采取什么样的优化方法？"><a href="#173、数据库一般会采取什么样的优化方法？" class="headerlink" title="173、数据库一般会采取什么样的优化方法？"></a>173、数据库一般会采取什么样的优化方法？</h3><p>1、选取适合的字段属性</p>
<ul>
<li>为了获取更好的性能，可以将表中的字段宽度设得尽可能小。</li>
<li>尽量把字段设置成not null</li>
<li>执行查询的时候，数据库不用去比较null值。</li>
<li>对某些省份或者性别字段，将他们定义为enum类型，enum类型被当做数值型数据来处理，而数值型数据被处理起来的速度要比文本类型块很多。</li>
</ul>
<p>2、使用join连接代替子查询</p>
<p>3、使用联合union来代替手动创建的临时表</p>
<p>注意：union用法中，两个select语句的字段类型要匹配，而且字段个数要相同。</p>
<p>4、事务</p>
<p>要么都成功，要么都失败。</p>
<p>可以保证数据库中数据的一致性和完整性。事务以begin开始，commit关键字结束。</p>
<p>如果出错，rollback命令可以将数据库恢复到begin开始之前的状态。</p>
<p>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方式为用户提供一种安全的访问方式，这样就可以保证用户的操作不被其他的用户干扰。</p>
<p>5、锁定表</p>
<p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在大应用中。</p>
<p>由于在事务执行的过程中，数据库会被锁定，因此其它用户只能暂时等待直到事务结束。</p>
<p>有的时候可以用锁定表的方法来获得更好的性能，</p>
<p>共享锁：其它用户只能看，不能修改</p>
<p>lock table person in share mode；</p>
<p>对于通过lock table 命令主动添加的锁来说，如果要释放它们，只需发出rollback命令即可。</p>
<p>6、使用外键</p>
<p>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性，这个时候可以使用外键。</p>
<p>7、使用索引</p>
<p>索引是提高数据库查询速度的常用方法，尤其是查询语句中包含max()、min()、order by这些命令的时候，性能提高更为显著。</p>
<p>一般来说索引应该建在常用于join、where、order by的字段上。尽量不要对数据库中含有大量重复的值得字段建立索引。</p>
<p>8、优化的查询语句</p>
<p>在索引的字段上尽量不要使用函数进行操作。</p>
<p>尽量不要使用like关键字和通配符，这样做法很简单，但却是以牺牲性能为代价的。</p>
<p>避免在查询中进行自动类型转换，因为类型转换也会使索引失效。</p>
<h3 id="174、索引怎么定义，分哪几种"><a href="#174、索引怎么定义，分哪几种" class="headerlink" title="174、索引怎么定义，分哪几种"></a>174、索引怎么定义，分哪几种</h3><ol>
<li>b-tree索引，如果不建立索引的情况下，oracle就自动给每一列都加一个B 树索引;</li>
<li>normal：普通索引</li>
<li>unique：唯一索引</li>
<li>bitmap：位图索引，位图索引特定于只有几个枚举值的情况，比如性别字段；</li>
<li>基于函数的索引</li>
</ol>
<h3 id="175、mysql-的内连接、左连接、右连接有什么区别？"><a href="#175、mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="175、mysql 的内连接、左连接、右连接有什么区别？"></a>175、mysql 的内连接、左连接、右连接有什么区别？</h3><ol>
<li>内连接,显示两个表中有联系的所有数据;</li>
<li>左链接,以左表为参照,显示所有数据,右表中没有则以null显示</li>
<li>右链接,以右表为参照显示数据，,左表中没有则以null显示</li>
</ol>
<h3 id="176、RabbitMQ的使用场景有哪些？"><a href="#176、RabbitMQ的使用场景有哪些？" class="headerlink" title="176、RabbitMQ的使用场景有哪些？"></a>176、RabbitMQ的使用场景有哪些？</h3><p>1、解决异步问题</p>
<p>例如用户注册，发送邮件和短信反馈注册成功，可以使用RabbitMQ消息队列，用户无需等待反馈。</p>
<p>2、服务间解耦</p>
<p>订单系统和库存系统，中间加入RabbitMQ消息队列，当库存系统出现问题时，订单系统依旧能正常使用，降低服务间耦合度。</p>
<p>3、秒杀系统</p>
<p>利用RabbitMQ的最大值，实现秒杀系统。</p>
<h3 id="177、RabbitMQ有哪些重要的角色？有哪些重要的组件？"><a href="#177、RabbitMQ有哪些重要的角色？有哪些重要的组件？" class="headerlink" title="177、RabbitMQ有哪些重要的角色？有哪些重要的组件？"></a>177、RabbitMQ有哪些重要的角色？有哪些重要的组件？</h3><p>1、RabbitMQ有哪些重要的角色？</p>
<p>客户端、RabbitMQ、服务端。</p>
<p>2、有哪些重要的组件？</p>
<p>（1）connectionFactory（连接管理器）</p>
<p>应用程序与RabbitMQ之间建立连接的管理器。</p>
<p>（2）Channel（信道）</p>
<p>消息推送使用的信道。</p>
<p>（3）RoutingKey（路由键）</p>
<p>用于把生产者的数据分配到交换机上。</p>
<p>（4）Exchange（交换机）</p>
<p>用于接受和分配消息。</p>
<p>（5）BindKey（绑定键）</p>
<p>用于把交换机的消息绑定到队列上</p>
<p>（6）Queue（队列）</p>
<p>用于存储生产者消息。</p>
<h3 id="178、RabbitMQ中-vhost-的作用是什么？"><a href="#178、RabbitMQ中-vhost-的作用是什么？" class="headerlink" title="178、RabbitMQ中 vhost 的作用是什么？"></a>178、RabbitMQ中 vhost 的作用是什么？</h3><p>vhost可以理解为mini版的RabbitMQ，其内部均含有独立的交换机、绑定、队列，最重要的是拥有独立的权限系统，可以做到vhost范围内的用户控制。从RabbitMQ全局考虑，不同的应用可以跑在不同的vhost上，作为不同权限隔离的手段。</p>
<h3 id="179、说一下-jvm-的主要组成部分？及其作用？"><a href="#179、说一下-jvm-的主要组成部分？及其作用？" class="headerlink" title="179、说一下 jvm 的主要组成部分？及其作用？"></a>179、说一下 jvm 的主要组成部分？及其作用？</h3><p>JVM包括类加载子系统、堆、方法区、栈、本地方法栈、程序计数器、直接内存、垃圾回收器、执行引擎。</p>
<p>1、类加载子系统</p>
<p>类加载子系统负责加载class信息，加载的类信息存放于方法区中。</p>
<p>2、直接内存</p>
<p>直接内存是在Java堆外的、直接向系统申请的内存空间。访问直接内存的速度会由于Java堆。出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。</p>
<p>3、垃圾回收器</p>
<p>垃圾回收器可以对堆、方法区、直接内存进行回收。</p>
<p>4、执行引擎</p>
<p>执行引擎负责执行虚拟机的字节码，虚拟机会使用即时编译技术将方法编译成机器码后再执行。</p>
<h3 id="180、说一下-jvm-运行时数据区？"><a href="#180、说一下-jvm-运行时数据区？" class="headerlink" title="180、说一下 jvm 运行时数据区？"></a>180、说一下 jvm 运行时数据区？</h3><p>运行时数据区包括堆、方法区、栈、本地方法栈、程序计数器。</p>
<p>1、堆</p>
<p>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</p>
<p>2、方法区</p>
<p>方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</p>
<p>3、栈</p>
<p>栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>（1）栈帧</p>
<p>每个方法从调用到执行的过程就是一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>（2）局部变量表</p>
<p>用于保存函数的参数和局部变量。</p>
<p>（3）操作数栈</p>
<p>操作数栈又称操作栈，大多数指令都是从这里弹出数据，执行运算，然后把结果压回操作数栈。</p>
<p>4、本地方法栈</p>
<p>与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</p>
<p>5、程序计数器（PC寄存器）</p>
<p>程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</p>
<h3 id="181、什么是类加载器，类加载器有哪些？"><a href="#181、什么是类加载器，类加载器有哪些？" class="headerlink" title="181、什么是类加载器，类加载器有哪些？"></a>181、什么是类加载器，类加载器有哪些？</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210801183934528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70"></p>
<p>1、什么是类加载器？</p>
<p>类加载器负责加载所有的类，其为所有被载入内存的类生成一个java.lang.Class实例对象。</p>
<p>2、类加载器有哪些？</p>
<p>JVM有三种类加载器：</p>
<p>（1）启动类加载器</p>
<p>该类没有父加载器，用来加载Java的核心类，启动类加载器的实现依赖于底层操作系统，属于虚拟机实现的一部分，它并不继承自java.lang.classLoader。</p>
<p>（2）扩展类加载器</p>
<p>它的父类为启动类加载器，扩展类加载器是纯java类，是ClassLoader类的子类，负责加载JRE的扩展目录。</p>
<p>（3）应用程序类加载器</p>
<p>它的父类为扩展类加载器，它从环境变量classpath或者系统属性java.lang.path所指定的目录中加载类，它是自定义的类加载器的父加载器。</p>
<h3 id="182、说一下类加载的执行过程？"><a href="#182、说一下类加载的执行过程？" class="headerlink" title="182、说一下类加载的执行过程？"></a>182、说一下类加载的执行过程？</h3><p>当程序主动使用某个类时，如果该类还未被加载到内存中，JVM会通过加载、连接、初始化3个步骤对该类进行类加载。</p>
<p>1、加载</p>
<p>加载指的是将类的class文件读入到内存中，并为之创建一个java.lang.Class对象。</p>
<p>类的加载由类加载器完成，类加载器由JVM提供，开发者也可以通过继承ClassLoader基类来创建自己的类加载器。</p>
<p>通过使用不同的类加载器可以从不同来源加载类的二进制数据，通常有如下几种来源：</p>
<ol>
<li>从本地文件系统加载</li>
<li>从jar包加载</li>
<li>通过网络加载</li>
<li>把一个Java源文件动态编译，并执行加载</li>
</ol>
<p>2、连接</p>
<p>当类被加载之后，系统为之生成一个对应的Class对象，接着进入连接阶段，连接阶段负责将类的二进制数据合并到JRE中。</p>
<p>类连接又可分为三个阶段：</p>
<p>（1）验证</p>
<p>文件格式验证<br>元数据验证<br>字节码验证<br>符号引用验证</p>
<p>（2）准备</p>
<p>为类的静态变量分配内存，并设置默认初始值。</p>
<p>（3）解析</p>
<p>将类的二进制数据中的符号引用替换成直接引用。</p>
<p>3、初始化</p>
<p>为类的静态变量赋予初始值。</p>
<h3 id="183、JVM的类加载机制是什么？"><a href="#183、JVM的类加载机制是什么？" class="headerlink" title="183、JVM的类加载机制是什么？"></a>183、JVM的类加载机制是什么？</h3><p>JVM类加载机制主要有三种：</p>
<p>1、全盘负责</p>
<p>类加载器加载某个class时，该class所依赖的和引用其它的class也由该类加载器载入。</p>
<p>2、双亲委派</p>
<p>先让父加载器加载该class，父加载器无法加载时才考虑自己加载。</p>
<p>3、缓存机制</p>
<p>缓存机制保证所有加载过的class都会被缓存，当程序中需要某个class时，先从缓存区中搜索，如果不存在，才会读取该类对应的二进制数据，并将其转换成class对象，存入缓存区中。</p>
<p>这就是为什么修改了class后，必须重启JVM，程序所做的修改才会生效的原因。</p>
<h3 id="184、什么是双亲委派模型？"><a href="#184、什么是双亲委派模型？" class="headerlink" title="184、什么是双亲委派模型？"></a>184、什么是双亲委派模型？</h3><p>如果一个类收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器执行，如果父加载器还存在其父加载器，则进一步向上委托，依次递归，请求将最终到达顶层的启动类加载器，如果父类加载器可以完成父加载任务，就成功返回，如果父加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模型。</p>
<p>双亲委派模式的优势：</p>
<ol>
<li>避免重复加载；</li>
<li>考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委派模式传递到启动加载器，而启动加载器在核心Java API中发现同名的类，发现该类已经被加载，就不会重新加载网络传递的Integer类，而直接返回已加载过的Integer.class，这样可以防止核心API库被随意篡改。</li>
</ol>
<h3 id="185、怎么判断对象是否可以被回收？"><a href="#185、怎么判断对象是否可以被回收？" class="headerlink" title="185、怎么判断对象是否可以被回收？"></a>185、怎么判断对象是否可以被回收？</h3><p>1、引用计数算法</p>
<p>（1）判断对象的引用数量</p>
<p>通过判断对象的引用数量来决定对象是否可以被回收；<br>每个对象实例都有一个引用计数器，被引用+1，完成引用-1；<br>任何引用计数为0的对象实例可以被当做垃圾回收；</p>
<p>（2）优缺点</p>
<p>优点：执行效率高，程序受影响较小；<br>缺点：无法检测出循环引用的情况，导致内存泄漏；</p>
<p>2、可达性分析算法</p>
<p>通过判断对象的引用链是否可达来决定对象是否可以被回收。</p>
<p>如果程序无法再引用该对象，那么这个对象肯定可以被回收，这个状态称为不可达。</p>
<p>那么不可达状态如何判断呢？</p>
<p>答案是GC roots，也就是根对象，如果一个对象无法到达根对象的路径，或者说从根对象无法引用到该对象，该对象就是不可达的。</p>
<p>以下三种对象在JVM中被称为GC roots，来判断一个对象是否可以被回收。</p>
<p>（1）虚拟机栈的栈帧</p>
<p>每个方法在执行的时候，JVM都会创建一个相应的栈帧（操作数栈、局部变量表、运行时常量池的引用），当方法执行完，该栈帧就从栈中弹出，这样一来，方法中临时创建的独享就不存在了，或者说没有任何GC roots指向这些临时对象，这些对象在下一次GC的时候便会被回收。</p>
<p>（2）方法区中的静态属性</p>
<p>静态属性数据类属性，不属于任何实例，因此该属性自然会作为GC roots。这要这个class在，该引用指向的对象就一直存在，class也由被回收的时候。</p>
<p>class何时会被回收？</p>
<ol>
<li>堆中不存在该类的任何实例</li>
<li>加载该类的classLoader已经被回收</li>
<li>该类的java.lang.class对象没有在任何地方被引用，也就是说无法通过反射访问该类的信息</li>
</ol>
<p>（3）本地方法栈引用的对象</p>
<h3 id="186、说一下-jvm-有哪些垃圾回收算法？"><a href="#186、说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="186、说一下 jvm 有哪些垃圾回收算法？"></a>186、说一下 jvm 有哪些垃圾回收算法？</h3><p>1、对象是否已死算法</p>
<ul>
<li>引用计数器算法</li>
<li>可达性分析算法</li>
</ul>
<p>2、GC算法</p>
<p>（1）标记清除算法</p>
<p>如果对象被标记后进行清除，会带来一个新的问题–内存碎片化。如果下次有比较大的对象实例需要在堆上分配较大的内存空间时，可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收。</p>
<p>（2）复制算法（Java堆中新生代的垃圾回收算法）</p>
<ol>
<li>先标记待回收内存和不用回收内存；</li>
<li>将不用回收的内存复制到新的内存区域；</li>
<li>就的内存区域就可以被全部回收了，而新的内存区域也是连续的；</li>
</ol>
<p>缺点是损失部分系统内存，因为腾出部分内存进行复制。</p>
<p>（3）标记压缩算法（Java堆中老年代的垃圾回收算法）</p>
<p>对于新生代，大部分对象都不会存活，所以复制算法较高效，但对于老年代，大部分对象可能要继续存活，如果此时使用复制算法，效率会降低。</p>
<p>标记压缩算法首先还是标记，将不用回收的内存对象压缩到内存一端，此时即可清除边界处的内存，这样就能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。</p>
<p>老年代的垃圾回收算法称为”Major GC”。</p>
<h3 id="187、说一下-jvm-有哪些垃圾回收器？"><a href="#187、说一下-jvm-有哪些垃圾回收器？" class="headerlink" title="187、说一下 jvm 有哪些垃圾回收器？"></a>187、说一下 jvm 有哪些垃圾回收器？</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guorui_java/article/details/108405844" title="说一下 jvm 有哪些垃圾回收器？">说一下 jvm 有哪些垃圾回收器？</a></p>
<h3 id="188、JVM栈堆概念，何时销毁对象"><a href="#188、JVM栈堆概念，何时销毁对象" class="headerlink" title="188、JVM栈堆概念，何时销毁对象"></a>188、JVM栈堆概念，何时销毁对象</h3><ol>
<li>类在程序运行的时候就会被加载，方法是在执行的时候才会被加载，如果没有任何引用了，Java自动垃圾回收，也可以用System.gc()开启回收器，但是回收器不一定会马上回收。</li>
<li>静态变量在类装载的时候进行创建，在整个程序结束时按序销毁；</li>
<li>实例变量在类实例化对象时创建，在对象销毁的时候销毁；</li>
<li>局部变量在局部范围内使用时创建，跳出局部范围时销毁；</li>
</ol>
<h3 id="189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h3><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>新生代回收器一般采用的是复制算法，复制算法效率较高，但是浪费内存；</p>
<p>老生代回收器一般采用标记清楚算法，比如最常用的CMS；</p>
<h3 id="190、详细介绍一下-CMS-垃圾回收器？"><a href="#190、详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="190、详细介绍一下 CMS 垃圾回收器？"></a>190、详细介绍一下 CMS 垃圾回收器？</h3><p>CMS 垃圾回收器是Concurrent Mark Sweep，是一种同步的标记-清除，CMS分为四个阶段：</p>
<p>初始标记，标记一下GC Root能直接关联到的对象，会触发”Stop The World”；<br>并发标记，通过GC Roots Tracing判断对象是否在使用中；<br>重新标记，标记期间产生对象的再次判断，执行时间较短，会触发”Stop The World”；<br>并发清除，清除对象，可以和用户线程并发进行；</p>
<h3 id="191、简述分代垃圾回收器是怎么工作的？"><a href="#191、简述分代垃圾回收器是怎么工作的？" class="headerlink" title="191、简述分代垃圾回收器是怎么工作的？"></a>191、简述分代垃圾回收器是怎么工作的？</h3><p>分代回收器分为新生代和老年代，新生代大概占1/3，老年代大概占2/3；</p>
<p>新生代包括Eden、From Survivor、To Survivor；</p>
<p>Eden区和两个survivor区的 的空间比例 为8：1：1 ；</p>
<p>垃圾回收器的执行流程：</p>
<ol>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden + From Survivor 分区，From Survivor 和 To Survivor 分区交换；</li>
<li>每次交换后存活的对象年龄+1，到达15，升级为老年代，大对象会直接进入老年代；</li>
<li>老年代中当空间到达一定占比，会触发全局回收，老年代一般采取标记-清除算法；</li>
</ol>
<h3 id="192、Redis是什么？"><a href="#192、Redis是什么？" class="headerlink" title="192、Redis是什么？"></a>192、Redis是什么？</h3><p>Redis是一个key-value存储系统，它支持存储的value类型相对更多，包括string、list、set、zset（sorted set –有序集合）和hash。这些数据结构都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中，Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。</p>
<h3 id="193、Redis都有哪些使用场景？"><a href="#193、Redis都有哪些使用场景？" class="headerlink" title="193、Redis都有哪些使用场景？"></a>193、Redis都有哪些使用场景？</h3><ol>
<li>Redis是基于内存的nosql数据库，可以通过新建线程的形式进行持久化，不影响Redis单线程的读写操作</li>
<li>通过list取最新的N条数据</li>
<li>模拟类似于token这种需要设置过期时间的场景</li>
<li>发布订阅消息系统</li>
<li>定时器、计数器</li>
</ol>
<h3 id="194、Redis有哪些功能？"><a href="#194、Redis有哪些功能？" class="headerlink" title="194、Redis有哪些功能？"></a>194、Redis有哪些功能？</h3><p>1、基于本机内存的缓存</p>
<p>当调用api访问数据库时，假如此过程需要2秒，如果每次请求都要访问数据库，那将对服务器造成巨大的压力，如果将此sql的查询结果存到Redis中，再次请求时，直接从Redis中取得，而不是访问数据库，效率将得到巨大的提升，Redis可以定时去更新数据（比如1分钟）。</p>
<p>2、如果电脑重启，写入内存的数据是不是就失效了呢，这时Redis还提供了持久化的功能。</p>
<p>3、哨兵（Sentinel）和复制</p>
<p>Sentinel可以管理多个Redis服务器，它提供了监控、提醒以及自动的故障转移功能；</p>
<p>复制则是让Redis服务器可以配备备份的服务器；</p>
<p>Redis也是通过这两个功能保证Redis的高可用；</p>
<p>4、集群（Cluster）</p>
<p>单台服务器资源总是有上限的，CPU和IO资源可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上，但是内存资源怎么办，主从模式只是数据的备份，并不能扩充内存；</p>
<p>现在我们可以横向扩展，让每台服务器只负责一部分任务，然后将这些服务器构成一个整体，对外界来说，这一组服务器就像是集群一样。</p>
<h3 id="195、Redis支持的数据类型有哪些？"><a href="#195、Redis支持的数据类型有哪些？" class="headerlink" title="195、Redis支持的数据类型有哪些？"></a>195、Redis支持的数据类型有哪些？</h3><ol>
<li>字符串</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>zset</li>
</ol>
<h3 id="196、Redis取值存值问题"><a href="#196、Redis取值存值问题" class="headerlink" title="196、Redis取值存值问题"></a>196、Redis取值存值问题</h3><p>1、先把Redis的连接池拿出来</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>(),<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource();</span><br></pre></td></tr></tbody></table></figure>

<p>2、存取值</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line">jedis.get(<span class="string">"key"</span>);</span><br><span class="line">jedis.del(<span class="string">"key"</span>);</span><br><span class="line"><span class="comment">//给一个key叠加value</span></span><br><span class="line">jedis.append(<span class="string">"key"</span>,<span class="string">"value2"</span>);<span class="comment">//此时key的值就是value + value2;</span></span><br><span class="line"><span class="comment">//同时给多个key进行赋值：</span></span><br><span class="line">jedis.mset(<span class="string">"key1"</span>,<span class="string">"value1"</span>,<span class="string">"key2"</span>,<span class="string">"value2"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>3、对map进行操作</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">user.put(<span class="string">"key1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">user.put(<span class="string">"key2"</span>,<span class="string">"value2"</span>);</span><br><span class="line">user.put(<span class="string">"key3"</span>,<span class="string">"value3"</span>);</span><br><span class="line"><span class="comment">//存入</span></span><br><span class="line">jedis.hmset(<span class="string">"user"</span>,user);</span><br><span class="line"><span class="comment">//取出user中key1</span></span><br><span class="line"><span class="type">List</span> <span class="variable">nameMap</span> <span class="operator">=</span> jedis.hmget(<span class="string">"user"</span>,<span class="string">"key1"</span>);</span><br><span class="line"><span class="comment">//删除其中一个键值</span></span><br><span class="line">jedis.hdel(<span class="string">"user"</span>,<span class="string">"key2"</span>);</span><br><span class="line"><span class="comment">//是否存在一个键</span></span><br><span class="line">jedis.exists(<span class="string">"user"</span>);</span><br><span class="line"><span class="comment">//取出所有的Map中的值：</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> jedis.hkeys(<span class="string">"user"</span>).iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.next()){</span><br><span class="line">    jedis.hmget(<span class="string">"user"</span>,iter.next());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="197、Redis为什么是单线程的？"><a href="#197、Redis为什么是单线程的？" class="headerlink" title="197、Redis为什么是单线程的？"></a>197、Redis为什么是单线程的？</h3><ol>
<li>代码更清晰，处理逻辑更简单；</li>
<li>不用考虑各种锁的问题，不存在加锁和释放锁的操作，没有因为可能出现死锁而导致的性能问题；</li>
<li>不存在多线程切换而消耗CPU；</li>
<li>无法发挥多核CPU的优势，但可以采用多开几个Redis实例来完善；</li>
</ol>
<h3 id="198、Redis真的是单线程的吗？"><a href="#198、Redis真的是单线程的吗？" class="headerlink" title="198、Redis真的是单线程的吗？"></a>198、Redis真的是单线程的吗？</h3><p>Redis6.0之前是单线程的，Redis6.0之后开始支持多线程；<br>redis内部使用了基于epoll的多路服用，也可以多部署几个redis服务器解决单线程的问题；<br>redis主要的性能瓶颈是内存和网络；<br>内存好说，加内存条就行了，而网络才是大麻烦，所以redis6内存好说，加内存条就行了；<br>而网络才是大麻烦，所以redis6.0引入了多线程的概念，<br>redis6.0在网络IO处理方面引入了多线程，如网络数据的读写和协议解析等，需要注意的是，执行命令的核心模块还是单线程的。</p>
<h3 id="199、Redis持久化有几种方式？"><a href="#199、Redis持久化有几种方式？" class="headerlink" title="199、Redis持久化有几种方式？"></a>199、Redis持久化有几种方式？</h3><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p>
<p>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</p>
<p>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p>
<p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</p>
<p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p>
<h3 id="200、Redis和-memecache-有什么区别？"><a href="#200、Redis和-memecache-有什么区别？" class="headerlink" title="200、Redis和 memecache 有什么区别？"></a>200、Redis和 memecache 有什么区别？</h3><p>1、Redis相比memecache，拥有更多的数据结构和支持更丰富的数据操作。</p>
<p>（1）Redis支持key-value，常用的数据类型主要有String、Hash、List、Set、Sorted Set。</p>
<p>（2）memecache只支持key-value。</p>
<p>2、内存使用率对比，Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于memecache。</p>
<p>3、性能对比：Redis只使用单核，memecache使用多核。</p>
<p>4、Redis支持磁盘持久化，memecache不支持。</p>
<p>Redis可以将一些很久没用到的value通过swap方法交换到磁盘。</p>
<p>5、Redis支持分布式集群，memecache不支持。</p>
<h3 id="201、Redis支持的-java-客户端都有哪些？"><a href="#201、Redis支持的-java-客户端都有哪些？" class="headerlink" title="201、Redis支持的 java 客户端都有哪些？"></a>201、Redis支持的 java 客户端都有哪些？</h3><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p>
<h3 id="202、jedis-和-redisson-有哪些区别？"><a href="#202、jedis-和-redisson-有哪些区别？" class="headerlink" title="202、jedis 和 redisson 有哪些区别？"></a>202、jedis 和 redisson 有哪些区别？</h3><p>Jedis 和 Redisson 都是Java中对Redis操作的封装。Jedis 只是简单的封装了 Redis 的API库，可以看作是Redis客户端，它的方法和Redis 的命令很类似。Redisson 不仅封装了 redis ，还封装了对更多数据结构的支持，以及锁等功能，相比于Jedis 更加大。但Jedis相比于Redisson 更原生一些，更灵活。</p>
<h3 id="203、什么是缓存穿透？怎么解决？"><a href="#203、什么是缓存穿透？怎么解决？" class="headerlink" title="203、什么是缓存穿透？怎么解决？"></a>203、什么是缓存穿透？怎么解决？</h3><p>1、缓存穿透</p>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对用的value，就应该去后端系统查找（比如DB数据库）。一些恶意的请求会故意查询不存在的key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p>2、怎么解决？</p>
<p>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert之后清理缓存。</p>
<p>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。</p>
<p>3、缓存雪崩</p>
<p>当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，会给后端系统带来很大的压力，导致系统崩溃。</p>
<p>4、如何解决？</p>
<ol>
<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其它线程等待；</li>
<li>做二级缓存；</li>
<li>不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀；</li>
</ol>
<h3 id="204、怎么保证缓存和数据库数据的一致性？"><a href="#204、怎么保证缓存和数据库数据的一致性？" class="headerlink" title="204、怎么保证缓存和数据库数据的一致性？"></a>204、怎么保证缓存和数据库数据的一致性？</h3><p>1、淘汰缓存</p>
<p>数据如果为较为复杂的数据时，进行缓存的更新操作就会变得异常复杂，因此一般推荐选择淘汰缓存，而不是更新缓存。</p>
<p>2、选择先淘汰缓存，再更新数据库</p>
<p>假如先更新数据库，再淘汰缓存，如果淘汰缓存失败，那么后面的请求都会得到脏数据，直至缓存过期。</p>
<p>假如先淘汰缓存再更新数据库，如果更新数据库失败，只会产生一次缓存穿透，相比较而言，后者对业务则没有本质上的影响。</p>
<p>3、延时双删策略</p>
<p>如下场景：同时有一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>次数便出现了数据不一致问题。采用延时双删策略得以解决。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key,Object data)</span>{</span><br><span class="line">    redisUtils.del(key);</span><br><span class="line">    db.update(data);</span><br><span class="line">    Thread.Sleep(<span class="number">100</span>);</span><br><span class="line">    redisUtils.del(key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。这个时间设定可根据俄业务场景进行一个调节。</p>
<p>4、数据库读写分离的场景</p>
<p>两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求A将数据写入数据库了，</li>
<li>请求B查询缓存发现，缓存没有值</li>
<li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li>
<li>请求B将旧值写入缓存</li>
<li>数据库完成主从同步，从库变为新值</li>
</ol>
<p>依旧采用延时双删策略解决此问题。</p>
<h3 id="205、Redis，什么是缓存穿透？怎么解决？"><a href="#205、Redis，什么是缓存穿透？怎么解决？" class="headerlink" title="205、Redis，什么是缓存穿透？怎么解决？"></a>205、Redis，什么是缓存穿透？怎么解决？</h3><p>1、缓存穿透</p>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对用的value，就应该去后端系统查找（比如DB数据库）。一些恶意的请求会故意查询不存在的key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p>2、怎么解决？</p>
<p>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert之后清理缓存。</p>
<p>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。</p>
<p>3、缓存雪崩</p>
<p>当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，会给后端系统带来很大的压力，导致系统崩溃。</p>
<p>4、如何解决？</p>
<ol>
<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其它线程等待；</li>
<li>做二级缓存；</li>
<li>不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀；</li>
</ol>
<h3 id="206、Redis怎么实现分布式锁？"><a href="#206、Redis怎么实现分布式锁？" class="headerlink" title="206、Redis怎么实现分布式锁？"></a>206、Redis怎么实现分布式锁？</h3><p>使用Redis实现分布式锁</p>
<p>redis命令：set users 10 nx ex 12 原子性命令</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用uuid，解决锁释放的问题</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b_lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(b_lock){</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">"num"</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value)){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value + <span class="string">""</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"num"</span>,++num);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lockUUID</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">"lock"</span>);</span><br><span class="line">        <span class="keyword">if</span>(uuid.equals(lockUUID.toString())){</span><br><span class="line">            redisTemplate.delete(<span class="string">"lock"</span>);</span><br><span class="line">        }</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        testLock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>备注：可以通过lua脚本，保证分布式锁的原子性。</p>
<h3 id="207、Redis分布式锁有什么缺陷？"><a href="#207、Redis分布式锁有什么缺陷？" class="headerlink" title="207、Redis分布式锁有什么缺陷？"></a>207、Redis分布式锁有什么缺陷？</h3><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
<p>Redis容易产生的几个问题：</p>
<ol>
<li>锁未被释放</li>
<li>B锁被A锁释放了</li>
<li>数据库事务超时</li>
<li>锁过期了，业务还没执行完</li>
<li>Redis主从复制的问题</li>
</ol>
<h3 id="208、Redis如何做内存优化？"><a href="#208、Redis如何做内存优化？" class="headerlink" title="208、Redis如何做内存优化？"></a>208、Redis如何做内存优化？</h3><p>1、缩短键值的长度</p>
<ol>
<li>缩短值的长度才是关键，如果值是一个大的业务对象，可以将对象序列化成二进制数组；</li>
<li>首先应该在业务上进行精简，去掉不必要的属性，避免存储一些没用的数据；</li>
<li>其次是序列化的工具选择上，应该选择更高效的序列化工具来降低字节数组大小；</li>
<li>以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等</li>
</ol>
<p>2、共享对象池</p>
<p>对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。</p>
<p>3、字符串优化</p>
<p>4、编码优化</p>
<p>5、控制key的数量</p>
<blockquote>
<p>🍅 作者简介：哪吒，CSDN2021博客之星亚军🏆、新星计划导师✌、博客专家💪<br>🍅 哪吒多年工作总结：<a target="_blank" rel="noopener" href="https://blog.csdn.net/guorui_java/article/details/120098618" title="Java学习路线总结，搬砖工逆袭Java架构师">Java学习路线总结，搬砖工逆袭Java架构师</a><br>🍅 技术交流：<a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/607729516" title="定期更新Java硬核干货，不定期送书活动">定期更新Java硬核干货，不定期送书活动</a><br>🍅 <strong>关注公众号【哪吒编程】，回复 面试题</strong>，获取《10万字208道Java经典面试题总结(附答案)》 <strong>pdf</strong>，背题更方便，一文在手，面试我有</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://img-blog.csdnimg.cn/7a795a91f31b4360a55a6c2439b20141.gif"></p>
<div id="lv-container" data-id="city" data-uid="MTAyMC81OTg1MC8zNjMxMg==">
  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>
</div>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://ts1.cn.mm.bing.net/th/id/R-C.9a6de07448a467a377b44596d9ae5da0?rik=8WbMsGmKuRB5XA&amp;riu=http%3a%2f%2fpic.2265.com%2fupload%2f2021-8%2f2021810928385817.png&amp;ehk=Xi9L%2fFaaTMGPUxE7TnAHh3CKp6VDRo44YeVHbgK3Auk%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://ts1.cn.mm.bing.net/th/id/R-C.9a6de07448a467a377b44596d9ae5da0?rik=8WbMsGmKuRB5XA&amp;riu=http%3a%2f%2fpic.2265.com%2fupload%2f2021-8%2f2021810928385817.png&amp;ehk=Xi9L%2fFaaTMGPUxE7TnAHh3CKp6VDRo44YeVHbgK3Auk%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="头像" alt="头像"></a><div class="post-copyright__author_name">Mybbs —— 开源MC社区</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://bianb-hehe.github.io/2024/05/31/119299329/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://bianb-hehe.github.io/2024/05/31/119299329/')">10万字208道Java经典面试题总结(附答案)</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://bianb-hehe.github.io/2024/05/31/119299329/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=10万字208道Java经典面试题总结(附答案)&amp;url=https://bianb-hehe.github.io/2024/05/31/119299329/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://bianb-hehe.github.io" target="_blank">Mybbs</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%95%99%E7%A8%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>教程<span class="tagsPageCount">16</span></a><a class="post-meta__box__tags" href="/tags/github/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>github<span class="tagsPageCount">29</span></a><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://ts1.cn.mm.bing.net/th/id/R-C.9a6de07448a467a377b44596d9ae5da0?rik=8WbMsGmKuRB5XA&amp;riu=http%3a%2f%2fpic.2265.com%2fupload%2f2021-8%2f2021810928385817.png&amp;ehk=Xi9L%2fFaaTMGPUxE7TnAHh3CKp6VDRo44YeVHbgK3Auk%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/16/128750716/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="/" onerror="onerror=null;src='https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&amp;riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&amp;ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">csdn博客转markdown</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/31/105138570/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="/" onerror="onerror=null;src='https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&amp;riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&amp;ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Minecraft-纯净服务器搭建全流程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/04/16/128750716/" title="csdn博客转markdown"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-16</div><div class="title">csdn博客转markdown</div></div></a></div><div><a href="/2024/06/06/130442795/" title="【原创】搭建一个Chat-GPT Proxy"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-06</div><div class="title">【原创】搭建一个Chat-GPT Proxy</div></div></a></div><div><a href="/2024/05/31/18142/" title="Cloudflare Pages + Hexo 搭建个人博客"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-31</div><div class="title">Cloudflare Pages + Hexo 搭建个人博客</div></div></a></div><div><a href="/2024/05/31/18222455/" title="面试官：如果不允许线程池丢弃任务，应该选择哪个拒绝策略？"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-31</div><div class="title">面试官：如果不允许线程池丢弃任务，应该选择哪个拒绝策略？</div></div></a></div><div><a href="/2025/09/24/2589378/" title="「Disqus」为 hexo 博客添加文章推荐功能"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-09-24</div><div class="title">「Disqus」为 hexo 博客添加文章推荐功能</div></div></a></div><div><a href="/2020/05/12/4893589/" title="[github]Minecraft我的世界Spigot插件保姆级开发教程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-05-12</div><div class="title">[github]Minecraft我的世界Spigot插件保姆级开发教程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://ts1.cn.mm.bing.net/th/id/R-C.9a6de07448a467a377b44596d9ae5da0?rik=8WbMsGmKuRB5XA&amp;riu=http%3a%2f%2fpic.2265.com%2fupload%2f2021-8%2f2021810928385817.png&amp;ehk=Xi9L%2fFaaTMGPUxE7TnAHh3CKp6VDRo44YeVHbgK3Auk%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81JDK-%E5%92%8C-JRE-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">1、JDK 和 JRE 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">2、&#x3D;&#x3D; 和 equals 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81final-%E5%9C%A8-java-%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">3、final 在 java 中有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81java-%E4%B8%AD%E7%9A%84-Math-round-1-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">4、java 中的 Math.round(-1.5) 等于多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81String-%E5%B1%9E%E4%BA%8E%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">5、String 属于基础的数据类型吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81String-str-%E2%80%9Di%E2%80%9D%E4%B8%8E-String-str-new-String-%E2%80%9Ci%E2%80%9D-%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">6、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">7、如何将字符串反转？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">8、String 类的常用方法都有那些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81new-String-%E2%80%9Ca%E2%80%9D-new-String-%E2%80%9Cb%E2%80%9D-%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">9、new String(“a”) + new String(“b”) 会创建几个对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">10、如何将字符串反转？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">11、String 类的常用方法都有那些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">12、普通类和抽象类有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">13、接口和抽象类有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">14、java 中 IO 流分为几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">15、BIO、NIO、AIO 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81Files%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">16、Files的常用方法都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">17、什么是反射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-java-%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">18、什么是 java 序列化？什么情况下需要序列化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81throw-%E5%92%8C-throws-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">20、throw 和 throws 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81final%E3%80%81finally%E3%80%81finalize-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">21、final、finally、finalize 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81try-catch-finally-%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C-catch-%E4%B8%AD-return-%E4%BA%86%EF%BC%8Cfinally-%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">23、常见的异常类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81hashcode%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">24、hashcode是什么？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81java-%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">25、java 中操作字符串都有哪些类？它们之间有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81java-%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">26、java 中都有哪些引用类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BB%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">27、在 Java 中，为什么不允许从静态方法中访问非静态变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81%E8%AF%B4%E8%AF%B4Java-Bean%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">29.</span> <span class="toc-text">28、说说Java Bean的命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81Java-Bean-%E5%B1%9E%E6%80%A7%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">30.</span> <span class="toc-text">29、Java Bean 属性命名规范问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">31.</span> <span class="toc-text">30、什么是 Java 的内存模型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">31、在 Java 中，什么时候用重载，什么时候用重写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%9B%B4%E5%80%BE%E5%90%91%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">32、举例说明什么情况下会更倾向于使用抽象类而不是接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">34.</span> <span class="toc-text">33、实例化对象有哪几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81byte%E7%B1%BB%E5%9E%8B127-1%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="toc-number">35.</span> <span class="toc-text">34、byte类型127+1等于多少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81Java-%E5%AE%B9%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">35、Java 容器都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81Collection-%E5%92%8C-Collections-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">36、Collection 和 Collections 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81list%E4%B8%8ESet%E5%8C%BA%E5%88%AB"><span class="toc-number">38.</span> <span class="toc-text">37、list与Set区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81HashMap-%E5%92%8C-Hashtable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">38、HashMap 和 Hashtable 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-HashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">39、说一下 HashMap 的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81set%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">40、set有哪些实现类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-HashSet-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">41、说一下 HashSet 的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8C-List-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">43、如何实现数组和 List 之间的转换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E3%80%81%E5%9C%A8-Queue-%E4%B8%AD-poll-%E5%92%8C-remove-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">44、在 Queue 中 poll()和 remove()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E3%80%81%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">45.</span> <span class="toc-text">45、哪些集合类是线程安全的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">46、迭代器 Iterator 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47%E3%80%81Iterator-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">47、Iterator 怎么使用？有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48%E3%80%81Iterator-%E5%92%8C-ListIterator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">48、Iterator 和 ListIterator 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49%E3%80%81%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-number">49.</span> <span class="toc-text">49、怎么确保一个集合不能被修改？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">50、队列和栈是什么？有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51%E3%80%81Java8%E5%BC%80%E5%A7%8BConcurrentHashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%88%8D%E5%BC%83%E5%88%86%E6%AE%B5%E9%94%81%EF%BC%9F"><span class="toc-number">51.</span> <span class="toc-text">51、Java8开始ConcurrentHashMap,为什么舍弃分段锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E3%80%81ConcurrentHashMap-JDK1-8-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8synchronized%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A6%82ReentranLock%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E3%80%81concurrentHashMap%E5%92%8CHashTable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">53.</span> <span class="toc-text">53、concurrentHashMap和HashTable有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54%E3%80%81HasmMap%E5%92%8CHashSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">54.</span> <span class="toc-text">54、HasmMap和HashSet的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55%E3%80%81%E8%AF%B7%E8%B0%88%E8%B0%88-ReadWriteLock-%E5%92%8C-StampedLock"><span class="toc-number">55.</span> <span class="toc-text">55、请谈谈 ReadWriteLock 和 StampedLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84run-%E5%92%8Cstart-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">56.</span> <span class="toc-text">56、线程的run()和start()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">57、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58%E3%80%81Synchronized-%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%8C%E5%85%B6%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">58、Synchronized 用过吗，其原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59%E3%80%81JVM-%E5%AF%B9-Java-%E7%9A%84%E5%8E%9F%E7%94%9F%E9%94%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">59、JVM 对 Java 的原生锁做了哪些优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88-wait-notify-%E5%92%8C-notifyAll-%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">60.</span> <span class="toc-text">60、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61%E3%80%81Java-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E5%92%8C%E5%8D%8F%E4%BD%9C%EF%BC%9F"><span class="toc-number">61.</span> <span class="toc-text">61、Java 如何实现多线程之间的通讯和协作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62%E3%80%81Thread-%E7%B1%BB%E4%B8%AD%E7%9A%84-yield-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">62、Thread 类中的 yield 方法有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Synchronized-%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F"><span class="toc-number">63.</span> <span class="toc-text">63、为什么说 Synchronized 是非公平锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E3%80%81%E8%AF%B7%E8%B0%88%E8%B0%88-volatile-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%AF%B9%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-number">64.</span> <span class="toc-text">64、请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Synchronized-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF-CAS%EF%BC%8C%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">65.</span> <span class="toc-text">65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%80%E5%AE%9A%E5%B0%B1%E6%98%AF%E5%A5%BD%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">66.</span> <span class="toc-text">66、乐观锁一定就是好的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67%E3%80%81%E8%AF%B7%E5%B0%BD%E5%8F%AF%E8%83%BD%E8%AF%A6%E5%B0%BD%E5%9C%B0%E5%AF%B9%E6%AF%94%E4%B8%8B-Synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%BC%82%E5%90%8C%E3%80%82"><span class="toc-number">67.</span> <span class="toc-text">67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68%E3%80%81ReentrantLock-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">68.</span> <span class="toc-text">68、ReentrantLock 是如何实现可重入性的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E7%B2%97%E5%8C%96%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">69、什么是锁消除和锁粗化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70%E3%80%81%E8%B7%9F-Synchronized-%E7%9B%B8%E6%AF%94%EF%BC%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-ReentrantLock-%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">70.</span> <span class="toc-text">70、跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71%E3%80%81%E9%82%A3%E4%B9%88%E8%AF%B7%E8%B0%88%E8%B0%88-AQS-%E6%A1%86%E6%9E%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%E5%84%BF%EF%BC%9F"><span class="toc-number">71.</span> <span class="toc-text">71、那么请谈谈 AQS 框架是怎么回事儿？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72%E3%80%81AQS-%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">72.</span> <span class="toc-text">72、AQS 对资源的共享方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9-Java-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%BD%BC%E6%AD%A4%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-number">73.</span> <span class="toc-text">73、如何让 Java 的线程彼此同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74%E3%80%81%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%BF%87%E5%93%AA%E4%BA%9B%E5%90%8C%E6%AD%A5%E5%99%A8%EF%BC%9F%E8%AF%B7%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D%E4%B8%8B%E3%80%82"><span class="toc-number">74.</span> <span class="toc-text">74、你了解过哪些同步器？请分别介绍下。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75%E3%80%81Java-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">75.</span> <span class="toc-text">75、Java 中的线程池是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0"><span class="toc-number">76.</span> <span class="toc-text">76、创建线程池的几个核心构造参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%9F%E6%98%AF%E4%B8%80%E5%BC%80%E5%A7%8B%E5%B0%B1%E9%9A%8F%E7%9D%80%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%90%AF%E5%8A%A8%E5%88%9B%E5%BB%BA%E5%A5%BD%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">77.</span> <span class="toc-text">77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78%E3%80%81volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">78.</span> <span class="toc-text">78、volatile 关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79%E3%80%81%E6%97%A2%E7%84%B6-volatile-%E8%83%BD%E5%A4%9F%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%8F%98%E9%87%8F%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B0%B1%E6%84%8F%E5%91%B3%E7%9D%80%E5%9F%BA%E4%BA%8E-volatile-%E5%8F%98%E9%87%8F%E7%9A%84%E8%BF%90%E7%AE%97%E5%B0%B1%E6%98%AF%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">79.</span> <span class="toc-text">79、既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80%E3%80%81ThreadLocal-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">80.</span> <span class="toc-text">80、ThreadLocal 是什么？有哪些使用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81%E3%80%81%E8%AF%B7%E8%B0%88%E8%B0%88-ThreadLocal-%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">81.</span> <span class="toc-text">81、请谈谈 ThreadLocal 是怎么解决并发安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82%E3%80%81%E5%BE%88%E5%A4%9A%E4%BA%BA%E9%83%BD%E8%AF%B4%E8%A6%81%E6%85%8E%E7%94%A8-ThreadLocal%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BD%BF%E7%94%A8-ThreadLocal-%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">82.</span> <span class="toc-text">82、很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%E4%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">83.</span> <span class="toc-text">83、为什么代码会重排序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B"><span class="toc-number">84.</span> <span class="toc-text">84、什么是自旋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD-synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">85.</span> <span class="toc-text">85、多线程中 synchronized 锁升级的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86%E3%80%81synchronized-%E5%92%8C-ReentrantLock-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">86.</span> <span class="toc-text">86、synchronized 和 ReentrantLock 区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87%E3%80%81Java-Concurrency-API-%E4%B8%AD%E7%9A%84-Lock-%E6%8E%A5%E5%8F%A3-Lock-interface-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AF%B9%E6%AF%94%E5%90%8C%E6%AD%A5%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">87.</span> <span class="toc-text">87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88%E3%80%81jsp-%E5%92%8C-servlet-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">88.</span> <span class="toc-text">88、jsp 和 servlet 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89%E3%80%81jsp-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">89.</span> <span class="toc-text">89、jsp 有哪些内置对象？作用分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90%E3%80%81forward-%E5%92%8C-redirect-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">90.</span> <span class="toc-text">90、forward 和 redirect 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-jsp-%E7%9A%84-4-%E7%A7%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">91.</span> <span class="toc-text">91、说一下 jsp 的 4 种作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92%E3%80%81session-%E5%92%8C-cookie-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">92.</span> <span class="toc-text">92、session 和 cookie 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93%E3%80%81%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A6%81%E6%AD%A2-cookie-%E8%83%BD%E5%AE%9E%E7%8E%B0-session-%E8%BF%98%E8%83%BD%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">93.</span> <span class="toc-text">93、如果客户端禁止 cookie 能实现 session 还能用吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">94.</span> <span class="toc-text">94、什么是上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#95%E3%80%81cookie%E3%80%81session%E3%80%81token"><span class="toc-number">95.</span> <span class="toc-text">95、cookie、session、token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-session-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">96.</span> <span class="toc-text">96、说一下 session 的工作原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#97%E3%80%81http-%E5%93%8D%E5%BA%94%E7%A0%81-301-%E5%92%8C-302-%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">97.</span> <span class="toc-text">97、http 响应码 301 和 302 代表的是什么？有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98%E3%80%81%E7%AE%80%E8%BF%B0-tcp-%E5%92%8C-udp%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">98.</span> <span class="toc-text">98、简述 tcp 和 udp的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#99%E3%80%81tcp-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">99.</span> <span class="toc-text">99、tcp 为什么要三次握手，两次不行吗？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100%E3%80%81OSI-%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">100.</span> <span class="toc-text">100、OSI 的七层模型都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101%E3%80%81get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">101.</span> <span class="toc-text">101、get 和 post 请求有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">102.</span> <span class="toc-text">102、什么是 XSS 攻击，如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#103%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">103.</span> <span class="toc-text">103、什么是 CSRF 攻击，如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B-JSONP-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">104.</span> <span class="toc-text">104、如何实现跨域？说一下 JSONP 实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105%E3%80%81websocket%E5%BA%94%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E5%8D%8F%E8%AE%AE"><span class="toc-number">105.</span> <span class="toc-text">105、websocket应用的是哪个协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-tcp-%E7%B2%98%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">106.</span> <span class="toc-text">106、说一下 tcp 粘包是怎么产生的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#107%E3%80%81%E8%AF%B7%E5%88%97%E4%B8%BE%E5%87%BA%E5%9C%A8-JDK-%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">107.</span> <span class="toc-text">107、请列举出在 JDK 中几个常用的设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E4%BD%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E8%BF%87%E4%BB%BB%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">108.</span> <span class="toc-text">108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#109%E3%80%81Java-%E4%B8%AD%E4%BB%80%E4%B9%88%E5%8F%AB%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E8%AF%B7%E7%94%A8-Java-%E5%86%99%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">109.</span> <span class="toc-text">109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110%E3%80%81%E5%9C%A8-Java-%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E5%8F%AB%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88observer-design-pattern%EF%BC%89%EF%BC%9F"><span class="toc-number">110.</span> <span class="toc-text">110、在 Java 中，什么叫观察者设计模式（observer design pattern）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#111%E3%80%81%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">111.</span> <span class="toc-text">111、使用工厂模式最主要的好处是什么？在哪里使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112%E3%80%81%E8%AF%B7%E8%A7%A3%E9%87%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">112.</span> <span class="toc-text">112、请解释自动装配模式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113%E3%80%81%E4%B8%BE%E4%B8%80%E4%B8%AA%E7%94%A8-Java-%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-decorator-design-pattern-%EF%BC%9F%E5%AE%83%E6%98%AF%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%B1%82%E6%AC%A1%E8%BF%98%E6%98%AF%E7%B1%BB%E5%B1%82%E6%AC%A1%EF%BC%9F"><span class="toc-number">113.</span> <span class="toc-text">113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Spring-%E6%A1%86%E6%9E%B6%EF%BC%9FSpring-%E6%A1%86%E6%9E%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97%EF%BC%9F"><span class="toc-number">114.</span> <span class="toc-text">114、什么是 Spring 框架？Spring 框架有哪些主要模块？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#115%E3%80%81%E4%BD%BF%E7%94%A8-Spring-%E6%A1%86%E6%9E%B6%E8%83%BD%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">115.</span> <span class="toc-text">115、使用 Spring 框架能带来哪些好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116%E3%80%81Spring-IOC%E3%80%81AOP%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">116.</span> <span class="toc-text">116、Spring IOC、AOP举例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#117%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IOC-%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">117.</span> <span class="toc-text">117、什么是控制反转(IOC)？什么是依赖注入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#118%E3%80%81BeanFactory-%E5%92%8C-ApplicationContext-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">118.</span> <span class="toc-text">118、BeanFactory 和 ApplicationContext 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#119%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-JavaConfig%EF%BC%9F"><span class="toc-number">119.</span> <span class="toc-text">119、什么是 JavaConfig？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#120%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-ORM-%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-number">120.</span> <span class="toc-text">120、什么是 ORM 框架？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#121%E3%80%81Spring-%E6%9C%89%E5%87%A0%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">121.</span> <span class="toc-text">121、Spring 有几种配置方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122%E3%80%81%E8%AF%B7%E8%A7%A3%E9%87%8A-Spring-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">122.</span> <span class="toc-text">122、请解释 Spring Bean 的生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#123%E3%80%81Spring-Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-Spring%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84bean%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA5%E4%B8%AA%E8%8C%83%E5%9B%B4%EF%BC%9A"><span class="toc-number">123.</span> <span class="toc-text">123、Spring Bean 的作用域之间有什么区别？ Spring容器中的bean可以分为5个范围：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#124%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8-Spring-Boot-%E4%B8%AD%E7%A6%81%E7%94%A8-Actuator-%E7%AB%AF%E7%82%B9%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">124.</span> <span class="toc-text">124、如何在 Spring Boot 中禁用 Actuator 端点安全性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#125%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Spring-inner-beans%EF%BC%9F"><span class="toc-number">125.</span> <span class="toc-text">125、什么是 Spring inner beans？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#126%E3%80%81Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-Beans-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88%EF%BC%9F"><span class="toc-number">126.</span> <span class="toc-text">126、Spring 框架中的单例 Beans 是线程安全的么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#127%E3%80%81%E8%AF%B7%E8%A7%A3%E9%87%8A-Spring-Bean-%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%9F"><span class="toc-number">127.</span> <span class="toc-text">127、请解释 Spring Bean 的自动装配？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#128%E3%80%81%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%9F"><span class="toc-number">128.</span> <span class="toc-text">128、如何开启基于注解的自动装配？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#129%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Batch%EF%BC%9F"><span class="toc-number">129.</span> <span class="toc-text">129、什么是 Spring Batch？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#130%E3%80%81spring-mvc-%E5%92%8C-struts-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">130.</span> <span class="toc-text">130、spring mvc 和 struts 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#131%E3%80%81%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%A7%A3%E9%87%8A-Required-%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-number">131.</span> <span class="toc-text">131、请举例解释@Required 注解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#132%E3%80%81Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">132.</span> <span class="toc-text">132、Spring常用注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#133%E3%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E7%9A%84%EF%BC%8C%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E9%9C%80%E8%A6%81%E5%87%A0%E5%BC%A0%E8%A1%A8"><span class="toc-number">133.</span> <span class="toc-text">133、项目中是如何实现权限验证的，权限验证需要几张表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134%E3%80%81%E8%B0%88%E8%B0%88controller%EF%BC%8C%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">134.</span> <span class="toc-text">134、谈谈controller，接口调用的路径问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135%E3%80%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4"><span class="toc-number">135.</span> <span class="toc-text">135、如何防止表单重复提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#136%E3%80%81Spring%E4%B8%AD%E9%83%BD%E5%BA%94%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">136.</span> <span class="toc-text">136、Spring中都应用了哪些设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#137%E3%80%81%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%A6%82%E4%BD%95%E5%9C%A8-Spring-%E4%B8%AD%E6%B3%A8%E5%85%A5%E4%B8%80%E4%B8%AA-Java-Collection%EF%BC%9F"><span class="toc-number">137.</span> <span class="toc-text">137、请举例说明如何在 Spring 中注入一个 Java Collection？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#138%E3%80%81mybatis-%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">138.</span> <span class="toc-text">138、mybatis 中 #{}和 ${}的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#139%E3%80%81mybatis-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">139.</span> <span class="toc-text">139、mybatis 是否支持延迟加载？延迟加载的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#140%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-mybatis-%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">140.</span> <span class="toc-text">140、说一下 mybatis 的一级缓存和二级缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#141%E3%80%81mybatis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%88Executor%EF%BC%89%EF%BC%9F"><span class="toc-number">141.</span> <span class="toc-text">141、mybatis 有哪些执行器（Executor）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142%E3%80%81mybatis-%E5%92%8C-hibernate-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">142.</span> <span class="toc-text">142、mybatis 和 hibernate 的区别有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#143%E3%80%81myBatis%E6%9F%A5%E8%AF%A2%E5%A4%9A%E4%B8%AAid%E3%80%81myBatis%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">143.</span> <span class="toc-text">143、myBatis查询多个id、myBatis常用属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#144%E3%80%81mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">144.</span> <span class="toc-text">144、mybatis一级缓存、二级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#145%E3%80%81mybatis%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5"><span class="toc-number">145.</span> <span class="toc-text">145、mybatis如何防止sql注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#146%E3%80%81hibernate-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E6%89%93%E5%8D%B0%E7%9A%84-sql-%E8%AF%AD%E5%8F%A5%EF%BC%9F"><span class="toc-number">146.</span> <span class="toc-text">146、hibernate 中如何在控制台查看打印的 sql 语句？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#147%E3%80%81hibernate-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">147.</span> <span class="toc-text">147、hibernate 有几种查询方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#148%E3%80%81hibernate-%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AE%9A%E4%B9%89%E4%B8%BA-final-%E5%90%97%EF%BC%9F"><span class="toc-number">148.</span> <span class="toc-text">148、hibernate 实体类可以被定义为 final 吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#149%E3%80%81%E5%9C%A8-hibernate-%E4%B8%AD%E4%BD%BF%E7%94%A8-Integer-%E5%92%8C-int-%E5%81%9A%E6%98%A0%E5%B0%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">149.</span> <span class="toc-text">149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#150%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Boot%EF%BC%9FSpring-Boot-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">150.</span> <span class="toc-text">150、什么是 Spring Boot？Spring Boot 有哪些优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#151%E3%80%81Spring-Boot-%E4%B8%AD%E7%9A%84%E7%9B%91%E8%A7%86%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">151.</span> <span class="toc-text">151、Spring Boot 中的监视器是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#152%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-YAML%EF%BC%9F"><span class="toc-number">152.</span> <span class="toc-text">152、什么是 YAML？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#153%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Spring-Boot-%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E5%92%8C%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">153.</span> <span class="toc-text">153、如何使用 Spring Boot 实现分页和排序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#154%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Spring-Boot-%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">154.</span> <span class="toc-text">154、如何使用 Spring Boot 实现异常处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#155%E3%80%81%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">155.</span> <span class="toc-text">155、单点登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#156%E3%80%81Spring-Boot%E6%AF%94Spring%E5%A4%9A%E5%93%AA%E4%BA%9B%E6%B3%A8%E8%A7%A3"><span class="toc-number">156.</span> <span class="toc-text">156、Spring Boot比Spring多哪些注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#157%E3%80%81%E6%89%93%E5%8C%85%E5%92%8C%E9%83%A8%E7%BD%B2"><span class="toc-number">157.</span> <span class="toc-text">157、打包和部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#158%E3%80%81Spring-Boot%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">158.</span> <span class="toc-text">158、Spring Boot如何访问不同的数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#159%E3%80%81%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99%E5%9C%A8%E7%BA%BF%E4%BA%BA%E6%95%B0"><span class="toc-number">159.</span> <span class="toc-text">159、查询网站在线人数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#160%E3%80%81easyExcel%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">160.</span> <span class="toc-text">160、easyExcel如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#161%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Swagger%EF%BC%9F%E4%BD%A0%E7%94%A8-Spring-Boot-%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%AE%83%E5%90%97%EF%BC%9F"><span class="toc-number">161.</span> <span class="toc-text">161、什么是 Swagger？你用 Spring Boot 实现了它吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#162%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">162.</span> <span class="toc-text">162、数据库的三范式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#163%E3%80%81%E4%B8%80%E5%BC%A0%E8%87%AA%E5%A2%9E%E8%A1%A8%E9%87%8C%E9%9D%A2%E6%80%BB%E5%85%B1%E6%9C%89-7-%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%A0%E9%99%A4%E4%BA%86%E6%9C%80%E5%90%8E-2-%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E9%87%8D%E5%90%AF-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%8F%88%E6%8F%92%E5%85%A5%E4%BA%86%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%AD%A4%E6%97%B6-id-%E6%98%AF%E5%87%A0%EF%BC%9F"><span class="toc-number">163.</span> <span class="toc-text">163、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#164%E3%80%81%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%EF%BC%9F"><span class="toc-number">164.</span> <span class="toc-text">164、如何获取当前数据库版本？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#165%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-ACID-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">165.</span> <span class="toc-text">165、说一下 ACID 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#166%E3%80%81char-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">166.</span> <span class="toc-text">166、char 和 varchar 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#167%E3%80%81float-%E5%92%8C-double-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">167.</span> <span class="toc-text">167、float 和 double 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#168%E3%80%81Oracle%E5%88%86%E9%A1%B5sql"><span class="toc-number">168.</span> <span class="toc-text">168、Oracle分页sql</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#169%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%BB%E9%94%AE%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-number">169.</span> <span class="toc-text">169、数据库如何保证主键唯一性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#170%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">170.</span> <span class="toc-text">170、如何设计数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#171%E3%80%81%E6%80%A7%E5%88%AB%E6%98%AF%E5%90%A6%E9%80%82%E5%90%88%E5%81%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">171.</span> <span class="toc-text">171、性别是否适合做索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#172%E3%80%81%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">172.</span> <span class="toc-text">172、如何查询重复的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#173%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%88%AC%E4%BC%9A%E9%87%87%E5%8F%96%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">173.</span> <span class="toc-text">173、数据库一般会采取什么样的优化方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#174%E3%80%81%E7%B4%A2%E5%BC%95%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%88%86%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">174.</span> <span class="toc-text">174、索引怎么定义，分哪几种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#175%E3%80%81mysql-%E7%9A%84%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">175.</span> <span class="toc-text">175、mysql 的内连接、左连接、右连接有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#176%E3%80%81RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">176.</span> <span class="toc-text">176、RabbitMQ的使用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#177%E3%80%81RabbitMQ%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E8%A7%92%E8%89%B2%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">177.</span> <span class="toc-text">177、RabbitMQ有哪些重要的角色？有哪些重要的组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#178%E3%80%81RabbitMQ%E4%B8%AD-vhost-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">178.</span> <span class="toc-text">178、RabbitMQ中 vhost 的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#179%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-jvm-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%9F%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">179.</span> <span class="toc-text">179、说一下 jvm 的主要组成部分？及其作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#180%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%9F"><span class="toc-number">180.</span> <span class="toc-text">180、说一下 jvm 运行时数据区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#181%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">181.</span> <span class="toc-text">181、什么是类加载器，类加载器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#182%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">182.</span> <span class="toc-text">182、说一下类加载的执行过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#183%E3%80%81JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">183.</span> <span class="toc-text">183、JVM的类加载机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#184%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">184.</span> <span class="toc-text">184、什么是双亲委派模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#185%E3%80%81%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">185.</span> <span class="toc-text">185、怎么判断对象是否可以被回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#186%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-jvm-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">186.</span> <span class="toc-text">186、说一下 jvm 有哪些垃圾回收算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#187%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B-jvm-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">187.</span> <span class="toc-text">187、说一下 jvm 有哪些垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#188%E3%80%81JVM%E6%A0%88%E5%A0%86%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%BD%95%E6%97%B6%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">188.</span> <span class="toc-text">188、JVM栈堆概念，何时销毁对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#189%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E8%80%81%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">189.</span> <span class="toc-text">189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#190%E3%80%81%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">190.</span> <span class="toc-text">190、详细介绍一下 CMS 垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#191%E3%80%81%E7%AE%80%E8%BF%B0%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">191.</span> <span class="toc-text">191、简述分代垃圾回收器是怎么工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#192%E3%80%81Redis%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">192.</span> <span class="toc-text">192、Redis是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#193%E3%80%81Redis%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">193.</span> <span class="toc-text">193、Redis都有哪些使用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#194%E3%80%81Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">194.</span> <span class="toc-text">194、Redis有哪些功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#195%E3%80%81Redis%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">195.</span> <span class="toc-text">195、Redis支持的数据类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#196%E3%80%81Redis%E5%8F%96%E5%80%BC%E5%AD%98%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">196.</span> <span class="toc-text">196、Redis取值存值问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#197%E3%80%81Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">197.</span> <span class="toc-text">197、Redis为什么是单线程的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#198%E3%80%81Redis%E7%9C%9F%E7%9A%84%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">198.</span> <span class="toc-text">198、Redis真的是单线程的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#199%E3%80%81Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">199.</span> <span class="toc-text">199、Redis持久化有几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#200%E3%80%81Redis%E5%92%8C-memecache-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">200.</span> <span class="toc-text">200、Redis和 memecache 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#201%E3%80%81Redis%E6%94%AF%E6%8C%81%E7%9A%84-java-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">201.</span> <span class="toc-text">201、Redis支持的 java 客户端都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#202%E3%80%81jedis-%E5%92%8C-redisson-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">202.</span> <span class="toc-text">202、jedis 和 redisson 有哪些区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#203%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">203.</span> <span class="toc-text">203、什么是缓存穿透？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#204%E3%80%81%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">204.</span> <span class="toc-text">204、怎么保证缓存和数据库数据的一致性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#205%E3%80%81Redis%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">205.</span> <span class="toc-text">205、Redis，什么是缓存穿透？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206%E3%80%81Redis%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">206.</span> <span class="toc-text">206、Redis怎么实现分布式锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#207%E3%80%81Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">207.</span> <span class="toc-text">207、Redis分布式锁有什么缺陷？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#208%E3%80%81Redis%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">208.</span> <span class="toc-text">208、Redis如何做内存优化？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/05/26/8684/" title="[Github] MCBBS-Client">[Github] MCBBS-Client</a><time datetime="2026-05-26T05:03:32.000Z" title="发表于 2026-05-26 13:03:32">2026-05-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/24/2589378/" title="「Disqus」为 hexo 博客添加文章推荐功能">「Disqus」为 hexo 博客添加文章推荐功能</a><time datetime="2025-09-23T20:17:35.000Z" title="发表于 2025-09-24 04:17:35">2025-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/24/28523795/" title="「视频」MC绷带指令">「视频」MC绷带指令</a><time datetime="2025-09-23T20:17:35.000Z" title="发表于 2025-09-24 04:17:35">2025-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/07/GriefDefender/" title="GriefDefender | 支持混合端且功能丰富强大的领地插件">GriefDefender | 支持混合端且功能丰富强大的领地插件</a><time datetime="2025-04-07T04:12:13.000Z" title="发表于 2025-04-07 12:12:13">2025-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/25/57892389/" title="「教程」在Deepin（Linux）下如何优雅地查词典？—— sdcv ⚡📚">「教程」在Deepin（Linux）下如何优雅地查词典？—— sdcv ⚡📚</a><time datetime="2025-02-25T06:04:55.000Z" title="发表于 2025-02-25 14:04:55">2025-02-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Mybbs —— 开源MC社区" target="_blank">Mybbs —— 开源MC社区</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">8</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">推荐网站</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://tse1-mm.cn.bing.net/th/id/OIP-C.NGIDdVP6vw9ue_D-mrEVFQHaHa?rs=1&amp;pid=ImgDetMainhttps://tse1-mm.cn.bing.net/th/id/OIP-C.NGIDdVP6vw9ue_D-mrEVFQHaHa?rs=1&amp;pid=ImgDetMain" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">暂无</div><div class="back-menu-list"><a class="back-menu-item" href="/%E9%83%BD%E8%AF%B4%E4%BA%86%E6%9A%82%E6%97%A0%E4%BA%86%EF%BC%81" title="暂无"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&risl=&pid=ImgRaw&r=0&quot;" data-lazy-src="https://ts1.cn.mm.bing.net/th/id/R-C.7b1a08b9cad671ec7cd3f40a937cf90c?rik=bscFCAJCax1ZJg&amp;riu=http%3a%2f%2fbpic.588ku.com%2felement_pic%2f19%2f03%2f29%2f32fd5b5d10ca51980988fedeb9ecd694.jpg&amp;ehk=EBfBi6AGEGxpmzZ4S6BvITM75dU67ZEekiA%2bh0bxbtc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="暂无"/><span class="back-menu-item-text">暂无</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 本站</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 首页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/HTML/4238948.html"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 帮助</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&amp;k=AVD1Y5VnrY8z603_1dFsQrHfY1Uodp1O&amp;authKey=bX2RSjVq%2BYvjD2fsZ3PpEz4r2UAeV0e4lMLr4gTi7agxGPNsEfOP2M%2F%2Bw7i1mryp&amp;noverify=0&amp;group_code=565126072"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 交流群</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 帖子</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 帖子</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 板块</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/HTML/index1.html"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 发帖子</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 更多</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/HTML/tc.html"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 图床</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.pixelbbs.cn/source/plugin/bphp_clouds/upload/4438/20240601/417cb596663d3d5bf57708af2fa16eba.zip"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 源码</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/HTML/30588.html"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 导航站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/HTML/index2.html"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 服务器</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/HTML/gl.html"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 个人中心</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 小游戏</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/HTML/tcs.html"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 2048</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/HTML/tcc.html"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 贪吃蛇</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CSDN/" style="font-size: 0.88rem;">CSDN<sup>1</sup></a><a href="/tags/MC/" style="font-size: 0.88rem;">MC<sup>14</sup></a><a href="/tags/Mod/" style="font-size: 0.88rem;">Mod<sup>1</sup></a><a href="/tags/blog/" style="font-size: 0.88rem;">blog<sup>1</sup></a><a href="/tags/github/" style="font-size: 0.88rem;">github<sup>29</sup></a><a href="/tags/hexo/" style="font-size: 0.88rem;">hexo<sup>4</sup></a><a href="/tags/hexo%E4%B8%BB%E9%A2%98/" style="font-size: 0.88rem;">hexo主题<sup>9</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>1</sup></a><a href="/tags/paper/" style="font-size: 0.88rem;">paper<sup>1</sup></a><a href="/tags/%E4%BC%91%E9%97%B2/" style="font-size: 0.88rem;">休闲<sup>1</sup></a><a href="/tags/%E5%88%86%E4%BA%AB/" style="font-size: 0.88rem;">分享<sup>5</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">工具<sup>4</sup></a><a href="/tags/%E6%89%98%E7%AE%A1/" style="font-size: 0.88rem;">托管<sup>1</sup></a><a href="/tags/%E6%8E%A8%E8%8D%90/" style="font-size: 0.88rem;">推荐<sup>1</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 0.88rem;">插件<sup>2</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">教程<sup>16</sup></a><a href="/tags/%E6%95%B4%E5%90%88%E5%8C%85/" style="font-size: 0.88rem;">整合包<sup>3</sup></a><a href="/tags/%E6%96%B0%E9%97%BB/" style="font-size: 0.88rem;">新闻<sup>2</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 0.88rem;">服务器<sup>2</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/" style="font-size: 0.88rem;">服务端<sup>1</sup></a><a href="/tags/%E7%B2%BE%E5%93%81/" style="font-size: 0.88rem;">精品<sup>3</sup></a><a href="/tags/%E8%A7%86%E9%A2%91/" style="font-size: 0.88rem;">视频<sup>1</sup></a><a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 0.88rem;">转载<sup>9</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Mybbs —— 开源MC社区 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "2898734480@qq.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>